import {
  COORDINATE_SYSTEM,
  CompositeLayer,
  CubeGeometry,
  Geometry,
  Layer,
  Model,
  Tesselator,
  UNIT,
  createIterable,
  load,
  log,
  log_default,
  picking_default,
  project32_default
} from "./chunk-2V2T5TYC.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i2 = dim; i2 < outerLen; i2 += dim) {
          x2 = data[i2];
          y2 = data[i2 + 1];
          if (x2 < minX) minX = x2;
          if (y2 < minY) minY = y2;
          if (x2 > maxX) maxX = x2;
          if (y2 > maxY) maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i2, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i2 = start; i2 < end; i2 += dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
      } else {
        for (i2 = end - dim; i2 >= start; i2 -= dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
      }
      if (last && equals8(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals8(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next) break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0) return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c2.next;
      while (p2 !== a2) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0) return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p2 = start;
      do {
        var a2 = p2.prev, b2 = p2.next.next;
        if (!equals8(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
          triangles.push(a2.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start = b2;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints(p2);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b2 = a2.next.next;
        while (b2 !== a2.prev) {
          if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
            var c2 = splitPolygon(a2, b2);
            a2 = filterPoints(a2, a2.next);
            c2 = filterPoints(c2, c2.next);
            earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i2, len5, start, end, list;
      for (i2 = 0, len5 = holeIndices.length; i2 < len5; i2++) {
        start = holeIndices[i2] * dim;
        end = i2 < len5 - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i2 = 0; i2 < queue.length; i2++) {
        outerNode = eliminateHole(queue[i2], outerNode);
      }
      return outerNode;
    }
    function compareX(a2, b2) {
      return a2.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m2 = p2.x < p2.next.x ? p2 : p2.next;
            if (x2 === hx) return m2;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m2) return null;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
      p2 = m2;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
            m2 = p2;
            tanMin = tan2;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p2) {
      return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q2 = p2;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
              e2 = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e2 = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e2;
            else list = e2;
            e2.prevZ = tail;
            tail = e2;
          }
          p2 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a2, b2) {
      return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
      (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
      (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
      equals8(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
    }
    function area(p2, q2, r2) {
      return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
    }
    function equals8(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;
      return false;
    }
    function onSegment(p2, q2, r2) {
      return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a2, b2) {
      var p2 = a2;
      do {
        if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
        p2 = p2.next;
      } while (p2 !== a2);
      return false;
    }
    function locallyInside(a2, b2) {
      return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
    }
    function middleInside(a2, b2) {
      var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a2);
      return inside;
    }
    function splitPolygon(a2, b2) {
      var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
      a2.next = b2;
      b2.prev = a2;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i2, x2, y2, last) {
      var p2 = new Node(i2, x2, y2);
      if (!last) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i2, x2, y2) {
      this.i = i2;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i2 = 0, len5 = holeIndices.length; i2 < len5; i2++) {
          var start = holeIndices[i2] * dim;
          var end = i2 < len5 - 1 ? holeIndices[i2 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i2 = 0; i2 < triangles.length; i2 += 3) {
        var a2 = triangles[i2] * dim;
        var b2 = triangles[i2 + 1] * dim;
        var c2 = triangles[i2 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
        sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
        j2 = i2;
      }
      return sum;
    }
    earcut3.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i2 = 0; i2 < data.length; i2++) {
        for (var j2 = 0; j2 < data[i2].length; j2++) {
          for (var d2 = 0; d2 < dim; d2++) result.vertices.push(data[i2][j2][d2]);
        }
        if (i2 > 0) {
          holeIndex += data[i2 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-uniforms.js
var uniformBlock = `uniform arcUniforms {
  bool greatCircle;
  bool useShortestPath;
  float numSegments;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int widthUnits;
} arc;
`;
var arcUniforms = {
  name: "arc",
  vs: uniformBlock,
  fs: uniformBlock,
  uniformTypes: {
    greatCircle: "f32",
    useShortestPath: "f32",
    numSegments: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-vertex.glsl.js
var arc_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = float(gl_VertexID / 2);
float segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, segmentSide);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (arc.useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (arc.useShortestPath) {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (arc.useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),
arc.widthMinPixels, arc.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-fragment.glsl.js
var arc_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer.js
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  getSourcePosition: { type: "accessor", value: (x2) => x2.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x2) => x2.targetPosition },
  getSourceColor: { type: "accessor", value: DEFAULT_COLOR },
  getTargetColor: { type: "accessor", value: DEFAULT_COLOR },
  getWidth: { type: "accessor", value: 1 },
  getHeight: { type: "accessor", value: 1 },
  getTilt: { type: "accessor", value: 0 },
  greatCircle: false,
  numSegments: { type: "number", value: 50, min: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var ArcLayer = class extends Layer {
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: arc_layer_vertex_glsl_default, fs: arc_layer_fragment_glsl_default, modules: [project32_default, picking_default, arcUniforms] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getSourceColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getTargetColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: "getHeight",
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: "getTilt",
        defaultValue: 0
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle, wrapLongitude, numSegments } = this.props;
    const arcProps = {
      numSegments,
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      greatCircle,
      useShortestPath: wrapLongitude
    };
    const model = this.state.model;
    model.shaderInputs.setProps({ arc: arcProps });
    model.setVertexCount(numSegments * 2);
    model.draw(this.context.renderPass);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-strip",
      isInstanced: true
    });
  }
};
ArcLayer.layerName = "ArcLayer";
ArcLayer.defaultProps = defaultProps;
var arc_layer_default = ArcLayer;

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/lib/common.js
var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var DEFAULT_CONFIG = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true,
  _cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
var config = globalThis.mathgl.config;
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function lerp(a2, b2, t2) {
  if (isArray(a2)) {
    return a2.map((ai, i2) => lerp(ai, b2[i2], t2));
  }
  return t2 * b2 + (1 - t2) * a2;
}

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add,
  angle: () => angle,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp2,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotate: () => rotate,
  round: () => round2,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  zero: () => zero
});

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function round(a2) {
  if (a2 >= 0)
    return Math.round(a2);
  return a2 % 0.5 === 0 ? Math.floor(a2) : Math.round(a2);
}
var degree = Math.PI / 180;

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
function create() {
  const out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone(a2) {
  const out = new ARRAY_TYPE(2);
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function fromValues(x2, y2) {
  const out = new ARRAY_TYPE(2);
  out[0] = x2;
  out[1] = y2;
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function set(out, x2, y2) {
  out[0] = x2;
  out[1] = y2;
  return out;
}
function add(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  return out;
}
function subtract(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  return out;
}
function multiply(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  return out;
}
function divide(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  return out;
}
function min(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  return out;
}
function max(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  return out;
}
function round2(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  return out;
}
function scale(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  return out;
}
function scaleAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  return out;
}
function distance(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function squaredDistance(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return x2 * x2 + y2 * y2;
}
function length(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function squaredLength(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return x2 * x2 + y2 * y2;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  return out;
}
function normalize(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  let len5 = x2 * x2 + y2 * y2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  return out;
}
function dot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1];
}
function cross(out, a2, b2) {
  const z2 = a2[0] * b2[1] - a2[1] * b2[0];
  out[0] = out[1] = 0;
  out[2] = z2;
  return out;
}
function lerp2(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  return out;
}
function random(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  const r2 = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r2) * scale7;
  out[1] = Math.sin(r2) * scale7;
  return out;
}
function transformMat2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  return out;
}
function transformMat2d(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
  out[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
  return out;
}
function transformMat3(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
  return out;
}
function transformMat4(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[12];
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[13];
  return out;
}
function rotate(out, a2, b2, rad) {
  const p0 = a2[0] - b2[0];
  const p1 = a2[1] - b2[1];
  const sinC = Math.sin(rad);
  const cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b2[0];
  out[1] = p0 * sinC + p1 * cosC + b2[1];
  return out;
}
function angle(a2, b2) {
  const x1 = a2[0];
  const y1 = a2[1];
  const x2 = b2[0];
  const y2 = b2[1];
  const mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));
  const cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str(a2) {
  return `vec2(${a2[0]}, ${a2[1]})`;
}
function exactEquals(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1];
}
function equals2(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const b0 = b2[0];
  const b1 = b2[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len = length;
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach = function() {
  const vec = create();
  return function(a2, stride, offset, count, fn, arg) {
    let i2;
    let l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
    }
    return a2;
  };
}();

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle2,
  bezier: () => bezier,
  ceil: () => ceil2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp3,
  max: () => max2,
  min: () => min2,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round3,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set2,
  slerp: () => slerp,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat,
  zero: () => zero2
});
function create2() {
  const out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a2) {
  const out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length2(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function fromValues2(x2, y2, z2) {
  const out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function copy2(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set2(out, x2, y2, z2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function add2(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  return out;
}
function subtract2(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  return out;
}
function multiply2(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  return out;
}
function divide2(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  out[2] = a2[2] / b2[2];
  return out;
}
function ceil2(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor2(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min2(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  return out;
}
function max2(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  return out;
}
function round3(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  out[2] = round(a2[2]);
  return out;
}
function scale2(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  return out;
}
function scaleAndAdd2(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  return out;
}
function distance2(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function squaredDistance2(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function squaredLength2(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function negate2(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse2(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize2(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let len5 = x2 * x2 + y2 * y2 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  out[2] = a2[2] * len5;
  return out;
}
function dot2(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cross2(out, a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp3(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  out[2] = az + t2 * (b2[2] - az);
  return out;
}
function slerp(out, a2, b2, t2) {
  const angle3 = Math.acos(Math.min(Math.max(dot2(a2, b2), -1), 1));
  const sinTotal = Math.sin(angle3);
  const ratioA = Math.sin((1 - t2) * angle3) / sinTotal;
  const ratioB = Math.sin(t2 * angle3) / sinTotal;
  out[0] = ratioA * a2[0] + ratioB * b2[0];
  out[1] = ratioA * a2[1] + ratioB * b2[1];
  out[2] = ratioA * a2[2] + ratioB * b2[2];
  return out;
}
function hermite(out, a2, b2, c2, d2, t2) {
  const factorTimes2 = t2 * t2;
  const factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  const factor2 = factorTimes2 * (t2 - 2) + t2;
  const factor3 = factorTimes2 * (t2 - 1);
  const factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a2, b2, c2, d2, t2) {
  const inverseFactor = 1 - t2;
  const inverseFactorTimesTwo = inverseFactor * inverseFactor;
  const factorTimes2 = t2 * t2;
  const factor1 = inverseFactorTimesTwo * inverseFactor;
  const factor2 = 3 * t2 * inverseFactorTimesTwo;
  const factor3 = 3 * factorTimes2 * inverseFactor;
  const factor4 = factorTimes2 * t2;
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function random2(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  const r2 = RANDOM() * 2 * Math.PI;
  const z2 = RANDOM() * 2 - 1;
  const zScale = Math.sqrt(1 - z2 * z2) * scale7;
  out[0] = Math.cos(r2) * zScale;
  out[1] = Math.sin(r2) * zScale;
  out[2] = z2 * scale7;
  return out;
}
function transformMat42(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let w2 = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15];
  w2 = w2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12]) / w2;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13]) / w2;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14]) / w2;
  return out;
}
function transformMat32(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  out[0] = x2 * m2[0] + y2 * m2[3] + z2 * m2[6];
  out[1] = x2 * m2[1] + y2 * m2[4] + z2 * m2[7];
  out[2] = x2 * m2[2] + y2 * m2[5] + z2 * m2[8];
  return out;
}
function transformQuat(out, a2, q2) {
  const qx = q2[0];
  const qy = q2[1];
  const qz = q2[2];
  const qw = q2[3];
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let uvx = qy * z2 - qz * y2;
  let uvy = qz * x2 - qx * z2;
  let uvz = qx * y2 - qy * x2;
  let uuvx = qy * uvz - qz * uvy;
  let uuvy = qz * uvx - qx * uvz;
  let uuvz = qx * uvy - qy * uvx;
  const w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x2 + uvx + uuvx;
  out[1] = y2 + uvy + uuvy;
  out[2] = z2 + uvz + uuvz;
  return out;
}
function rotateX(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[0];
  r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function rotateY(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r2[1] = p2[1];
  r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function rotateZ(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r2[2] = p2[2];
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function angle2(a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
  const cosine = mag && dot2(a2, b2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a2) {
  return `vec3(${a2[0]}, ${a2[1]}, ${a2[2]})`;
}
function exactEquals2(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2];
}
function equals3(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  const vec = create2();
  return function(a2, stride, offset, count, fn, arg) {
    let i2;
    let l2;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
    }
    return a2;
  };
}();

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add3,
  adjoint: () => adjoint,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  determinant: () => determinant,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues3,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul3,
  multiply: () => multiply3,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate2,
  scale: () => scale3,
  set: () => set3,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  translate: () => translate,
  transpose: () => transpose
});
function create3() {
  const out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[4];
  out[4] = a2[5];
  out[5] = a2[6];
  out[6] = a2[8];
  out[7] = a2[9];
  out[8] = a2[10];
  return out;
}
function clone3(a2) {
  const out = new ARRAY_TYPE(9);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function copy3(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromValues3(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  const out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set3(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a12 = a2[5];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a01;
    out[5] = a2[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a2[0];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a2[1];
    out[4] = a2[4];
    out[5] = a2[7];
    out[6] = a2[2];
    out[7] = a2[5];
    out[8] = a2[8];
  }
  return out;
}
function invert(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b01 = a22 * a11 - a12 * a21;
  const b11 = -a22 * a10 + a12 * a20;
  const b21 = a21 * a10 - a11 * a20;
  let det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply3(out, a2, b2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b00 = b2[0];
  const b01 = b2[1];
  const b02 = b2[2];
  const b10 = b2[3];
  const b11 = b2[4];
  const b12 = b2[5];
  const b20 = b2[6];
  const b21 = b2[7];
  const b22 = b2[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a2, v2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const x2 = v2[0];
  const y2 = v2[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x2 * a00 + y2 * a10 + a20;
  out[7] = x2 * a01 + y2 * a11 + a21;
  out[8] = x2 * a02 + y2 * a12 + a22;
  return out;
}
function rotate2(out, a2, rad) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2 * a00 + s2 * a10;
  out[1] = c2 * a01 + s2 * a11;
  out[2] = c2 * a02 + s2 * a12;
  out[3] = c2 * a10 - s2 * a00;
  out[4] = c2 * a11 - s2 * a01;
  out[5] = c2 * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale3(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  out[0] = x2 * a2[0];
  out[1] = x2 * a2[1];
  out[2] = x2 * a2[2];
  out[3] = y2 * a2[3];
  out[4] = y2 * a2[4];
  out[5] = y2 * a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v2[0];
  out[7] = v2[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c2;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v2[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = 0;
  out[3] = a2[2];
  out[4] = a2[3];
  out[5] = 0;
  out[6] = a2[4];
  out[7] = a2[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const yx = y2 * x22;
  const yy = y2 * y22;
  const zx = z2 * x22;
  const zy = z2 * y22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str3(a2) {
  return `mat3(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]}, ${a2[4]}, ${a2[5]}, ${a2[6]}, ${a2[7]}, ${a2[8]})`;
}
function frob(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8]);
}
function add3(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  out[4] = a2[4] + b2[4];
  out[5] = a2[5] + b2[5];
  out[6] = a2[6] + b2[6];
  out[7] = a2[7] + b2[7];
  out[8] = a2[8] + b2[8];
  return out;
}
function subtract3(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  out[4] = a2[4] - b2[4];
  out[5] = a2[5] - b2[5];
  out[6] = a2[6] - b2[6];
  out[7] = a2[7] - b2[7];
  out[8] = a2[8] - b2[8];
  return out;
}
function multiplyScalar(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  out[4] = a2[4] * b2;
  out[5] = a2[5] * b2;
  out[6] = a2[6] * b2;
  out[7] = a2[7] * b2;
  out[8] = a2[8] * b2;
  return out;
}
function multiplyScalarAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  out[4] = a2[4] + b2[4] * scale7;
  out[5] = a2[5] + b2[5] * scale7;
  out[6] = a2[6] + b2[6] * scale7;
  out[7] = a2[7] + b2[7] * scale7;
  out[8] = a2[8] + b2[8] * scale7;
  return out;
}
function exactEquals3(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3] && a2[4] === b2[4] && a2[5] === b2[5] && a2[6] === b2[6] && a2[7] === b2[7] && a2[8] === b2[8];
}
function equals4(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const a4 = a2[4];
  const a5 = a2[5];
  const a6 = a2[6];
  const a7 = a2[7];
  const a8 = a2[8];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  const b4 = b2[4];
  const b5 = b2[5];
  const b6 = b2[6];
  const b7 = b2[7];
  const b8 = b2[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul3 = multiply3;
var sub3 = subtract3;

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/classes/matrix3.js
var INDICES;
(function(INDICES3) {
  INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
  INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
  INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
  INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
  INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
  INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
})(INDICES || (INDICES = {}));
var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add4,
  adjoint: () => adjoint2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  decompose: () => decompose,
  determinant: () => determinant2,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues4,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul4,
  multiply: () => multiply4,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate3,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  scale: () => scale4,
  set: () => set4,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create4() {
  const out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone4(a2) {
  const out = new ARRAY_TYPE(16);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function copy4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function fromValues4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  const out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set4(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a03 = a2[3];
    const a12 = a2[6];
    const a13 = a2[7];
    const a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert2(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant2(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b0 = a00 * a11 - a01 * a10;
  const b1 = a00 * a12 - a02 * a10;
  const b2 = a01 * a12 - a02 * a11;
  const b3 = a20 * a31 - a21 * a30;
  const b4 = a20 * a32 - a22 * a30;
  const b5 = a21 * a32 - a22 * a31;
  const b6 = a00 * b5 - a01 * b4 + a02 * b3;
  const b7 = a10 * b5 - a11 * b4 + a12 * b3;
  const b8 = a20 * b2 - a21 * b1 + a22 * b0;
  const b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply4(out, a2, b2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  let b0 = b2[0];
  let b1 = b2[1];
  let b22 = b2[2];
  let b3 = b2[3];
  out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[4];
  b1 = b2[5];
  b22 = b2[6];
  b3 = b2[7];
  out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[8];
  b1 = b2[9];
  b22 = b2[10];
  b3 = b2[11];
  out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[12];
  b1 = b2[13];
  b22 = b2[14];
  b3 = b2[15];
  out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  return out;
}
function translate2(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  const z2 = v2[2];
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  if (a2 === out) {
    out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z2 + a2[12];
    out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z2 + a2[13];
    out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z2 + a2[14];
    out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z2 + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y2 + a20 * z2 + a2[12];
    out[13] = a01 * x2 + a11 * y2 + a21 * z2 + a2[13];
    out[14] = a02 * x2 + a12 * y2 + a22 * z2 + a2[14];
    out[15] = a03 * x2 + a13 * y2 + a23 * z2 + a2[15];
  }
  return out;
}
function scale4(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  const z2 = v2[2];
  out[0] = a2[0] * x2;
  out[1] = a2[1] * x2;
  out[2] = a2[2] * x2;
  out[3] = a2[3] * x2;
  out[4] = a2[4] * y2;
  out[5] = a2[5] * y2;
  out[6] = a2[6] * y2;
  out[7] = a2[7] * y2;
  out[8] = a2[8] * z2;
  out[9] = a2[9] * z2;
  out[10] = a2[10] * z2;
  out[11] = a2[11] * z2;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate3(out, a2, rad, axis) {
  let x2 = axis[0];
  let y2 = axis[1];
  let z2 = axis[2];
  let len5 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  let c2;
  let s2;
  let t2;
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  let b00;
  let b01;
  let b02;
  let b10;
  let b11;
  let b12;
  let b20;
  let b21;
  let b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x2 *= len5;
  y2 *= len5;
  z2 *= len5;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t2 = 1 - c2;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x2 * x2 * t2 + c2;
  b01 = y2 * x2 * t2 + z2 * s2;
  b02 = z2 * x2 * t2 - y2 * s2;
  b10 = x2 * y2 * t2 - z2 * s2;
  b11 = y2 * y2 * t2 + c2;
  b12 = z2 * y2 * t2 + x2 * s2;
  b20 = x2 * z2 * t2 + y2 * s2;
  b21 = y2 * z2 * t2 - x2 * s2;
  b22 = z2 * z2 * t2 + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c2 + a20 * s2;
  out[5] = a11 * c2 + a21 * s2;
  out[6] = a12 * c2 + a22 * s2;
  out[7] = a13 * c2 + a23 * s2;
  out[8] = a20 * c2 - a10 * s2;
  out[9] = a21 * c2 - a11 * s2;
  out[10] = a22 * c2 - a12 * s2;
  out[11] = a23 * c2 - a13 * s2;
  return out;
}
function rotateY2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 - a20 * s2;
  out[1] = a01 * c2 - a21 * s2;
  out[2] = a02 * c2 - a22 * s2;
  out[3] = a03 * c2 - a23 * s2;
  out[8] = a00 * s2 + a20 * c2;
  out[9] = a01 * s2 + a21 * c2;
  out[10] = a02 * s2 + a22 * c2;
  out[11] = a03 * s2 + a23 * c2;
  return out;
}
function rotateZ2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 + a10 * s2;
  out[1] = a01 * c2 + a11 * s2;
  out[2] = a02 * c2 + a12 * s2;
  out[3] = a03 * c2 + a13 * s2;
  out[4] = a10 * c2 - a00 * s2;
  out[5] = a11 * c2 - a01 * s2;
  out[6] = a12 * c2 - a02 * s2;
  out[7] = a13 * c2 - a03 * s2;
  return out;
}
function fromTranslation2(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  let x2 = axis[0];
  let y2 = axis[1];
  let z2 = axis[2];
  let len5 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  let c2;
  let s2;
  let t2;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x2 *= len5;
  y2 *= len5;
  z2 *= len5;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t2 = 1 - c2;
  out[0] = x2 * x2 * t2 + c2;
  out[1] = y2 * x2 * t2 + z2 * s2;
  out[2] = z2 * x2 * t2 - y2 * s2;
  out[3] = 0;
  out[4] = x2 * y2 * t2 - z2 * s2;
  out[5] = y2 * y2 * t2 + c2;
  out[6] = z2 * y2 * t2 + x2 * s2;
  out[7] = 0;
  out[8] = x2 * z2 * t2 + y2 * s2;
  out[9] = y2 * z2 * t2 - x2 * s2;
  out[10] = z2 * z2 * t2 + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c2;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q2, v2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a2) {
  const translation = new ARRAY_TYPE(3);
  const bx = -a2[0];
  const by = -a2[1];
  const bz = -a2[2];
  const bw = a2[3];
  const ax = a2[4];
  const ay = a2[5];
  const az = a2[6];
  const aw = a2[7];
  const magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a2, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  const m11 = mat[0];
  const m12 = mat[1];
  const m13 = mat[2];
  const m21 = mat[4];
  const m22 = mat[5];
  const m23 = mat[6];
  const m31 = mat[8];
  const m32 = mat[9];
  const m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  const scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  const is1 = 1 / scaling[0];
  const is2 = 1 / scaling[1];
  const is3 = 1 / scaling[2];
  const sm11 = mat[0] * is1;
  const sm12 = mat[1] * is2;
  const sm13 = mat[2] * is3;
  const sm21 = mat[4] * is1;
  const sm22 = mat[5] * is2;
  const sm23 = mat[6] * is3;
  const sm31 = mat[8] * is1;
  const sm32 = mat[9] * is2;
  const sm33 = mat[10] * is3;
  const trace = sm11 + sm22 + sm33;
  let S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  const m11 = mat[0];
  const m12 = mat[1];
  const m13 = mat[2];
  const m21 = mat[4];
  const m22 = mat[5];
  const m23 = mat[6];
  const m31 = mat[8];
  const m32 = mat[9];
  const m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  const is1 = 1 / out_s[0];
  const is2 = 1 / out_s[1];
  const is3 = 1 / out_s[2];
  const sm11 = m11 * is1;
  const sm12 = m12 * is2;
  const sm13 = m13 * is3;
  const sm21 = m21 * is1;
  const sm22 = m22 * is2;
  const sm23 = m23 * is3;
  const sm31 = m31 * is1;
  const sm32 = m32 * is2;
  const sm33 = m33 * is3;
  const trace = sm11 + sm22 + sm33;
  let S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S2;
    out_r[0] = (sm23 - sm32) / S2;
    out_r[1] = (sm31 - sm13) / S2;
    out_r[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S2;
    out_r[0] = 0.25 * S2;
    out_r[1] = (sm12 + sm21) / S2;
    out_r[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S2;
    out_r[0] = (sm12 + sm21) / S2;
    out_r[1] = 0.25 * S2;
    out_r[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S2;
    out_r[0] = (sm31 + sm13) / S2;
    out_r[1] = (sm23 + sm32) / S2;
    out_r[2] = 0.25 * S2;
  }
  return out_r;
}
function fromRotationTranslationScale(out, q2, v2, s2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  const sx = s2[0];
  const sy = s2[1];
  const sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q2, v2, s2, o2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  const sx = s2[0];
  const sy = s2[1];
  const sz = s2[2];
  const ox = o2[0];
  const oy = o2[1];
  const oz = o2[2];
  const out0 = (1 - (yy + zz)) * sx;
  const out1 = (xy + wz) * sx;
  const out2 = (xz - wy) * sx;
  const out4 = (xy - wz) * sy;
  const out5 = (1 - (xx + zz)) * sy;
  const out6 = (yz + wx) * sy;
  const out8 = (xz + wy) * sz;
  const out9 = (yz - wx) * sz;
  const out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w2 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const yx = y2 * x22;
  const yy = y2 * y22;
  const zx = z2 * x22;
  const zy = z2 * y22;
  const zz = z2 * z22;
  const wx = w2 * x22;
  const wy = w2 * y22;
  const wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  const rl = 1 / (right - left);
  const tb = 1 / (top - bottom);
  const nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  const f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    const nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  const f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    const nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  const xScale = 2 / (leftTan + rightTan);
  const yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  let len5;
  let x0;
  let x1;
  let x2;
  let y0;
  let y1;
  let y2;
  let z0;
  let z1;
  let z2;
  const eyex = eye[0];
  const eyey = eye[1];
  const eyez = eye[2];
  const upx = up[0];
  const upy = up[1];
  const upz = up[2];
  const centerx = center[0];
  const centery = center[1];
  const centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len5 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len5 = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y2 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  const eyex = eye[0];
  const eyey = eye[1];
  const eyez = eye[2];
  const upx = up[0];
  const upy = up[1];
  const upz = up[2];
  let z0 = eyex - target[0];
  let z1 = eyey - target[1];
  let z2 = eyez - target[2];
  let len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  let x0 = upy * z2 - upz * z1;
  let x1 = upz * z0 - upx * z2;
  let x2 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str4(a2) {
  return `mat4(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]}, ${a2[4]}, ${a2[5]}, ${a2[6]}, ${a2[7]}, ${a2[8]}, ${a2[9]}, ${a2[10]}, ${a2[11]}, ${a2[12]}, ${a2[13]}, ${a2[14]}, ${a2[15]})`;
}
function frob2(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8] + a2[9] * a2[9] + a2[10] * a2[10] + a2[11] * a2[11] + a2[12] * a2[12] + a2[13] * a2[13] + a2[14] * a2[14] + a2[15] * a2[15]);
}
function add4(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  out[4] = a2[4] + b2[4];
  out[5] = a2[5] + b2[5];
  out[6] = a2[6] + b2[6];
  out[7] = a2[7] + b2[7];
  out[8] = a2[8] + b2[8];
  out[9] = a2[9] + b2[9];
  out[10] = a2[10] + b2[10];
  out[11] = a2[11] + b2[11];
  out[12] = a2[12] + b2[12];
  out[13] = a2[13] + b2[13];
  out[14] = a2[14] + b2[14];
  out[15] = a2[15] + b2[15];
  return out;
}
function subtract4(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  out[4] = a2[4] - b2[4];
  out[5] = a2[5] - b2[5];
  out[6] = a2[6] - b2[6];
  out[7] = a2[7] - b2[7];
  out[8] = a2[8] - b2[8];
  out[9] = a2[9] - b2[9];
  out[10] = a2[10] - b2[10];
  out[11] = a2[11] - b2[11];
  out[12] = a2[12] - b2[12];
  out[13] = a2[13] - b2[13];
  out[14] = a2[14] - b2[14];
  out[15] = a2[15] - b2[15];
  return out;
}
function multiplyScalar2(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  out[4] = a2[4] * b2;
  out[5] = a2[5] * b2;
  out[6] = a2[6] * b2;
  out[7] = a2[7] * b2;
  out[8] = a2[8] * b2;
  out[9] = a2[9] * b2;
  out[10] = a2[10] * b2;
  out[11] = a2[11] * b2;
  out[12] = a2[12] * b2;
  out[13] = a2[13] * b2;
  out[14] = a2[14] * b2;
  out[15] = a2[15] * b2;
  return out;
}
function multiplyScalarAndAdd2(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  out[4] = a2[4] + b2[4] * scale7;
  out[5] = a2[5] + b2[5] * scale7;
  out[6] = a2[6] + b2[6] * scale7;
  out[7] = a2[7] + b2[7] * scale7;
  out[8] = a2[8] + b2[8] * scale7;
  out[9] = a2[9] + b2[9] * scale7;
  out[10] = a2[10] + b2[10] * scale7;
  out[11] = a2[11] + b2[11] * scale7;
  out[12] = a2[12] + b2[12] * scale7;
  out[13] = a2[13] + b2[13] * scale7;
  out[14] = a2[14] + b2[14] * scale7;
  out[15] = a2[15] + b2[15] * scale7;
  return out;
}
function exactEquals4(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3] && a2[4] === b2[4] && a2[5] === b2[5] && a2[6] === b2[6] && a2[7] === b2[7] && a2[8] === b2[8] && a2[9] === b2[9] && a2[10] === b2[10] && a2[11] === b2[11] && a2[12] === b2[12] && a2[13] === b2[13] && a2[14] === b2[14] && a2[15] === b2[15];
}
function equals5(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const a4 = a2[4];
  const a5 = a2[5];
  const a6 = a2[6];
  const a7 = a2[7];
  const a8 = a2[8];
  const a9 = a2[9];
  const a10 = a2[10];
  const a11 = a2[11];
  const a12 = a2[12];
  const a13 = a2[13];
  const a14 = a2[14];
  const a15 = a2[15];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  const b4 = b2[4];
  const b5 = b2[5];
  const b6 = b2[6];
  const b7 = b2[7];
  const b8 = b2[8];
  const b9 = b2[9];
  const b10 = b2[10];
  const b11 = b2[11];
  const b12 = b2[12];
  const b13 = b2[13];
  const b14 = b2[14];
  const b15 = b2[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul4 = multiply4;
var sub4 = subtract4;

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add5,
  ceil: () => ceil3,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create5,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot3,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues5,
  inverse: () => inverse3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul5,
  multiply: () => multiply5,
  negate: () => negate3,
  normalize: () => normalize3,
  random: () => random3,
  round: () => round4,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set5,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength3,
  str: () => str5,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat4: () => transformMat43,
  transformQuat: () => transformQuat2,
  zero: () => zero3
});
function create5() {
  const out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone5(a2) {
  const out = new ARRAY_TYPE(4);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function fromValues5(x2, y2, z2, w2) {
  const out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function copy5(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function set5(out, x2, y2, z2, w2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function add5(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  return out;
}
function subtract5(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  return out;
}
function multiply5(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  out[3] = a2[3] * b2[3];
  return out;
}
function divide3(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  out[2] = a2[2] / b2[2];
  out[3] = a2[3] / b2[3];
  return out;
}
function ceil3(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  out[3] = Math.ceil(a2[3]);
  return out;
}
function floor3(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  out[3] = Math.floor(a2[3]);
  return out;
}
function min3(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  out[3] = Math.min(a2[3], b2[3]);
  return out;
}
function max3(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  out[3] = Math.max(a2[3], b2[3]);
  return out;
}
function round4(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  out[2] = round(a2[2]);
  out[3] = round(a2[3]);
  return out;
}
function scale5(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  return out;
}
function scaleAndAdd3(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  return out;
}
function distance3(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  const w2 = b2[3] - a2[3];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
}
function squaredDistance3(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  const w2 = b2[3] - a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
}
function length3(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
}
function squaredLength3(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
}
function negate3(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = -a2[3];
  return out;
}
function inverse3(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  out[3] = 1 / a2[3];
  return out;
}
function normalize3(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  let len5 = x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x2 * len5;
  out[1] = y2 * len5;
  out[2] = z2 * len5;
  out[3] = w2 * len5;
  return out;
}
function dot3(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2] + a2[3] * b2[3];
}
function cross3(out, u2, v2, w2) {
  const A2 = v2[0] * w2[1] - v2[1] * w2[0];
  const B2 = v2[0] * w2[2] - v2[2] * w2[0];
  const C2 = v2[0] * w2[3] - v2[3] * w2[0];
  const D = v2[1] * w2[2] - v2[2] * w2[1];
  const E2 = v2[1] * w2[3] - v2[3] * w2[1];
  const F2 = v2[2] * w2[3] - v2[3] * w2[2];
  const G2 = u2[0];
  const H2 = u2[1];
  const I2 = u2[2];
  const J2 = u2[3];
  out[0] = H2 * F2 - I2 * E2 + J2 * D;
  out[1] = -(G2 * F2) + I2 * C2 - J2 * B2;
  out[2] = G2 * E2 - H2 * C2 + J2 * A2;
  out[3] = -(G2 * D) + H2 * B2 - I2 * A2;
  return out;
}
function lerp4(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  out[2] = az + t2 * (b2[2] - az);
  out[3] = aw + t2 * (b2[3] - aw);
  return out;
}
function random3(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  let v1;
  let v2;
  let v3;
  let v4;
  let s1;
  let s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  const d2 = Math.sqrt((1 - s1) / s2);
  out[0] = scale7 * v1;
  out[1] = scale7 * v2;
  out[2] = scale7 * v3 * d2;
  out[3] = scale7 * v4 * d2;
  return out;
}
function transformMat43(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12] * w2;
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13] * w2;
  out[2] = m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14] * w2;
  out[3] = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15] * w2;
  return out;
}
function transformQuat2(out, a2, q2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const qx = q2[0];
  const qy = q2[1];
  const qz = q2[2];
  const qw = q2[3];
  const ix = qw * x2 + qy * z2 - qz * y2;
  const iy = qw * y2 + qz * x2 - qx * z2;
  const iz = qw * z2 + qx * y2 - qy * x2;
  const iw = -qx * x2 - qy * y2 - qz * z2;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a2[3];
  return out;
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str5(a2) {
  return `vec4(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]})`;
}
function exactEquals5(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3];
}
function equals6(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub5 = subtract5;
var mul5 = multiply5;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var len3 = length3;
var sqrLen3 = squaredLength3;
var forEach3 = function() {
  const vec = create5();
  return function(a2, stride, offset, count, fn, arg) {
    let i2;
    let l2;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      vec[3] = a2[i2 + 3];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
      a2[i2 + 3] = vec[3];
    }
    return a2;
  };
}();

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/classes/matrix4.js
var INDICES2;
(function(INDICES3) {
  INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES2 || (INDICES2 = {}));
var DEFAULT_FOVY = 45 * Math.PI / 180;
var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/gl-matrix/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add6,
  calculateW: () => calculateW,
  clone: () => clone6,
  conjugate: () => conjugate,
  copy: () => copy6,
  create: () => create6,
  dot: () => dot4,
  equals: () => equals7,
  exactEquals: () => exactEquals6,
  exp: () => exp,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues6,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp5,
  ln: () => ln,
  mul: () => mul6,
  multiply: () => multiply6,
  normalize: () => normalize4,
  pow: () => pow,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale6,
  set: () => set6,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp2,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen4,
  squaredLength: () => squaredLength4,
  str: () => str6
});
function create6() {
  const out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  const s2 = Math.sin(rad);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q2) {
  const rad = Math.acos(q2[3]) * 2;
  const s2 = Math.sin(rad / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q2[0] / s2;
    out_axis[1] = q2[1] / s2;
    out_axis[2] = q2[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a2, b2) {
  const dotproduct = dot4(a2, b2);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply6(out, a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  const bw = b2[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bx = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const by = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bz = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y2 * y2 - z2 * z2));
  return out;
}
function exp(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  const r2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  const et2 = Math.exp(w2);
  const s2 = r2 > 0 ? et2 * Math.sin(r2) / r2 : 0;
  out[0] = x2 * s2;
  out[1] = y2 * s2;
  out[2] = z2 * s2;
  out[3] = et2 * Math.cos(r2);
  return out;
}
function ln(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w2 = a2[3];
  const r2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  const t2 = r2 > 0 ? Math.atan2(r2, w2) / r2 : 0;
  out[0] = x2 * t2;
  out[1] = y2 * t2;
  out[2] = z2 * t2;
  out[3] = 0.5 * Math.log(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
  return out;
}
function pow(out, a2, b2) {
  ln(out, a2);
  scale6(out, out, b2);
  exp(out, out);
  return out;
}
function slerp2(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  let bx = b2[0];
  let by = b2[1];
  let bz = b2[2];
  let bw = b2[3];
  let cosom;
  let omega;
  let scale0;
  let scale1;
  let sinom;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t2) * omega) / sinom;
    scale1 = Math.sin(t2 * omega) / sinom;
  } else {
    scale0 = 1 - t2;
    scale1 = t2;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert3(out, a2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const dot5 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  const invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a2[3];
  return out;
}
function fromMat3(out, m2) {
  const fTrace = m2[0] + m2[4] + m2[8];
  let fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m2[5] - m2[7]) * fRoot;
    out[1] = (m2[6] - m2[2]) * fRoot;
    out[2] = (m2[1] - m2[3]) * fRoot;
  } else {
    let i2 = 0;
    if (m2[4] > m2[0])
      i2 = 1;
    if (m2[8] > m2[i2 * 3 + i2])
      i2 = 2;
    const j2 = (i2 + 1) % 3;
    const k2 = (i2 + 2) % 3;
    fRoot = Math.sqrt(m2[i2 * 3 + i2] - m2[j2 * 3 + j2] - m2[k2 * 3 + k2] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m2[j2 * 3 + k2] - m2[k2 * 3 + j2]) * fRoot;
    out[j2] = (m2[j2 * 3 + i2] + m2[i2 * 3 + j2]) * fRoot;
    out[k2] = (m2[k2 * 3 + i2] + m2[i2 * 3 + k2]) * fRoot;
  }
  return out;
}
function str6(a2) {
  return `quat(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]})`;
}
var clone6 = clone5;
var fromValues6 = fromValues5;
var copy6 = copy5;
var set6 = set5;
var add6 = add5;
var mul6 = multiply6;
var scale6 = scale5;
var dot4 = dot3;
var lerp5 = lerp4;
var length4 = length3;
var len4 = length4;
var squaredLength4 = squaredLength3;
var sqrLen4 = squaredLength4;
var normalize4 = normalize3;
var exactEquals6 = exactEquals5;
function equals7(a2, b2) {
  return Math.abs(dot3(a2, b2)) >= 1 - EPSILON;
}
var rotationTo = function() {
  const tmpvec3 = create2();
  const xUnitVec3 = fromValues2(1, 0, 0);
  const yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a2, b2) {
    const dot5 = dot2(a2, b2);
    if (dot5 < -0.999999) {
      cross2(tmpvec3, xUnitVec3, a2);
      if (len2(tmpvec3) < 1e-6)
        cross2(tmpvec3, yUnitVec3, a2);
      normalize2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    }
    cross2(tmpvec3, a2, b2);
    out[0] = tmpvec3[0];
    out[1] = tmpvec3[1];
    out[2] = tmpvec3[2];
    out[3] = 1 + dot5;
    return normalize4(out, out);
  };
}();
var sqlerp = function() {
  const temp1 = create6();
  const temp2 = create6();
  return function(out, a2, b2, c2, d2, t2) {
    slerp2(temp1, a2, d2, t2);
    slerp2(temp2, b2, c2, t2);
    slerp2(out, temp1, temp2, 2 * t2 * (1 - t2));
    return out;
  };
}();
var setAxes = function() {
  const matr = create3();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize4(out, fromMat3(out, matr));
  };
}();

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/classes/euler.js
var RotationOrder;
(function(RotationOrder2) {
  RotationOrder2[RotationOrder2["ZYX"] = 0] = "ZYX";
  RotationOrder2[RotationOrder2["YXZ"] = 1] = "YXZ";
  RotationOrder2[RotationOrder2["XZY"] = 2] = "XZY";
  RotationOrder2[RotationOrder2["ZXY"] = 3] = "ZXY";
  RotationOrder2[RotationOrder2["YZX"] = 4] = "YZX";
  RotationOrder2[RotationOrder2["XYZ"] = 5] = "XYZ";
})(RotationOrder || (RotationOrder = {}));

// node_modules/@deck.gl/layers/node_modules/@math.gl/core/dist/lib/math-utils.js
var math_utils_exports = {};
__export(math_utils_exports, {
  EPSILON1: () => EPSILON1,
  EPSILON10: () => EPSILON10,
  EPSILON11: () => EPSILON11,
  EPSILON12: () => EPSILON12,
  EPSILON13: () => EPSILON13,
  EPSILON14: () => EPSILON14,
  EPSILON15: () => EPSILON15,
  EPSILON16: () => EPSILON16,
  EPSILON17: () => EPSILON17,
  EPSILON18: () => EPSILON18,
  EPSILON19: () => EPSILON19,
  EPSILON2: () => EPSILON2,
  EPSILON20: () => EPSILON20,
  EPSILON3: () => EPSILON3,
  EPSILON4: () => EPSILON4,
  EPSILON5: () => EPSILON5,
  EPSILON6: () => EPSILON6,
  EPSILON7: () => EPSILON7,
  EPSILON8: () => EPSILON8,
  EPSILON9: () => EPSILON9,
  PI_OVER_FOUR: () => PI_OVER_FOUR,
  PI_OVER_SIX: () => PI_OVER_SIX,
  PI_OVER_TWO: () => PI_OVER_TWO,
  TWO_PI: () => TWO_PI
});
var EPSILON1 = 0.1;
var EPSILON2 = 0.01;
var EPSILON3 = 1e-3;
var EPSILON4 = 1e-4;
var EPSILON5 = 1e-5;
var EPSILON6 = 1e-6;
var EPSILON7 = 1e-7;
var EPSILON8 = 1e-8;
var EPSILON9 = 1e-9;
var EPSILON10 = 1e-10;
var EPSILON11 = 1e-11;
var EPSILON12 = 1e-12;
var EPSILON13 = 1e-13;
var EPSILON14 = 1e-14;
var EPSILON15 = 1e-15;
var EPSILON16 = 1e-16;
var EPSILON17 = 1e-17;
var EPSILON18 = 1e-18;
var EPSILON19 = 1e-19;
var EPSILON20 = 1e-20;
var PI_OVER_TWO = Math.PI / 2;
var PI_OVER_FOUR = Math.PI / 4;
var PI_OVER_SIX = Math.PI / 6;
var TWO_PI = Math.PI * 2;

// node_modules/@deck.gl/layers/node_modules/@math.gl/web-mercator/dist/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "@math.gl/web-mercator: assertion failed.");
  }
}

// node_modules/@deck.gl/layers/node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS2 = PI / 180;
var RADIANS_TO_DEGREES2 = 180 / PI;
var TILE_SIZE = 512;
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert2(Number.isFinite(lng));
  assert2(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  const lambda2 = lng * DEGREES_TO_RADIANS2;
  const phi2 = lat * DEGREES_TO_RADIANS2;
  const x2 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y2 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x2, y2];
}

// node_modules/@deck.gl/layers/node_modules/@math.gl/web-mercator/dist/get-bounds.js
var DEGREES_TO_RADIANS3 = Math.PI / 180;

// node_modules/@deck.gl/layers/dist/bitmap-layer/create-mesh.js
var DEFAULT_INDICES = new Uint32Array([0, 2, 1, 0, 3, 2]);
var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex = 0;
  let index = 0;
  for (let u2 = 0; u2 < uCount; u2++) {
    const ut2 = u2 / (uCount - 1);
    for (let v2 = 0; v2 < vCount; v2++) {
      const vt = v2 / (vCount - 1);
      const p2 = interpolateQuad(bounds, ut2, vt);
      positions[vertex * 3 + 0] = p2[0];
      positions[vertex * 3 + 1] = p2[1];
      positions[vertex * 3 + 2] = p2[2] || 0;
      texCoords[vertex * 2 + 0] = ut2;
      texCoords[vertex * 2 + 1] = 1 - vt;
      if (u2 > 0 && v2 > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }
      vertex++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i2 = 0; i2 < bounds.length; i2++) {
    positions[i2 * 3 + 0] = bounds[i2][0];
    positions[i2 * 3 + 1] = bounds[i2][1];
    positions[i2 * 3 + 2] = bounds[i2][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut2, vt) {
  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut2);
}

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-uniforms.js
var uniformBlock2 = `uniform bitmapUniforms {
  vec4 bounds;
  float coordinateConversion;
  float desaturate;
  vec3 tintColor;
  vec4 transparentColor;
} bitmap;
`;
var bitmapUniforms = {
  name: "bitmap",
  vs: uniformBlock2,
  fs: uniformBlock2,
  uniformTypes: {
    bounds: "vec4<f32>",
    coordinateConversion: "f32",
    desaturate: "f32",
    tintColor: "vec3<f32>",
    transparentColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (bitmap.coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project.commonOrigin.xy;
  } else if (bitmap.coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-fragment.js
var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
var bitmap_layer_fragment_default = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), bitmap.desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * bitmap.tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (bitmap.transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),
    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (bitmap.coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (bitmap.coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer.js
var defaultProps2 = {
  image: { type: "image", value: null, async: true },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  desaturate: { type: "number", min: 0, max: 1, value: 0 },
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: { type: "color", value: [0, 0, 0, 0] },
  tintColor: { type: "color", value: [255, 255, 255] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var BitmapLayer = class extends Layer {
  getShaders() {
    return super.getShaders({ vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default, bitmapUniforms] });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(["instancePickingColors"]);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: (attribute) => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        update: (attribute) => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: (attribute) => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }
  updateState({ props, oldProps, changeFlags }) {
    var _a;
    const attributeManager = this.getAttributeManager();
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;
      const mesh = this._createMesh();
      this.state.model.setVertexCount(mesh.vertexCount);
      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }
      this.setState({ mesh, ...this._getCoordinateUniforms() });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }
  getPickingInfo(params) {
    const { image } = this.props;
    const info = params.info;
    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }
    const { width, height } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    info.bitmap = {
      size: { width, height },
      uv,
      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
    };
    return info;
  }
  // Override base Layer multi-depth picking logic
  disablePickingIndex() {
    this.setState({ disablePicking: true });
  }
  restorePickingColors() {
    this.setState({ disablePicking: false });
  }
  _updateAutoHighlight(info) {
    super._updateAutoHighlight({
      ...info,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const { bounds } = this.props;
    let normalizedBounds = bounds;
    if (isRectangularBounds(bounds)) {
      normalizedBounds = [
        [bounds[0], bounds[1]],
        [bounds[0], bounds[3]],
        [bounds[2], bounds[3]],
        [bounds[2], bounds[1]]
      ];
    }
    return createMesh(normalizedBounds, this.context.viewport.resolution);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-list",
      isInstanced: false
    });
  }
  draw(opts) {
    const { shaderModuleProps } = opts;
    const { model, coordinateConversion, bounds, disablePicking } = this.state;
    const { image, desaturate, transparentColor, tintColor } = this.props;
    if (shaderModuleProps.picking.isActive && disablePicking) {
      return;
    }
    if (image && model) {
      const bitmapProps = {
        bitmapTexture: image,
        bounds,
        coordinateConversion,
        desaturate,
        tintColor: tintColor.slice(0, 3).map((x2) => x2 / 255),
        transparentColor: transparentColor.map((x2) => x2 / 255)
      };
      model.shaderInputs.setProps({ bitmap: bitmapProps });
      model.draw(this.context.renderPass);
    }
  }
  _getCoordinateUniforms() {
    const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
    let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
    if (imageCoordinateSystem !== DEFAULT) {
      const { bounds } = this.props;
      if (!isRectangularBounds(bounds)) {
        throw new Error("_imageCoordinateSystem only supports rectangular bounds");
      }
      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return { coordinateConversion: -1, bounds };
      }
      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
        const topRight = lngLatToWorld([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
};
BitmapLayer.layerName = "BitmapLayer";
BitmapLayer.defaultProps = defaultProps2;
var bitmap_layer_default = BitmapLayer;
function unpackUVsFromRGB(color) {
  const [u2, v2, fracUV] = color;
  const vFrac = (fracUV & 240) / 256;
  const uFrac = (fracUV & 15) / 16;
  return [(u2 + uFrac) / 256, (v2 + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-uniforms.js
var uniformBlock3 = `uniform iconUniforms {
  float sizeScale;
  vec2 iconsTextureDim;
  float sizeMinPixels;
  float sizeMaxPixels;
  bool billboard;
  highp int sizeUnits;
  float alphaCutoff;
} icon;
`;
var iconUniforms = {
  name: "icon",
  vs: uniformBlock3,
  fs: uniformBlock3,
  uniformTypes: {
    sizeScale: "f32",
    iconsTextureDim: "vec2<f32>",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    billboard: "f32",
    sizeUnits: "i32",
    alphaCutoff: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),
icon.sizeMinPixels, icon.sizeMaxPixels
);
float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (icon.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / icon.iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * layer.opacity * vColor.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-manager.js
var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;
var noop = () => {
};
var DEFAULT_SAMPLER_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  // LINEAR is the default value but explicitly set it here
  magFilter: "linear",
  // minimize texture boundary artifacts
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
var MISSING_ICON = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return { image: imageData, width, height };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return { image: ctx.canvas, width, height };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, sampler) {
  const { width: oldWidth, height: oldHeight, device } = texture;
  const newTexture = device.createTexture({
    format: "rgba8unorm",
    width,
    height,
    sampler,
    mipmaps: true
  });
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyTextureToTexture({
    sourceTexture: texture,
    destinationTexture: newTexture,
    width: oldWidth,
    height: oldHeight
  });
  commandEncoder.finish();
  texture.destroy();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i2 = 0; i2 < columns.length; i2++) {
    const { icon, xOffset } = columns[i2];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({ icons, buffer: buffer2, mapping = {}, xOffset = 0, yOffset = 0, rowHeight = 0, canvasWidth }) {
  let columns = [];
  for (let i2 = 0; i2 < icons.length; i2++) {
    const icon = icons[i2];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const { height, width } = icon;
      if (xOffset + width + buffer2 > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer2;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer2;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer2)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const { iterable, objectInfo } = createIterable(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index };
    }
  }
  return icons;
}
var IconManager = class {
  constructor(device, { onUpdate = noop, onError = noop }) {
    this._loadOptions = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._samplerParameters = null;
    this._pendingCount = 0;
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._rowHeight = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
    this.device = device;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    var _a;
    (_a = this._texture) == null ? void 0 : _a.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || MISSING_ICON;
  }
  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, textureParameters }) {
    var _a;
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== void 0) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      (_a = this._texture) == null ? void 0 : _a.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._samplerParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    if (!this._autoPacking || typeof document === "undefined") {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = this.device.createTexture({
          format: "rgba8unorm",
          width: this._canvasWidth,
          height: this._canvasHeight,
          sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,
          mipmaps: true
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement("canvas");
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      load(icon.url, this._loadOptions).then((imageData) => {
        var _a;
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const { x: x2, y: y2, width: maxWidth, height: maxHeight } = iconDef;
        const { image, width, height } = resizeImage(ctx, imageData, maxWidth, maxHeight);
        (_a = this._texture) == null ? void 0 : _a.copyExternalImage({
          image,
          x: x2 + (maxWidth - width) / 2,
          y: y2 + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch((error) => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer.js
var DEFAULT_COLOR2 = [0, 0, 0, 255];
var defaultProps3 = {
  iconAtlas: { type: "image", value: null, async: true },
  iconMapping: { type: "object", value: {}, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  billboard: true,
  sizeUnits: "pixels",
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getIcon: { type: "accessor", value: (x2) => x2.icon },
  getColor: { type: "accessor", value: DEFAULT_COLOR2 },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  onIconError: { type: "function", value: null, optional: true },
  textureParameters: { type: "object", ignore: true, value: null }
};
var IconLayer = class extends Layer {
  getShaders() {
    return super.getShaders({ vs: icon_layer_vertex_glsl_default, fs: icon_layer_fragment_glsl_default, modules: [project32_default, picking_default, iconUniforms] });
  }
  initializeState() {
    this.state = {
      iconManager: new IconManager(this.context.device, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: "uint8",
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR2
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      }
    });
  }
  /* eslint-disable max-statements, complexity */
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
    const { iconManager } = this.state;
    if (typeof iconAtlas === "string") {
      return;
    }
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate("getIcon");
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  /* eslint-enable max-statements, complexity */
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({ uniforms }) {
    const { sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
    const { iconManager } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      const model = this.state.model;
      const iconProps = {
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      };
      model.shaderInputs.setProps({ icon: iconProps });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          // The size must be explicitly passed here otherwise luma.gl
          // will default to assuming that positions are 3D (x,y,z)
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    var _a;
    const onIconError = (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      log_default.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const { width, height, anchorX = width / 2, anchorY = height / 2 } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const { x: x2, y: y2, width, height } = this.state.iconManager.getIconMapping(icon);
    return [x2, y2, width, height];
  }
};
IconLayer.defaultProps = defaultProps3;
IconLayer.layerName = "IconLayer";
var icon_layer_default = IconLayer;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-uniforms.js
var uniformBlockWGSL = (
  /* wgsl */
  `struct LineUniforms {
  widthScale: f32,
  widthMinPixels: f32,
  widthMaxPixels: f32,
  useShortestPath: f32,
  widthUnits: i32,
};

@group(0) @binding(1)
var<uniform> line: LineUniforms;
`
);
var uniformBlockGLSL = (
  /* glsl */
  `uniform lineUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float useShortestPath;
  highp int widthUnits;
} line;
`
);
var lineUniforms = {
  name: "line",
  source: uniformBlockWGSL,
  vs: uniformBlockGLSL,
  fs: uniformBlockGLSL,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    useShortestPath: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.wgsl.js
var shaderWGSL = (
  /* wgsl */
  `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)
struct LayerUniforms {
  opacity: f32,
};
var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// ---------- Helper Structures & Functions ----------

// Placeholder filter functions.
fn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {
  return offset;
}
fn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return p;
}
fn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return color;
}

// Compute an extrusion offset given a line direction (in clipspace),
// an offset direction (-1 or 1), and a width in pixels.
// Assumes a uniform "project" with a viewportSize field is available.
fn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {
  // project.viewportSize should be provided as a uniform (not shown here)
  let dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // Rotate by 90°: (x,y) becomes (-y,x)
  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);
  return rotated * offset_direction * width / 2.0;
}

// Splits the line between two points at a given x coordinate.
// Interpolates the y and z components.
fn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {
  let t: f32 = (x - a.x) / (b.x - a.x);
  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));
}

// ---------- Uniforms & Global Structures ----------

// Uniforms for line, layer, and project are assumed to be defined elsewhere.
// For example:
//
// @group(0) @binding(0)
// var<uniform> line: LineUniform;
//
// struct LayerUniform {
//   opacity: f32,
// };
// @group(0) @binding(1)
// var<uniform> layer: LayerUniform;
//
// struct ProjectUniform {
//   viewportSize: vec2<f32>,
// };
// @group(0) @binding(2)
// var<uniform> project: ProjectUniform;



// ---------- Vertex Output Structure ----------

struct Varyings {
  @builtin(position) gl_Position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>,
};

// ---------- Vertex Shader Entry Point ----------

@vertex
fn vertexMain(
  @location(0) positions: vec3<f32>,
  @location(1) instanceSourcePositions: vec3<f32>,
  @location(2) instanceTargetPositions: vec3<f32>,
  @location(3) instanceSourcePositions64Low: vec3<f32>,
  @location(4) instanceTargetPositions64Low: vec3<f32>,
  @location(5) instanceColors: vec4<f32>,
  @location(6) instancePickingColors: vec3<f32>,
  @location(7) instanceWidths: f32
) -> Varyings {
  var geometry: Geometry;
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  var source_world: vec3<f32> = instanceSourcePositions;
  var target_world: vec3<f32> = instanceTargetPositions;
  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;
  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;

  // Apply shortest-path adjustments if needed.
  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;
    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;
    let deltaLng: f32 = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.0) {
      source_world.x = source_world.x + 360.0 * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (deltaLng * line.useShortestPath < -180.0) {
      target_world.x = target_world.x + 360.0 * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (line.useShortestPath < 0.0) {
      var abortOut: Varyings;
      abortOut.gl_Position = vec4<f32>(0.0);
      abortOut.vColor = vec4<f32>(0.0);
      abortOut.uv = vec2<f32>(0.0);
      return abortOut;
    }
  }

  // Project Pos and target positions to clip space.
  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));
  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));
  let sourcePos: vec4<f32> = sourceResult.clipPosition;
  let targetPos: vec4<f32> = targetResult.clipPosition;
  let source_commonspace: vec4<f32> = sourceResult.commonPosition;
  let target_commonspace: vec4<f32> = targetResult.commonPosition;

  // Interpolate along the line segment.
  let segmentIndex: f32 = positions.x;
  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);
  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);
  let uv: vec2<f32> = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Determine width in pixels.
  let widthPixels: f32 = clamp(
    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // Compute extrusion offset.
  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);
  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);

  // Apply deck.gl filter functions.
  let filteredOffset = deckgl_filter_size(offset, geometry);
  let filteredP = deckgl_filter_gl_position(p, geometry);

  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);
  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);

  // Compute color.
  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * layer.opacity);
  // vColor = deckgl_filter_color(vColor, geometry);

  var output: Varyings;
  output.gl_Position = finalPosition;
  output.vColor = vColor;
  output.uv = uv;
  return output;
}

@fragment
fn fragmentMain(
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>
) -> @location(0) vec4<f32> {
  // Create and initialize geometry with the provided uv.
  var geometry: Geometry;
  geometry.uv = uv;

  // Start with the input color.
  var fragColor: vec4<f32> = vColor;

  // Apply the deck.gl filter to the color.
  fragColor = deckgl_filter_color(fragColor, geometry);

  return fragColor;
}
`
);

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * line.useShortestPath > 180.) {
source_world.x += 360. * line.useShortestPath;
source_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * line.useShortestPath < -180.) {
target_world.x += 360. * line.useShortestPath;
target_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
target_world_64low = vec3(0.0);
} else if (line.useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
line.widthMinPixels, line.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.js
var DEFAULT_COLOR3 = [0, 0, 0, 255];
var defaultProps4 = {
  getSourcePosition: { type: "accessor", value: (x2) => x2.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x2) => x2.targetPosition },
  getColor: { type: "accessor", value: DEFAULT_COLOR3 },
  getWidth: { type: "accessor", value: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var LineLayer = class extends Layer {
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: line_layer_vertex_glsl_default, fs: line_layer_fragment_glsl_default, source: shaderWGSL, modules: [project32_default, picking_default, lineUniforms] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
    const model = this.state.model;
    const lineProps = {
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    };
    model.shaderInputs.setProps({ line: lineProps });
    model.draw(this.context.renderPass);
    if (wrapLongitude) {
      model.shaderInputs.setProps({ line: { ...lineProps, useShortestPath: -1 } });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
LineLayer.layerName = "LineLayer";
LineLayer.defaultProps = defaultProps4;
var line_layer_default = LineLayer;

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js
var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js
var ES300_REPLACEMENTS = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
];
var ES300_VERTEX_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `attribute` keyword replaced with `in`
  [makeVariableTextRegExp("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [makeVariableTextRegExp("varying"), "out $1"]
];
var ES300_FRAGMENT_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `varying` keyword replaced with `in`
  [makeVariableTextRegExp("varying"), "in $1"]
];
function makeVariableTextRegExp(qualifier) {
  return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js
var INJECT_SHADER_DECLARATIONS = `

${DECLARATION_INJECT_MARKER}
`;

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js
var FS_GLES = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
);
var FS300 = `#version 300 es
${FS_GLES}`;

// node_modules/wgsl_reflect/wgsl_reflect.module.js
var e = class {
  constructor(e2, t2) {
    this.name = e2, this.attributes = t2, this.size = 0;
  }
  get isArray() {
    return false;
  }
  get isStruct() {
    return false;
  }
  get isTemplate() {
    return false;
  }
  get isPointer() {
    return false;
  }
  getTypeName() {
    return this.name;
  }
};
var t = class {
  constructor(e2, t2, n2) {
    this.name = e2, this.type = t2, this.attributes = n2, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
};
var n = class extends e {
  constructor(e2, t2) {
    super(e2, t2), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = false;
  }
  get isStruct() {
    return true;
  }
};
var s = class extends e {
  constructor(e2, t2) {
    super(e2, t2), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return true;
  }
  getTypeName() {
    return `array<${this.format.getTypeName()}, ${this.count}>`;
  }
};
var r = class extends e {
  constructor(e2, t2, n2) {
    super(e2, n2), this.format = t2;
  }
  get isPointer() {
    return true;
  }
  getTypeName() {
    return `&${this.format.getTypeName()}`;
  }
};
var a = class extends e {
  constructor(e2, t2, n2, s2) {
    super(e2, n2), this.format = t2, this.access = s2;
  }
  get isTemplate() {
    return true;
  }
  getTypeName() {
    let e2 = this.name;
    if (null !== this.format) {
      if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2 || "mat2x2" === e2 || "mat2x3" === e2 || "mat2x4" === e2 || "mat3x2" === e2 || "mat3x3" === e2 || "mat3x4" === e2 || "mat4x2" === e2 || "mat4x3" === e2 || "mat4x4" === e2) {
        if ("f32" === this.format.name) return e2 += "f", e2;
        if ("i32" === this.format.name) return e2 += "i", e2;
        if ("u32" === this.format.name) return e2 += "u", e2;
        if ("bool" === this.format.name) return e2 += "b", e2;
        if ("f16" === this.format.name) return e2 += "h", e2;
      }
      e2 += `<${this.format.name}>`;
    } else if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2) return e2;
    return e2;
  }
};
var i;
((e2) => {
  e2[e2.Uniform = 0] = "Uniform", e2[e2.Storage = 1] = "Storage", e2[e2.Texture = 2] = "Texture", e2[e2.Sampler = 3] = "Sampler", e2[e2.StorageTexture = 4] = "StorageTexture";
})(i || (i = {}));
var o = class {
  constructor(e2, t2, n2, s2, r2, a2, i2) {
    this.name = e2, this.type = t2, this.group = n2, this.binding = s2, this.attributes = r2, this.resourceType = a2, this.access = i2;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
};
var l = class {
  constructor(e2, t2) {
    this.name = e2, this.type = t2;
  }
};
var c = class {
  constructor(e2, t2, n2, s2) {
    this.name = e2, this.type = t2, this.locationType = n2, this.location = s2, this.interpolation = null;
  }
};
var u = class {
  constructor(e2, t2, n2, s2) {
    this.name = e2, this.type = t2, this.locationType = n2, this.location = s2;
  }
};
var h = class {
  constructor(e2, t2, n2, s2) {
    this.name = e2, this.type = t2, this.attributes = n2, this.id = s2;
  }
};
var f = class {
  constructor(e2, t2, n2) {
    this.name = e2, this.type = t2, this.attributes = n2;
  }
};
var p = class {
  constructor(e2, t2 = null, n2) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = false, this.calls = /* @__PURE__ */ new Set(), this.name = e2, this.stage = t2, this.attributes = n2;
  }
};
var d = class {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
};
var m = new Float32Array(1);
var _ = new Int32Array(m.buffer);
var g = new Uint16Array(1);
function x(e2) {
  m[0] = e2;
  const t2 = _[0], n2 = t2 >> 31 & 1;
  let s2 = t2 >> 23 & 255, r2 = 8388607 & t2;
  if (255 === s2) return g[0] = n2 << 15 | 31744 | (0 !== r2 ? 512 : 0), g[0];
  if (0 === s2) {
    if (0 === r2) return g[0] = n2 << 15, g[0];
    r2 |= 8388608;
    let e3 = 113;
    for (; !(8388608 & r2); ) r2 <<= 1, e3--;
    return s2 = 127 - e3, r2 &= 8388607, s2 > 0 ? (r2 = (r2 >> 126 - s2) + (r2 >> 127 - s2 & 1), g[0] = n2 << 15 | s2 << 10 | r2 >> 13, g[0]) : (g[0] = n2 << 15, g[0]);
  }
  return s2 = s2 - 127 + 15, s2 >= 31 ? (g[0] = n2 << 15 | 31744, g[0]) : s2 <= 0 ? s2 < -10 ? (g[0] = n2 << 15, g[0]) : (r2 = (8388608 | r2) >> 1 - s2, g[0] = n2 << 15 | r2 >> 13, g[0]) : (r2 >>= 13, g[0] = n2 << 15 | s2 << 10 | r2, g[0]);
}
var y = new Uint32Array(1);
var b = new Float32Array(y.buffer, 0, 1);
function v(e2) {
  const t2 = 112 + (e2 >> 6 & 31) << 23 | (63 & e2) << 17;
  return y[0] = t2, b[0];
}
function w(e2, t2, n2, s2, r2, a2, i2, o2, l2) {
  const c2 = s2 * (i2 >>= r2) * (a2 >>= r2) + n2 * i2 + t2 * o2;
  switch (l2) {
    case "r8unorm":
      return [k(e2, c2, "8unorm", 1)[0]];
    case "r8snorm":
      return [k(e2, c2, "8snorm", 1)[0]];
    case "r8uint":
      return [k(e2, c2, "8uint", 1)[0]];
    case "r8sint":
      return [k(e2, c2, "8sint", 1)[0]];
    case "rg8unorm": {
      const t3 = k(e2, c2, "8unorm", 2);
      return [t3[0], t3[1]];
    }
    case "rg8snorm": {
      const t3 = k(e2, c2, "8snorm", 2);
      return [t3[0], t3[1]];
    }
    case "rg8uint": {
      const t3 = k(e2, c2, "8uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg8sint": {
      const t3 = k(e2, c2, "8sint", 2);
      return [t3[0], t3[1]];
    }
    case "rgba8unorm-srgb":
    case "rgba8unorm": {
      const t3 = k(e2, c2, "8unorm", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8snorm": {
      const t3 = k(e2, c2, "8snorm", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8uint": {
      const t3 = k(e2, c2, "8uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8sint": {
      const t3 = k(e2, c2, "8sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "bgra8unorm-srgb":
    case "bgra8unorm": {
      const t3 = k(e2, c2, "8unorm", 4);
      return [t3[2], t3[1], t3[0], t3[3]];
    }
    case "r16uint":
      return [k(e2, c2, "16uint", 1)[0]];
    case "r16sint":
      return [k(e2, c2, "16sint", 1)[0]];
    case "r16float":
      return [k(e2, c2, "16float", 1)[0]];
    case "rg16uint": {
      const t3 = k(e2, c2, "16uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg16sint": {
      const t3 = k(e2, c2, "16sint", 2);
      return [t3[0], t3[1]];
    }
    case "rg16float": {
      const t3 = k(e2, c2, "16float", 2);
      return [t3[0], t3[1]];
    }
    case "rgba16uint": {
      const t3 = k(e2, c2, "16uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba16sint": {
      const t3 = k(e2, c2, "16sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba16float": {
      const t3 = k(e2, c2, "16float", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "r32uint":
      return [k(e2, c2, "32uint", 1)[0]];
    case "r32sint":
      return [k(e2, c2, "32sint", 1)[0]];
    case "depth16unorm":
    case "depth24plus":
    case "depth24plus-stencil8":
    case "depth32float":
    case "depth32float-stencil8":
    case "r32float":
      return [k(e2, c2, "32float", 1)[0]];
    case "rg32uint": {
      const t3 = k(e2, c2, "32uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg32sint": {
      const t3 = k(e2, c2, "32sint", 2);
      return [t3[0], t3[1]];
    }
    case "rg32float": {
      const t3 = k(e2, c2, "32float", 2);
      return [t3[0], t3[1]];
    }
    case "rgba32uint": {
      const t3 = k(e2, c2, "32uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba32sint": {
      const t3 = k(e2, c2, "32sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba32float": {
      const t3 = k(e2, c2, "32float", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rg11b10ufloat": {
      const t3 = new Uint32Array(e2.buffer, c2, 1)[0], n3 = (4192256 & t3) >> 11, s3 = (4290772992 & t3) >> 22;
      return [v(2047 & t3), v(n3), function(e3) {
        const t4 = 112 + (e3 >> 5 & 31) << 23 | (31 & e3) << 18;
        return y[0] = t4, b[0];
      }(s3), 1];
    }
  }
  return null;
}
function k(e2, t2, n2, s2) {
  const r2 = [0, 0, 0, 0];
  for (let c2 = 0; c2 < s2; ++c2) switch (n2) {
    case "8unorm":
      r2[c2] = e2[t2] / 255, t2++;
      break;
    case "8snorm":
      r2[c2] = e2[t2] / 255 * 2 - 1, t2++;
      break;
    case "8uint":
      r2[c2] = e2[t2], t2++;
      break;
    case "8sint":
      r2[c2] = e2[t2] - 127, t2++;
      break;
    case "16uint":
      r2[c2] = e2[t2] | e2[t2 + 1] << 8, t2 += 2;
      break;
    case "16sint":
      r2[c2] = (e2[t2] | e2[t2 + 1] << 8) - 32768, t2 += 2;
      break;
    case "16float":
      r2[c2] = (a2 = e2[t2] | e2[t2 + 1] << 8, i2 = void 0, o2 = void 0, l2 = void 0, i2 = (32768 & a2) >> 15, l2 = 1023 & a2, 0 == (o2 = (31744 & a2) >> 10) ? (i2 ? -1 : 1) * Math.pow(2, -14) * (l2 / Math.pow(2, 10)) : 31 == o2 ? l2 ? NaN : 1 / 0 * (i2 ? -1 : 1) : (i2 ? -1 : 1) * Math.pow(2, o2 - 15) * (1 + l2 / Math.pow(2, 10))), t2 += 2;
      break;
    case "32uint":
    case "32sint":
      r2[c2] = e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24, t2 += 4;
      break;
    case "32float":
      r2[c2] = new Float32Array(e2.buffer, t2, 1)[0], t2 += 4;
  }
  var a2, i2, o2, l2;
  return r2;
}
function I(e2, t2, n2, s2, r2) {
  for (let a2 = 0; a2 < s2; ++a2) switch (n2) {
    case "8unorm":
      e2[t2] = 255 * r2[a2], t2++;
      break;
    case "8snorm":
      e2[t2] = 0.5 * (r2[a2] + 1) * 255, t2++;
      break;
    case "8uint":
      e2[t2] = r2[a2], t2++;
      break;
    case "8sint":
      e2[t2] = r2[a2] + 127, t2++;
      break;
    case "16uint":
      new Uint16Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 2;
      break;
    case "16sint":
      new Int16Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 2;
      break;
    case "16float": {
      const n3 = x(r2[a2]);
      new Uint16Array(e2.buffer, t2, 1)[0] = n3, t2 += 2;
      break;
    }
    case "32uint":
      new Uint32Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 4;
      break;
    case "32sint":
      new Int32Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 4;
      break;
    case "32float":
      new Float32Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 4;
  }
  return r2;
}
var T = { r8unorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8snorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8uint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8sint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg8unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8snorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "rgba8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8snorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, bgra8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "bgra8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, r16uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r16sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r16float: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg16uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg16sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg16float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba16uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba16sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba16float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, r32uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r32sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg32uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg32sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg32float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba32uint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba32sint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba32float: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgb10a2uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgb10a2unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rg11b10ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, stencil8: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: false, hasStencil: true, channels: 1 }, depth16unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, channels: 1 }, depth24plus: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, depthOnlyFormat: "depth32float", channels: 1 }, "depth24plus-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: true, depthOnlyFormat: "depth32float", channels: 1 }, depth32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, channels: 1 }, "depth32float-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: true, stencilOnlyFormat: "depth32float", channels: 1 }, rgb9e5ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "bc1-rgba-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc1-rgba-unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc2-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc2-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc3-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc3-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc4-r-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 1 }, "bc4-r-snorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 1 }, "bc5-rg-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 2 }, "bc5-rg-snorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 2 }, "bc6h-rgb-ufloat": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc6h-rgb-float": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc7-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc7-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8a1unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8a1unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgba8unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgba8unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "eac-r11unorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 1 }, "eac-r11snorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 1 }, "eac-rg11unorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 2 }, "eac-rg11snorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 2 }, "astc-4x4-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-4x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x4-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x5-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-5x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x5-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x6-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-6x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x5-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-8x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-8x6-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x8-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-8x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x5-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-10x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-10x6-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-10x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-10x8-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x10-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-10x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x10-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x12-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: true, channels: 4 }, "astc-12x12-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: true, channels: 4 } };
var S = class _S {
  constructor() {
    this.id = _S._id++, this.line = 0;
  }
  get isAstNode() {
    return true;
  }
  get astNodeType() {
    return "";
  }
  search(e2) {
    e2(this);
  }
  searchBlock(e2, t2) {
    if (e2) {
      t2(A.instance);
      for (const n2 of e2) n2 instanceof Array ? this.searchBlock(n2, t2) : n2.search(t2);
      t2(E.instance);
    }
  }
  constEvaluate(e2, t2) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(e2) {
    return this.constEvaluate(e2).toString();
  }
};
S._id = 0;
var A = class extends S {
};
A.instance = new A();
var E = class extends S {
};
E.instance = new E();
var $ = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
var L = class extends S {
  constructor() {
    super();
  }
};
var C = class extends L {
  constructor(e2, t2, n2, s2, r2, a2) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e2, this.args = t2, this.returnType = n2, this.body = s2, this.startLine = r2, this.endLine = a2;
  }
  get astNodeType() {
    return "function";
  }
  search(e2) {
    if (this.attributes) for (const t2 of this.attributes) e2(t2);
    e2(this);
    for (const t2 of this.args) e2(t2);
    this.searchBlock(this.body, e2);
  }
};
var N = class extends L {
  constructor(e2, t2) {
    super(), this.condition = e2, this.body = t2;
  }
  get astNodeType() {
    return "while";
  }
  search(e2) {
    this.condition.search(e2), this.searchBlock(this.body, e2);
  }
};
var V = class extends L {
  constructor(e2, t2) {
    super(), this.body = e2, this.loopId = t2;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e2) {
    this.searchBlock(this.body, e2);
  }
};
var O = class extends L {
  constructor(e2, t2, n2, s2) {
    super(), this.init = e2, this.condition = t2, this.increment = n2, this.body = s2;
  }
  get astNodeType() {
    return "for";
  }
  search(e2) {
    var t2, n2, s2;
    null === (t2 = this.init) || void 0 === t2 || t2.search(e2), null === (n2 = this.condition) || void 0 === n2 || n2.search(e2), null === (s2 = this.increment) || void 0 === s2 || s2.search(e2), this.searchBlock(this.body, e2);
  }
};
var B = class extends L {
  constructor(e2, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "var";
  }
  search(e2) {
    var t2;
    e2(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var F = class extends L {
  constructor(e2, t2, n2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.value = n2;
  }
  get astNodeType() {
    return "override";
  }
  search(e2) {
    var t2;
    null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var M = class extends L {
  constructor(e2, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "let";
  }
  search(e2) {
    var t2;
    e2(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var U = class extends L {
  constructor(e2, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(e2, t2) {
    return this.value.constEvaluate(e2, t2);
  }
  search(e2) {
    var t2;
    e2(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var P;
var W;
var q;
var H;
((e2) => {
  e2.increment = "++", e2.decrement = "--";
})(P || (P = {})), ((e2) => {
  e2.parse = function(t2) {
    const n2 = t2;
    if ("parse" == n2) throw new Error("Invalid value for IncrementOperator");
    return e2[n2];
  };
})(P || (P = {}));
var z = class extends L {
  constructor(e2, t2) {
    super(), this.operator = e2, this.variable = t2;
  }
  get astNodeType() {
    return "increment";
  }
  search(e2) {
    this.variable.search(e2);
  }
};
((e2) => {
  e2.assign = "=", e2.addAssign = "+=", e2.subtractAssin = "-=", e2.multiplyAssign = "*=", e2.divideAssign = "/=", e2.moduloAssign = "%=", e2.andAssign = "&=", e2.orAssign = "|=", e2.xorAssign = "^=", e2.shiftLeftAssign = "<<=", e2.shiftRightAssign = ">>=";
})(W || (W = {})), ((e2) => {
  e2.parse = function(e3) {
    const t2 = e3;
    if ("parse" == t2) throw new Error("Invalid value for AssignOperator");
    return t2;
  };
})(W || (W = {}));
var R = class extends L {
  constructor(e2, t2, n2) {
    super(), this.operator = e2, this.variable = t2, this.value = n2;
  }
  get astNodeType() {
    return "assign";
  }
  search(e2) {
    this.variable.search(e2), this.value.search(e2);
  }
};
var G = class extends L {
  constructor(e2, t2) {
    super(), this.name = e2, this.args = t2;
  }
  get astNodeType() {
    return "call";
  }
  isBuiltin() {
    return $.has(this.name);
  }
  search(e2) {
    for (const t2 of this.args) t2.search(e2);
    e2(this);
  }
};
var X = class extends L {
  constructor(e2, t2) {
    super(), this.body = e2, this.continuing = t2;
  }
  get astNodeType() {
    return "loop";
  }
};
var j = class extends L {
  constructor(e2, t2) {
    super(), this.condition = e2, this.cases = t2;
  }
  get astNodeType() {
    return "switch";
  }
  search(e2) {
    e2(this);
    for (const t2 of this.cases) t2.search(e2);
  }
};
var Z = class extends L {
  constructor(e2, t2, n2, s2) {
    super(), this.condition = e2, this.body = t2, this.elseif = n2, this.else = s2;
  }
  get astNodeType() {
    return "if";
  }
  search(e2) {
    this.condition.search(e2), this.searchBlock(this.body, e2), this.searchBlock(this.elseif, e2), this.searchBlock(this.else, e2);
  }
};
var Q = class extends L {
  constructor(e2) {
    super(), this.value = e2;
  }
  get astNodeType() {
    return "return";
  }
  search(e2) {
    var t2;
    null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var J = class extends L {
  constructor(e2, t2) {
    super(), this.severity = e2, this.rule = t2;
  }
  get astNodeType() {
    return "diagnostic";
  }
};
var ee = class extends L {
  constructor(e2, t2) {
    super(), this.name = e2, this.type = t2;
  }
  get astNodeType() {
    return "alias";
  }
};
var ne = class extends L {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
};
var se = class extends L {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
};
var re = class _re extends L {
  constructor(e2) {
    super(), this.attributes = null, this.name = e2;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return false;
  }
  get isArray() {
    return false;
  }
  static maxFormatType(e2) {
    let t2 = e2[0];
    if ("f32" === t2.name) return t2;
    for (let n2 = 1; n2 < e2.length; ++n2) {
      const s2 = _re._priority.get(t2.name);
      _re._priority.get(e2[n2].name) < s2 && (t2 = e2[n2]);
    }
    return "x32" === t2.name ? _re.i32 : t2;
  }
  getTypeName() {
    return this.name;
  }
};
re.x32 = new re("x32"), re.f32 = new re("f32"), re.i32 = new re("i32"), re.u32 = new re("u32"), re.f16 = new re("f16"), re.bool = new re("bool"), re.void = new re("void"), re._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
var ie = class extends re {
  constructor(e2, t2, n2, s2) {
    super(e2), this.members = t2, this.startLine = n2, this.endLine = s2;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return true;
  }
  getMemberIndex(e2) {
    for (let t2 = 0; t2 < this.members.length; t2++) if (this.members[t2].name == e2) return t2;
    return -1;
  }
  search(e2) {
    for (const t2 of this.members) e2(t2);
  }
};
var oe = class extends re {
  constructor(e2, t2, n2) {
    super(e2), this.format = t2, this.access = n2;
  }
  get astNodeType() {
    return "template";
  }
  getTypeName() {
    let e2 = this.name;
    if (null !== this.format) {
      if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2 || "mat2x2" === e2 || "mat2x3" === e2 || "mat2x4" === e2 || "mat3x2" === e2 || "mat3x3" === e2 || "mat3x4" === e2 || "mat4x2" === e2 || "mat4x3" === e2 || "mat4x4" === e2) {
        if ("f32" === this.format.name) return e2 += "f", e2;
        if ("i32" === this.format.name) return e2 += "i", e2;
        if ("u32" === this.format.name) return e2 += "u", e2;
        if ("bool" === this.format.name) return e2 += "b", e2;
        if ("f16" === this.format.name) return e2 += "h", e2;
      }
      e2 += `<${this.format.name}>`;
    } else if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2) return e2;
    return e2;
  }
};
oe.vec2f = new oe("vec2", re.f32, null), oe.vec3f = new oe("vec3", re.f32, null), oe.vec4f = new oe("vec4", re.f32, null), oe.vec2i = new oe("vec2", re.i32, null), oe.vec3i = new oe("vec3", re.i32, null), oe.vec4i = new oe("vec4", re.i32, null), oe.vec2u = new oe("vec2", re.u32, null), oe.vec3u = new oe("vec3", re.u32, null), oe.vec4u = new oe("vec4", re.u32, null), oe.vec2h = new oe("vec2", re.f16, null), oe.vec3h = new oe("vec3", re.f16, null), oe.vec4h = new oe("vec4", re.f16, null), oe.vec2b = new oe("vec2", re.bool, null), oe.vec3b = new oe("vec3", re.bool, null), oe.vec4b = new oe("vec4", re.bool, null), oe.mat2x2f = new oe("mat2x2", re.f32, null), oe.mat2x3f = new oe("mat2x3", re.f32, null), oe.mat2x4f = new oe("mat2x4", re.f32, null), oe.mat3x2f = new oe("mat3x2", re.f32, null), oe.mat3x3f = new oe("mat3x3", re.f32, null), oe.mat3x4f = new oe("mat3x4", re.f32, null), oe.mat4x2f = new oe("mat4x2", re.f32, null), oe.mat4x3f = new oe("mat4x3", re.f32, null), oe.mat4x4f = new oe("mat4x4", re.f32, null), oe.mat2x2h = new oe("mat2x2", re.f16, null), oe.mat2x3h = new oe("mat2x3", re.f16, null), oe.mat2x4h = new oe("mat2x4", re.f16, null), oe.mat3x2h = new oe("mat3x2", re.f16, null), oe.mat3x3h = new oe("mat3x3", re.f16, null), oe.mat3x4h = new oe("mat3x4", re.f16, null), oe.mat4x2h = new oe("mat4x2", re.f16, null), oe.mat4x3h = new oe("mat4x3", re.f16, null), oe.mat4x4h = new oe("mat4x4", re.f16, null), oe.mat2x2i = new oe("mat2x2", re.i32, null), oe.mat2x3i = new oe("mat2x3", re.i32, null), oe.mat2x4i = new oe("mat2x4", re.i32, null), oe.mat3x2i = new oe("mat3x2", re.i32, null), oe.mat3x3i = new oe("mat3x3", re.i32, null), oe.mat3x4i = new oe("mat3x4", re.i32, null), oe.mat4x2i = new oe("mat4x2", re.i32, null), oe.mat4x3i = new oe("mat4x3", re.i32, null), oe.mat4x4i = new oe("mat4x4", re.i32, null), oe.mat2x2u = new oe("mat2x2", re.u32, null), oe.mat2x3u = new oe("mat2x3", re.u32, null), oe.mat2x4u = new oe("mat2x4", re.u32, null), oe.mat3x2u = new oe("mat3x2", re.u32, null), oe.mat3x3u = new oe("mat3x3", re.u32, null), oe.mat3x4u = new oe("mat3x4", re.u32, null), oe.mat4x2u = new oe("mat4x2", re.u32, null), oe.mat4x3u = new oe("mat4x3", re.u32, null), oe.mat4x4u = new oe("mat4x4", re.u32, null);
var le = class extends re {
  constructor(e2, t2, n2, s2) {
    super(e2), this.storage = t2, this.type = n2, this.access = s2;
  }
  get astNodeType() {
    return "pointer";
  }
};
var ce = class extends re {
  constructor(e2, t2, n2, s2) {
    super(e2), this.attributes = t2, this.format = n2, this.count = s2;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return true;
  }
};
var ue = class extends re {
  constructor(e2, t2, n2) {
    super(e2), this.format = t2, this.access = n2;
  }
  get astNodeType() {
    return "sampler";
  }
};
var he = class extends S {
  constructor() {
    super(), this.postfix = null;
  }
};
var fe = class extends he {
  constructor(e2) {
    super(), this.value = e2;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
};
var pe = class extends he {
  constructor(e2, t2) {
    super(), this.type = e2, this.args = t2;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e2) {
    if (e2(this), this.args) for (const t2 of this.args) t2.search(e2);
  }
  constEvaluate(e2, t2) {
    return t2 && (t2[0] = this.type), e2.evalExpression(this, e2.context);
  }
};
var de = class extends he {
  constructor(e2, t2) {
    super(), this.cachedReturnValue = null, this.name = e2, this.args = t2;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(e2) {
    this.cachedReturnValue = e2;
  }
  get isBuiltin() {
    return $.has(this.name);
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
  search(e2) {
    for (const t2 of this.args) t2.search(e2);
    e2(this);
  }
};
var me = class extends he {
  constructor(e2) {
    super(), this.name = e2;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e2) {
    e2(this), this.postfix && this.postfix.search(e2);
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
};
var _e = class extends he {
  constructor(e2, t2) {
    super(), this.name = e2, this.initializer = t2;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(e2, t2) {
    if (this.initializer) {
      const t3 = e2.evalExpression(this.initializer, e2.context);
      return null !== t3 && this.postfix ? t3.getSubData(e2, this.postfix, e2.context) : t3;
    }
    return null;
  }
  search(e2) {
    this.initializer.search(e2);
  }
};
var ge = class extends he {
  constructor(e2, t2) {
    super(), this.value = e2, this.type = t2;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(e2, t2) {
    return void 0 !== t2 && (t2[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof Oe;
  }
  get isVector() {
    return this.value instanceof Fe || this.value instanceof Me;
  }
  get scalarValue() {
    return this.value instanceof Oe ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof Fe || this.value instanceof Me ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
  }
};
var xe = class extends he {
  constructor(e2, t2) {
    super(), this.type = e2, this.value = t2;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e2) {
    this.value.search(e2);
  }
};
var be = class extends he {
  constructor(e2) {
    super(), this.index = e2;
  }
  search(e2) {
    this.index.search(e2);
  }
};
var ve = class extends he {
  constructor() {
    super();
  }
};
var we = class extends ve {
  constructor(e2, t2) {
    super(), this.operator = e2, this.right = t2;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
  search(e2) {
    this.right.search(e2);
  }
};
var ke = class extends ve {
  constructor(e2, t2, n2) {
    super(), this.operator = e2, this.left = t2, this.right = n2;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(e2, t2) {
    return e2.name === t2.name ? e2 : "f32" === e2.name || "f32" === t2.name ? re.f32 : "u32" === e2.name || "u32" === t2.name ? re.u32 : re.i32;
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
  search(e2) {
    this.left.search(e2), this.right.search(e2);
  }
};
var Ie = class extends S {
  constructor(e2) {
    super(), this.body = e2;
  }
  search(e2) {
    e2(this), this.searchBlock(this.body, e2);
  }
};
var Te = class extends he {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
};
var Se = class extends Ie {
  constructor(e2, t2) {
    super(t2), this.selectors = e2;
  }
  get astNodeType() {
    return "case";
  }
  search(e2) {
    this.searchBlock(this.body, e2);
  }
};
var Ae = class extends Ie {
  constructor(e2) {
    super(e2);
  }
  get astNodeType() {
    return "default";
  }
  search(e2) {
    this.searchBlock(this.body, e2);
  }
};
var Ce = class extends S {
  constructor(e2, t2) {
    super(), this.name = e2, this.value = t2;
  }
  get astNodeType() {
    return "attribute";
  }
};
var De = class _De {
  constructor(e2, t2) {
    this.parent = null, this.typeInfo = e2, this.parent = t2, this.id = _De._id++;
  }
  clone() {
    throw `Clone: Not implemented for ${this.constructor.name}`;
  }
  setDataValue(e2, t2, n2, s2) {
    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
  }
  getSubData(e2, t2, n2) {
    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
  }
  toString() {
    return `<${this.typeInfo.getTypeName()}>`;
  }
};
De._id = 0;
var Ne = class extends De {
  constructor() {
    super(new e("void", null), null);
  }
  toString() {
    return "void";
  }
};
Ne.void = new Ne();
var Ve = class extends De {
  constructor(e2) {
    super(new r("pointer", e2.typeInfo, null), null), this.reference = e2;
  }
  clone() {
    return this;
  }
  setDataValue(e2, t2, n2, s2) {
    this.reference.setDataValue(e2, t2, n2, s2);
  }
  getSubData(e2, t2, n2) {
    return t2 ? this.reference.getSubData(e2, t2, n2) : this;
  }
  toString() {
    return `&${this.reference.toString()}`;
  }
};
var Oe = class _Oe extends De {
  constructor(e2, t2, n2 = null) {
    super(t2, n2), e2 instanceof Int32Array || e2 instanceof Uint32Array || e2 instanceof Float32Array ? this.data = e2 : "x32" === this.typeInfo.name ? e2 - Math.floor(e2) != 0 ? this.data = new Float32Array([e2]) : this.data = e2 >= 0 ? new Uint32Array([e2]) : new Int32Array([e2]) : "i32" === this.typeInfo.name || "bool" === this.typeInfo.name ? this.data = new Int32Array([e2]) : "u32" === this.typeInfo.name ? this.data = new Uint32Array([e2]) : "f32" === this.typeInfo.name || "f16" === this.typeInfo.name ? this.data = new Float32Array([e2]) : console.error("ScalarData2: Invalid type", t2);
  }
  clone() {
    if (this.data instanceof Float32Array) return new _Oe(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new _Oe(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new _Oe(new Uint32Array(this.data), this.typeInfo, null);
    throw "ScalarData: Invalid data type";
  }
  get value() {
    return this.data[0];
  }
  set value(e2) {
    this.data[0] = e2;
  }
  setDataValue(e2, t2, n2, s2) {
    if (n2) return void console.error("SetDataValue: Scalar data does not support postfix", n2);
    if (!(t2 instanceof _Oe)) return void console.error("SetDataValue: Invalid value", t2);
    let r2 = t2.data[0];
    "i32" === this.typeInfo.name || "u32" === this.typeInfo.name ? r2 = Math.floor(r2) : "bool" === this.typeInfo.name && (r2 = r2 ? 1 : 0), this.data[0] = r2;
  }
  getSubData(e2, t2, n2) {
    return t2 ? (console.error("getSubData: Scalar data does not support postfix", t2), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
};
function Be(e2, t2, n2) {
  const s2 = t2.length;
  return 2 === s2 ? "f32" === n2 ? new Fe(new Float32Array(t2), e2.getTypeInfo("vec2f")) : "i32" === n2 || "bool" === n2 ? new Fe(new Int32Array(t2), e2.getTypeInfo("vec2i")) : "u32" === n2 ? new Fe(new Uint32Array(t2), e2.getTypeInfo("vec2u")) : "f16" === n2 ? new Fe(new Float32Array(t2), e2.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : 3 === s2 ? "f32" === n2 ? new Fe(new Float32Array(t2), e2.getTypeInfo("vec3f")) : "i32" === n2 || "bool" === n2 ? new Fe(new Int32Array(t2), e2.getTypeInfo("vec3i")) : "u32" === n2 ? new Fe(new Uint32Array(t2), e2.getTypeInfo("vec3u")) : "f16" === n2 ? new Fe(new Float32Array(t2), e2.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : 4 === s2 ? "f32" === n2 ? new Fe(new Float32Array(t2), e2.getTypeInfo("vec4f")) : "i32" === n2 || "bool" === n2 ? new Fe(new Int32Array(t2), e2.getTypeInfo("vec4i")) : "u32" === n2 ? new Fe(new Uint32Array(t2), e2.getTypeInfo("vec4u")) : "f16" === n2 ? new Fe(new Float32Array(t2), e2.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : (console.error(`getSubData: Invalid vector size ${t2.length}`), null);
}
var Fe = class _Fe extends De {
  constructor(e2, t2, n2 = null) {
    if (super(t2, n2), e2 instanceof Float32Array || e2 instanceof Uint32Array || e2 instanceof Int32Array) this.data = e2;
    else {
      const t3 = this.typeInfo.name;
      "vec2f" === t3 || "vec3f" === t3 || "vec4f" === t3 ? this.data = new Float32Array(e2) : "vec2i" === t3 || "vec3i" === t3 || "vec4i" === t3 ? this.data = new Int32Array(e2) : "vec2u" === t3 || "vec3u" === t3 || "vec4u" === t3 ? this.data = new Uint32Array(e2) : "vec2h" === t3 || "vec3h" === t3 || "vec4h" === t3 ? this.data = new Float32Array(e2) : "vec2b" === t3 || "vec3b" === t3 || "vec4b" === t3 ? this.data = new Int32Array(e2) : "vec2" === t3 || "vec3" === t3 || "vec4" === t3 ? this.data = new Float32Array(e2) : console.error(`VectorData: Invalid type ${t3}`);
    }
  }
  clone() {
    if (this.data instanceof Float32Array) return new _Fe(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new _Fe(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new _Fe(new Uint32Array(this.data), this.typeInfo, null);
    throw "VectorData: Invalid data type";
  }
  setDataValue(e2, t2, n2, s2) {
    n2 instanceof fe ? console.error("TODO: Set vector postfix") : t2 instanceof _Fe ? this.data = t2.data : console.error("SetDataValue: Invalid value", t2);
  }
  getSubData(e2, t2, n2) {
    if (null === t2) return this;
    let s2 = e2.getTypeInfo("f32");
    if (this.typeInfo instanceof a) s2 = this.typeInfo.format || s2;
    else {
      const t3 = this.typeInfo.name;
      "vec2f" === t3 || "vec3f" === t3 || "vec4f" === t3 ? s2 = e2.getTypeInfo("f32") : "vec2i" === t3 || "vec3i" === t3 || "vec4i" === t3 ? s2 = e2.getTypeInfo("i32") : "vec2b" === t3 || "vec3b" === t3 || "vec4b" === t3 ? s2 = e2.getTypeInfo("bool") : "vec2u" === t3 || "vec3u" === t3 || "vec4u" === t3 ? s2 = e2.getTypeInfo("u32") : "vec2h" === t3 || "vec3h" === t3 || "vec4h" === t3 ? s2 = e2.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${t3}`);
    }
    let r2 = this;
    for (; null !== t2 && null !== r2; ) {
      if (t2 instanceof be) {
        const a2 = t2.index;
        let i2 = -1;
        if (a2 instanceof ge) {
          if (!(a2.value instanceof Oe)) return console.error(`GetSubData: Invalid array index ${a2.value}`), null;
          i2 = a2.value.value;
        } else {
          const t3 = e2.evalExpression(a2, n2);
          if (!(t3 instanceof Oe)) return console.error("GetSubData: Unknown index type", a2), null;
          i2 = t3.value;
        }
        if (i2 < 0 || i2 >= r2.data.length) return console.error("GetSubData: Index out of range", i2), null;
        if (r2.data instanceof Float32Array) {
          const e3 = new Float32Array(r2.data.buffer, r2.data.byteOffset + 4 * i2, 1);
          return new Oe(e3, s2);
        }
        if (r2.data instanceof Int32Array) {
          const e3 = new Int32Array(r2.data.buffer, r2.data.byteOffset + 4 * i2, 1);
          return new Oe(e3, s2);
        }
        if (r2.data instanceof Uint32Array) {
          const e3 = new Uint32Array(r2.data.buffer, r2.data.byteOffset + 4 * i2, 1);
          return new Oe(e3, s2);
        }
        throw "GetSubData: Invalid data type";
      }
      if (!(t2 instanceof fe)) return console.error("GetSubData: Unknown postfix", t2), null;
      {
        const n3 = t2.value.toLowerCase();
        if (1 === n3.length) {
          let e3 = 0;
          if ("x" === n3 || "r" === n3) e3 = 0;
          else if ("y" === n3 || "g" === n3) e3 = 1;
          else if ("z" === n3 || "b" === n3) e3 = 2;
          else {
            if ("w" !== n3 && "a" !== n3) return console.error(`GetSubData: Unknown member ${n3}`), null;
            e3 = 3;
          }
          if (this.data instanceof Float32Array) {
            let t3 = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * e3, 1);
            return new Oe(t3, s2, this);
          }
          if (this.data instanceof Int32Array) {
            let t3 = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * e3, 1);
            return new Oe(t3, s2, this);
          }
          if (this.data instanceof Uint32Array) {
            let t3 = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * e3, 1);
            return new Oe(t3, s2, this);
          }
        }
        const a2 = [];
        for (const e3 of n3) "x" === e3 || "r" === e3 ? a2.push(this.data[0]) : "y" === e3 || "g" === e3 ? a2.push(this.data[1]) : "z" === e3 || "b" === e3 ? a2.push(this.data[2]) : "w" === e3 || "a" === e3 ? a2.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${e3}`);
        r2 = Be(e2, a2, s2.name);
      }
      t2 = t2.postfix;
    }
    return r2;
  }
  toString() {
    let e2 = `${this.data[0]}`;
    for (let t2 = 1; t2 < this.data.length; ++t2) e2 += `, ${this.data[t2]}`;
    return e2;
  }
};
var Me = class _Me extends De {
  constructor(e2, t2, n2 = null) {
    super(t2, n2), e2 instanceof Float32Array ? this.data = e2 : this.data = new Float32Array(e2);
  }
  clone() {
    return new _Me(new Float32Array(this.data), this.typeInfo, null);
  }
  setDataValue(e2, t2, n2, s2) {
    n2 instanceof fe ? console.error("TODO: Set matrix postfix") : t2 instanceof _Me ? this.data = t2.data : console.error("SetDataValue: Invalid value", t2);
  }
  getSubData(e2, t2, n2) {
    if (null === t2) return this;
    const s2 = this.typeInfo.name;
    if (e2.getTypeInfo("f32"), this.typeInfo instanceof a) this.typeInfo.format;
    else if (s2.endsWith("f")) e2.getTypeInfo("f32");
    else if (s2.endsWith("i")) e2.getTypeInfo("i32");
    else if (s2.endsWith("u")) e2.getTypeInfo("u32");
    else {
      if (!s2.endsWith("h")) return console.error(`GetDataValue: Unknown type ${s2}`), null;
      e2.getTypeInfo("f16");
    }
    if (t2 instanceof be) {
      const r2 = t2.index;
      let a2 = -1;
      if (r2 instanceof ge) {
        if (!(r2.value instanceof Oe)) return console.error(`GetDataValue: Invalid array index ${r2.value}`), null;
        a2 = r2.value.value;
      } else {
        const t3 = e2.evalExpression(r2, n2);
        if (!(t3 instanceof Oe)) return console.error("GetDataValue: Unknown index type", r2), null;
        a2 = t3.value;
      }
      if (a2 < 0 || a2 >= this.data.length) return console.error("GetDataValue: Index out of range", a2), null;
      const i2 = s2.endsWith("h") ? "h" : "f";
      let o2;
      if ("mat2x2" === s2 || "mat2x2f" === s2 || "mat2x2h" === s2 || "mat3x2" === s2 || "mat3x2f" === s2 || "mat3x2h" === s2 || "mat4x2" === s2 || "mat4x2f" === s2 || "mat4x2h" === s2) o2 = new Fe(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * a2 * 4, 2), e2.getTypeInfo(`vec2${i2}`));
      else if ("mat2x3" === s2 || "mat2x3f" === s2 || "mat2x3h" === s2 || "mat3x3" === s2 || "mat3x3f" === s2 || "mat3x3h" === s2 || "mat4x3" === s2 || "mat4x3f" === s2 || "mat4x3h" === s2) o2 = new Fe(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * a2 * 4, 3), e2.getTypeInfo(`vec3${i2}`));
      else {
        if ("mat2x4" !== s2 && "mat2x4f" !== s2 && "mat2x4h" !== s2 && "mat3x4" !== s2 && "mat3x4f" !== s2 && "mat3x4h" !== s2 && "mat4x4" !== s2 && "mat4x4f" !== s2 && "mat4x4h" !== s2) return console.error(`GetDataValue: Unknown type ${s2}`), null;
        o2 = new Fe(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * a2 * 4, 4), e2.getTypeInfo(`vec4${i2}`));
      }
      return t2.postfix ? o2.getSubData(e2, t2.postfix, n2) : o2;
    }
    return console.error("GetDataValue: Invalid postfix", t2), null;
  }
  toString() {
    let e2 = `${this.data[0]}`;
    for (let t2 = 1; t2 < this.data.length; ++t2) e2 += `, ${this.data[t2]}`;
    return e2;
  }
};
var Ue = class _Ue extends De {
  constructor(e2, t2, n2 = 0, s2 = null) {
    super(t2, s2), this.buffer = e2 instanceof ArrayBuffer ? e2 : e2.buffer, this.offset = n2;
  }
  clone() {
    const e2 = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
    return new _Ue(e2.buffer, this.typeInfo, 0, null);
  }
  setDataValue(t2, r2, a2, i2) {
    if (null === r2) return void console.log("setDataValue: NULL data.");
    let o2 = this.offset, l2 = this.typeInfo;
    for (; a2; ) {
      if (a2 instanceof be) if (l2 instanceof s) {
        const e2 = a2.index;
        if (e2 instanceof ge) {
          if (!(e2.value instanceof Oe)) return void console.error(`SetDataValue: Invalid index type ${e2.value}`);
          o2 += e2.value.value * l2.stride;
        } else {
          const n2 = t2.evalExpression(e2, i2);
          if (!(n2 instanceof Oe)) return void console.error("SetDataValue: Unknown index type", e2);
          o2 += n2.value * l2.stride;
        }
        l2 = l2.format;
      } else console.error(`SetDataValue: Type ${l2.getTypeName()} is not an array`);
      else {
        if (!(a2 instanceof fe)) return void console.error("SetDataValue: Unknown postfix type", a2);
        {
          const t3 = a2.value;
          if (l2 instanceof n) {
            let e2 = false;
            for (const n2 of l2.members) if (n2.name === t3) {
              o2 += n2.offset, l2 = n2.type, e2 = true;
              break;
            }
            if (!e2) return void console.error(`SetDataValue: Member ${t3} not found`);
          } else if (l2 instanceof e) {
            const e2 = l2.getTypeName();
            let n2 = 0;
            if ("x" === t3 || "r" === t3) n2 = 0;
            else if ("y" === t3 || "g" === t3) n2 = 1;
            else if ("z" === t3 || "b" === t3) n2 = 2;
            else {
              if ("w" !== t3 && "a" !== t3) return void console.error(`SetDataValue: Unknown member ${t3}`);
              n2 = 3;
            }
            if (!(r2 instanceof Oe)) return void console.error("SetDataValue: Invalid value", r2);
            const s2 = r2.value;
            return "vec2f" === e2 ? void (new Float32Array(this.buffer, o2, 2)[n2] = s2) : "vec3f" === e2 ? void (new Float32Array(this.buffer, o2, 3)[n2] = s2) : "vec4f" === e2 ? void (new Float32Array(this.buffer, o2, 4)[n2] = s2) : "vec2i" === e2 ? void (new Int32Array(this.buffer, o2, 2)[n2] = s2) : "vec3i" === e2 ? void (new Int32Array(this.buffer, o2, 3)[n2] = s2) : "vec4i" === e2 ? void (new Int32Array(this.buffer, o2, 4)[n2] = s2) : "vec2u" === e2 ? void (new Uint32Array(this.buffer, o2, 2)[n2] = s2) : "vec3u" === e2 ? void (new Uint32Array(this.buffer, o2, 3)[n2] = s2) : "vec4u" === e2 ? void (new Uint32Array(this.buffer, o2, 4)[n2] = s2) : void console.error(`SetDataValue: Type ${e2} is not a struct`);
          }
        }
      }
      a2 = a2.postfix;
    }
    this.setData(t2, r2, l2, o2, i2);
  }
  setData(e2, t2, n2, s2, r2) {
    const a2 = n2.getTypeName();
    if ("f32" !== a2 && "f16" !== a2) if ("i32" !== a2 && "atomic<i32>" !== a2 && "x32" !== a2) if ("u32" !== a2 && "atomic<u32>" !== a2) if ("bool" !== a2) if ("vec2f" !== a2 && "vec2h" !== a2) if ("vec3f" !== a2 && "vec3h" !== a2) if ("vec4f" !== a2 && "vec4h" !== a2) if ("vec2i" !== a2) if ("vec3i" !== a2) if ("vec4i" !== a2) if ("vec2u" !== a2) if ("vec3u" !== a2) if ("vec4u" !== a2) if ("vec2b" !== a2) if ("vec3b" !== a2) if ("vec4b" !== a2) if ("mat2x2f" !== a2 && "mat2x2h" !== a2) if ("mat2x3f" !== a2 && "mat2x3h" !== a2) if ("mat2x4f" !== a2 && "mat2x4h" !== a2) if ("mat3x2f" !== a2 && "mat3x2h" !== a2) if ("mat3x3f" !== a2 && "mat3x3h" !== a2) if ("mat3x4f" !== a2 && "mat3x4h" !== a2) if ("mat4x2f" !== a2 && "mat4x2h" !== a2) if ("mat4x3f" !== a2 && "mat4x3h" !== a2) if ("mat4x4f" !== a2 && "mat4x4h" !== a2) if (t2 instanceof _Ue) {
      if (n2 === t2.typeInfo) {
        return void new Uint8Array(this.buffer, s2, t2.buffer.byteLength).set(new Uint8Array(t2.buffer));
      }
      console.error("SetDataValue: Type mismatch", a2, t2.typeInfo.getTypeName());
    } else console.error(`SetData: Unknown type ${a2}`);
    else {
      const e3 = new Float32Array(this.buffer, s2, 16);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8], e3[9] = t2.data[9], e3[10] = t2.data[10], e3[11] = t2.data[11], e3[12] = t2.data[12], e3[13] = t2.data[13], e3[14] = t2.data[14], e3[15] = t2.data[15]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11], e3[12] = t2[12], e3[13] = t2[13], e3[14] = t2[14], e3[15] = t2[15]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 12);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8], e3[9] = t2.data[9], e3[10] = t2.data[10], e3[11] = t2.data[11]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 8);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 12);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8], e3[9] = t2.data[9], e3[10] = t2.data[10], e3[11] = t2.data[11]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 9);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 6);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 8);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 6);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 4);
      t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]);
    }
    else {
      const e3 = new Uint32Array(this.buffer, s2, 4);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]);
    }
    else {
      const e3 = new Uint32Array(this.buffer, s2, 3);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]);
    }
    else {
      const e3 = new Uint32Array(this.buffer, s2, 2);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]);
    }
    else {
      const e3 = new Uint32Array(this.buffer, s2, 4);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]);
    }
    else {
      const e3 = new Uint32Array(this.buffer, s2, 3);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]);
    }
    else {
      const e3 = new Uint32Array(this.buffer, s2, 2);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]);
    }
    else {
      const e3 = new Int32Array(this.buffer, s2, 4);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]);
    }
    else {
      const e3 = new Int32Array(this.buffer, s2, 3);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]);
    }
    else {
      const e3 = new Int32Array(this.buffer, s2, 2);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 4);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 3);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]);
    }
    else {
      const e3 = new Float32Array(this.buffer, s2, 2);
      t2 instanceof Fe ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]);
    }
    else t2 instanceof Oe && (new Int32Array(this.buffer, s2, 1)[0] = t2.value);
    else t2 instanceof Oe && (new Uint32Array(this.buffer, s2, 1)[0] = t2.value);
    else t2 instanceof Oe && (new Int32Array(this.buffer, s2, 1)[0] = t2.value);
    else t2 instanceof Oe && (new Float32Array(this.buffer, s2, 1)[0] = t2.value);
  }
  getSubData(t2, r2, i2) {
    var o2, l2, c2;
    if (null === r2) return this;
    let u2 = this.offset, h2 = this.typeInfo;
    for (; r2; ) {
      if (r2 instanceof be) {
        const e2 = r2.index, n2 = e2 instanceof he ? t2.evalExpression(e2, i2) : e2;
        let a2 = 0;
        if (n2 instanceof Oe ? a2 = n2.value : "number" == typeof n2 ? a2 = n2 : console.error("GetDataValue: Invalid index type", e2), h2 instanceof s) u2 += a2 * h2.stride, h2 = h2.format;
        else {
          const e3 = h2.getTypeName();
          "mat4x4" === e3 || "mat4x4f" === e3 || "mat4x4h" === e3 ? (u2 += 16 * a2, h2 = t2.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${h2.getTypeName()} is not an array`);
        }
      } else {
        if (!(r2 instanceof fe)) return console.error("GetDataValue: Unknown postfix type", r2), null;
        {
          const s2 = r2.value;
          if (h2 instanceof n) {
            let e2 = false;
            for (const t3 of h2.members) if (t3.name === s2) {
              u2 += t3.offset, h2 = t3.type, e2 = true;
              break;
            }
            if (!e2) return console.error(`GetDataValue: Member ${s2} not found`), null;
          } else if (h2 instanceof e) {
            const e2 = h2.getTypeName();
            if ("vec2f" === e2 || "vec3f" === e2 || "vec4f" === e2 || "vec2i" === e2 || "vec3i" === e2 || "vec4i" === e2 || "vec2u" === e2 || "vec3u" === e2 || "vec4u" === e2 || "vec2b" === e2 || "vec3b" === e2 || "vec4b" === e2 || "vec2h" === e2 || "vec3h" === e2 || "vec4h" === e2 || "vec2" === e2 || "vec3" === e2 || "vec4" === e2) {
              if (s2.length > 0 && s2.length < 5) {
                let n2 = "f";
                const r3 = [];
                for (let a2 = 0; a2 < s2.length; ++a2) {
                  const i3 = s2[a2].toLowerCase();
                  let o3 = 0;
                  if ("x" === i3 || "r" === i3) o3 = 0;
                  else if ("y" === i3 || "g" === i3) o3 = 1;
                  else if ("z" === i3 || "b" === i3) o3 = 2;
                  else {
                    if ("w" !== i3 && "a" !== i3) return console.error(`Unknown member ${s2}`), null;
                    o3 = 3;
                  }
                  if (1 === s2.length) {
                    if (e2.endsWith("f")) return this.buffer.byteLength < u2 + 4 * o3 + 4 ? (console.log("Insufficient buffer data"), null) : new Oe(new Float32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("f32"), this);
                    if (e2.endsWith("h")) return new Oe(new Float32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("f16"), this);
                    if (e2.endsWith("i")) return new Oe(new Int32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("i32"), this);
                    if (e2.endsWith("b")) return new Oe(new Int32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("bool"), this);
                    if (e2.endsWith("u")) return new Oe(new Uint32Array(this.buffer, u2 + 4 * o3, 1), t2.getTypeInfo("i32"), this);
                  }
                  if ("vec2f" === e2) r3.push(new Float32Array(this.buffer, u2, 2)[o3]);
                  else if ("vec3f" === e2) {
                    if (u2 + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                    const e3 = new Float32Array(this.buffer, u2, 3);
                    r3.push(e3[o3]);
                  } else if ("vec4f" === e2) r3.push(new Float32Array(this.buffer, u2, 4)[o3]);
                  else if ("vec2i" === e2) n2 = "i", r3.push(new Int32Array(this.buffer, u2, 2)[o3]);
                  else if ("vec3i" === e2) n2 = "i", r3.push(new Int32Array(this.buffer, u2, 3)[o3]);
                  else if ("vec4i" === e2) n2 = "i", r3.push(new Int32Array(this.buffer, u2, 4)[o3]);
                  else if ("vec2u" === e2) {
                    n2 = "u";
                    const e3 = new Uint32Array(this.buffer, u2, 2);
                    r3.push(e3[o3]);
                  } else "vec3u" === e2 ? (n2 = "u", r3.push(new Uint32Array(this.buffer, u2, 3)[o3])) : "vec4u" === e2 && (n2 = "u", r3.push(new Uint32Array(this.buffer, u2, 4)[o3]));
                }
                return 2 === r3.length ? h2 = t2.getTypeInfo(`vec2${n2}`) : 3 === r3.length ? h2 = t2.getTypeInfo(`vec3${n2}`) : 4 === r3.length ? h2 = t2.getTypeInfo(`vec4${n2}`) : console.error(`GetDataValue: Invalid vector length ${r3.length}`), new Fe(r3, h2, null);
              }
              return console.error(`GetDataValue: Unknown member ${s2}`), null;
            }
            return console.error(`GetDataValue: Type ${e2} is not a struct`), null;
          }
        }
      }
      r2 = r2.postfix;
    }
    const f2 = h2.getTypeName();
    return "f32" === f2 ? new Oe(new Float32Array(this.buffer, u2, 1), h2, this) : "i32" === f2 ? new Oe(new Int32Array(this.buffer, u2, 1), h2, this) : "u32" === f2 ? new Oe(new Uint32Array(this.buffer, u2, 1), h2, this) : "vec2f" === f2 ? new Fe(new Float32Array(this.buffer, u2, 2), h2, this) : "vec3f" === f2 ? new Fe(new Float32Array(this.buffer, u2, 3), h2, this) : "vec4f" === f2 ? new Fe(new Float32Array(this.buffer, u2, 4), h2, this) : "vec2i" === f2 ? new Fe(new Int32Array(this.buffer, u2, 2), h2, this) : "vec3i" === f2 ? new Fe(new Int32Array(this.buffer, u2, 3), h2, this) : "vec4i" === f2 ? new Fe(new Int32Array(this.buffer, u2, 4), h2, this) : "vec2u" === f2 ? new Fe(new Uint32Array(this.buffer, u2, 2), h2, this) : "vec3u" === f2 ? new Fe(new Uint32Array(this.buffer, u2, 3), h2, this) : "vec4u" === f2 ? new Fe(new Uint32Array(this.buffer, u2, 4), h2, this) : h2 instanceof a && "atomic" === h2.name ? "u32" === (null === (o2 = h2.format) || void 0 === o2 ? void 0 : o2.name) ? new Oe(new Uint32Array(this.buffer, u2, 1)[0], h2.format, this) : "i32" === (null === (l2 = h2.format) || void 0 === l2 ? void 0 : l2.name) ? new Oe(new Int32Array(this.buffer, u2, 1)[0], h2.format, this) : (console.error(`GetDataValue: Invalid atomic format ${null === (c2 = h2.format) || void 0 === c2 ? void 0 : c2.name}`), null) : new _Ue(this.buffer, h2, u2, this);
  }
  toString() {
    let e2 = "";
    if (this.typeInfo instanceof s) if ("f32" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e2 = `[${t2[0]}`;
      for (let n2 = 1; n2 < t2.length; ++n2) e2 += `, ${t2[n2]}`;
    } else if ("i32" === this.typeInfo.format.name) {
      const t2 = new Int32Array(this.buffer, this.offset);
      e2 = `[${t2[0]}`;
      for (let n2 = 1; n2 < t2.length; ++n2) e2 += `, ${t2[n2]}`;
    } else if ("u32" === this.typeInfo.format.name) {
      const t2 = new Uint32Array(this.buffer, this.offset);
      e2 = `[${t2[0]}`;
      for (let n2 = 1; n2 < t2.length; ++n2) e2 += `, ${t2[n2]}`;
    } else if ("vec2f" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e2 = `[${t2[0]}, ${t2[1]}]`;
      for (let n2 = 1; n2 < t2.length / 2; ++n2) e2 += `, [${t2[2 * n2]}, ${t2[2 * n2 + 1]}]`;
    } else if ("vec3f" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e2 = `[${t2[0]}, ${t2[1]}, ${t2[2]}]`;
      for (let n2 = 4; n2 < t2.length; n2 += 4) e2 += `, [${t2[n2]}, ${t2[n2 + 1]}, ${t2[n2 + 2]}]`;
    } else if ("vec4f" === this.typeInfo.format.name) {
      const t2 = new Float32Array(this.buffer, this.offset);
      e2 = `[${t2[0]}, ${t2[1]}, ${t2[2]}, ${t2[3]}]`;
      for (let n2 = 4; n2 < t2.length; n2 += 4) e2 += `, [${t2[n2]}, ${t2[n2 + 1]}, ${t2[n2 + 2]}, ${t2[n2 + 3]}]`;
    } else e2 = "[...]";
    else this.typeInfo instanceof n ? e2 += "{...}" : e2 = "[...]";
    return e2;
  }
};
var Pe = class _Pe extends De {
  constructor(e2, t2, n2, s2) {
    super(t2, null), this.data = e2, this.descriptor = n2, this.view = s2;
  }
  clone() {
    return new _Pe(this.data, this.typeInfo, this.descriptor, this.view);
  }
  get width() {
    var e2, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 0 ? null !== (e2 = n2[0]) && void 0 !== e2 ? e2 : 0 : n2 instanceof Object && null !== (t2 = n2.width) && void 0 !== t2 ? t2 : 0;
  }
  get height() {
    var e2, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 1 ? null !== (e2 = n2[1]) && void 0 !== e2 ? e2 : 0 : n2 instanceof Object && null !== (t2 = n2.height) && void 0 !== t2 ? t2 : 0;
  }
  get depthOrArrayLayers() {
    var e2, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 2 ? null !== (e2 = n2[2]) && void 0 !== e2 ? e2 : 0 : n2 instanceof Object && null !== (t2 = n2.depthOrArrayLayers) && void 0 !== t2 ? t2 : 0;
  }
  get format() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.format) && void 0 !== e2 ? e2 : "rgba8unorm";
  }
  get sampleCount() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.sampleCount) && void 0 !== e2 ? e2 : 1;
  }
  get mipLevelCount() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.mipLevelCount) && void 0 !== e2 ? e2 : 1;
  }
  get dimension() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.dimension) && void 0 !== e2 ? e2 : "2d";
  }
  getMipLevelSize(e2) {
    if (e2 >= this.mipLevelCount) return [0, 0, 0];
    const t2 = [this.width, this.height, this.depthOrArrayLayers];
    for (let n2 = 0; n2 < t2.length; ++n2) t2[n2] = Math.max(1, t2[n2] >> e2);
    return t2;
  }
  get texelByteSize() {
    const e2 = this.format, t2 = T[e2];
    return t2 ? t2.isDepthStencil ? 4 : t2.bytesPerBlock : 0;
  }
  get bytesPerRow() {
    return this.width * this.texelByteSize;
  }
  get isDepthStencil() {
    const e2 = this.format, t2 = T[e2];
    return !!t2 && t2.isDepthStencil;
  }
  getGpuSize() {
    const e2 = this.format, t2 = T[e2], n2 = this.width;
    if (!e2 || n2 <= 0 || !t2) return -1;
    const s2 = this.height, r2 = this.depthOrArrayLayers, a2 = this.dimension;
    return n2 / t2.blockWidth * ("1d" === a2 ? 1 : s2 / t2.blockHeight) * t2.bytesPerBlock * r2;
  }
  getPixel(e2, t2, n2 = 0, s2 = 0) {
    const r2 = this.texelByteSize, a2 = this.bytesPerRow, i2 = this.height, o2 = this.data[s2];
    return w(new Uint8Array(o2), e2, t2, n2, s2, i2, a2, r2, this.format);
  }
  setPixel(e2, t2, n2, s2, r2) {
    const a2 = this.texelByteSize, i2 = this.bytesPerRow, o2 = this.height, l2 = this.data[s2];
    !function(e3, t3, n3, s3, r3, a3, i3, o3, l3, c2) {
      const u2 = s3 * (i3 >>= r3) * (a3 >>= r3) + n3 * i3 + t3 * o3;
      switch (l3) {
        case "r8unorm":
          return void I(e3, u2, "8unorm", 1, c2);
        case "r8snorm":
          return void I(e3, u2, "8snorm", 1, c2);
        case "r8uint":
          return void I(e3, u2, "8uint", 1, c2);
        case "r8sint":
          return void I(e3, u2, "8sint", 1, c2);
        case "rg8unorm":
          return void I(e3, u2, "8unorm", 2, c2);
        case "rg8snorm":
          return void I(e3, u2, "8snorm", 2, c2);
        case "rg8uint":
          return void I(e3, u2, "8uint", 2, c2);
        case "rg8sint":
          return void I(e3, u2, "8sint", 2, c2);
        case "rgba8unorm-srgb":
        case "rgba8unorm":
        case "bgra8unorm-srgb":
        case "bgra8unorm":
          return void I(e3, u2, "8unorm", 4, c2);
        case "rgba8snorm":
          return void I(e3, u2, "8snorm", 4, c2);
        case "rgba8uint":
          return void I(e3, u2, "8uint", 4, c2);
        case "rgba8sint":
          return void I(e3, u2, "8sint", 4, c2);
        case "r16uint":
          return void I(e3, u2, "16uint", 1, c2);
        case "r16sint":
          return void I(e3, u2, "16sint", 1, c2);
        case "r16float":
          return void I(e3, u2, "16float", 1, c2);
        case "rg16uint":
          return void I(e3, u2, "16uint", 2, c2);
        case "rg16sint":
          return void I(e3, u2, "16sint", 2, c2);
        case "rg16float":
          return void I(e3, u2, "16float", 2, c2);
        case "rgba16uint":
          return void I(e3, u2, "16uint", 4, c2);
        case "rgba16sint":
          return void I(e3, u2, "16sint", 4, c2);
        case "rgba16float":
          return void I(e3, u2, "16float", 4, c2);
        case "r32uint":
          return void I(e3, u2, "32uint", 1, c2);
        case "r32sint":
          return void I(e3, u2, "32sint", 1, c2);
        case "depth16unorm":
        case "depth24plus":
        case "depth24plus-stencil8":
        case "depth32float":
        case "depth32float-stencil8":
        case "r32float":
          return void I(e3, u2, "32float", 1, c2);
        case "rg32uint":
          return void I(e3, u2, "32uint", 2, c2);
        case "rg32sint":
          return void I(e3, u2, "32sint", 2, c2);
        case "rg32float":
          return void I(e3, u2, "32float", 2, c2);
        case "rgba32uint":
          return void I(e3, u2, "32uint", 4, c2);
        case "rgba32sint":
          return void I(e3, u2, "32sint", 4, c2);
        case "rgba32float":
          return void I(e3, u2, "32float", 4, c2);
        case "rg11b10ufloat":
          console.error("TODO: rg11b10ufloat not supported for writing");
      }
    }(new Uint8Array(l2), e2, t2, n2, s2, o2, i2, a2, this.format, r2);
  }
};
((e2) => {
  e2[e2.token = 0] = "token", e2[e2.keyword = 1] = "keyword", e2[e2.reserved = 2] = "reserved";
})(H || (H = {}));
var We = class {
  constructor(e2, t2, n2) {
    this.name = e2, this.type = t2, this.rule = n2;
  }
  toString() {
    return this.name;
  }
};
var qe = class {
};
q = qe, qe.none = new We("", H.reserved, ""), qe.eof = new We("EOF", H.token, ""), qe.reserved = { asm: new We("asm", H.reserved, "asm"), bf16: new We("bf16", H.reserved, "bf16"), do: new We("do", H.reserved, "do"), enum: new We("enum", H.reserved, "enum"), f16: new We("f16", H.reserved, "f16"), f64: new We("f64", H.reserved, "f64"), handle: new We("handle", H.reserved, "handle"), i8: new We("i8", H.reserved, "i8"), i16: new We("i16", H.reserved, "i16"), i64: new We("i64", H.reserved, "i64"), mat: new We("mat", H.reserved, "mat"), premerge: new We("premerge", H.reserved, "premerge"), regardless: new We("regardless", H.reserved, "regardless"), typedef: new We("typedef", H.reserved, "typedef"), u8: new We("u8", H.reserved, "u8"), u16: new We("u16", H.reserved, "u16"), u64: new We("u64", H.reserved, "u64"), unless: new We("unless", H.reserved, "unless"), using: new We("using", H.reserved, "using"), vec: new We("vec", H.reserved, "vec"), void: new We("void", H.reserved, "void") }, qe.keywords = { array: new We("array", H.keyword, "array"), atomic: new We("atomic", H.keyword, "atomic"), bool: new We("bool", H.keyword, "bool"), f32: new We("f32", H.keyword, "f32"), i32: new We("i32", H.keyword, "i32"), mat2x2: new We("mat2x2", H.keyword, "mat2x2"), mat2x3: new We("mat2x3", H.keyword, "mat2x3"), mat2x4: new We("mat2x4", H.keyword, "mat2x4"), mat3x2: new We("mat3x2", H.keyword, "mat3x2"), mat3x3: new We("mat3x3", H.keyword, "mat3x3"), mat3x4: new We("mat3x4", H.keyword, "mat3x4"), mat4x2: new We("mat4x2", H.keyword, "mat4x2"), mat4x3: new We("mat4x3", H.keyword, "mat4x3"), mat4x4: new We("mat4x4", H.keyword, "mat4x4"), ptr: new We("ptr", H.keyword, "ptr"), sampler: new We("sampler", H.keyword, "sampler"), sampler_comparison: new We("sampler_comparison", H.keyword, "sampler_comparison"), struct: new We("struct", H.keyword, "struct"), texture_1d: new We("texture_1d", H.keyword, "texture_1d"), texture_2d: new We("texture_2d", H.keyword, "texture_2d"), texture_2d_array: new We("texture_2d_array", H.keyword, "texture_2d_array"), texture_3d: new We("texture_3d", H.keyword, "texture_3d"), texture_cube: new We("texture_cube", H.keyword, "texture_cube"), texture_cube_array: new We("texture_cube_array", H.keyword, "texture_cube_array"), texture_multisampled_2d: new We("texture_multisampled_2d", H.keyword, "texture_multisampled_2d"), texture_storage_1d: new We("texture_storage_1d", H.keyword, "texture_storage_1d"), texture_storage_2d: new We("texture_storage_2d", H.keyword, "texture_storage_2d"), texture_storage_2d_array: new We("texture_storage_2d_array", H.keyword, "texture_storage_2d_array"), texture_storage_3d: new We("texture_storage_3d", H.keyword, "texture_storage_3d"), texture_depth_2d: new We("texture_depth_2d", H.keyword, "texture_depth_2d"), texture_depth_2d_array: new We("texture_depth_2d_array", H.keyword, "texture_depth_2d_array"), texture_depth_cube: new We("texture_depth_cube", H.keyword, "texture_depth_cube"), texture_depth_cube_array: new We("texture_depth_cube_array", H.keyword, "texture_depth_cube_array"), texture_depth_multisampled_2d: new We("texture_depth_multisampled_2d", H.keyword, "texture_depth_multisampled_2d"), texture_external: new We("texture_external", H.keyword, "texture_external"), u32: new We("u32", H.keyword, "u32"), vec2: new We("vec2", H.keyword, "vec2"), vec3: new We("vec3", H.keyword, "vec3"), vec4: new We("vec4", H.keyword, "vec4"), bitcast: new We("bitcast", H.keyword, "bitcast"), block: new We("block", H.keyword, "block"), break: new We("break", H.keyword, "break"), case: new We("case", H.keyword, "case"), continue: new We("continue", H.keyword, "continue"), continuing: new We("continuing", H.keyword, "continuing"), default: new We("default", H.keyword, "default"), diagnostic: new We("diagnostic", H.keyword, "diagnostic"), discard: new We("discard", H.keyword, "discard"), else: new We("else", H.keyword, "else"), enable: new We("enable", H.keyword, "enable"), fallthrough: new We("fallthrough", H.keyword, "fallthrough"), false: new We("false", H.keyword, "false"), fn: new We("fn", H.keyword, "fn"), for: new We("for", H.keyword, "for"), function: new We("function", H.keyword, "function"), if: new We("if", H.keyword, "if"), let: new We("let", H.keyword, "let"), const: new We("const", H.keyword, "const"), loop: new We("loop", H.keyword, "loop"), while: new We("while", H.keyword, "while"), private: new We("private", H.keyword, "private"), read: new We("read", H.keyword, "read"), read_write: new We("read_write", H.keyword, "read_write"), return: new We("return", H.keyword, "return"), requires: new We("requires", H.keyword, "requires"), storage: new We("storage", H.keyword, "storage"), switch: new We("switch", H.keyword, "switch"), true: new We("true", H.keyword, "true"), alias: new We("alias", H.keyword, "alias"), type: new We("type", H.keyword, "type"), uniform: new We("uniform", H.keyword, "uniform"), var: new We("var", H.keyword, "var"), override: new We("override", H.keyword, "override"), workgroup: new We("workgroup", H.keyword, "workgroup"), write: new We("write", H.keyword, "write"), r8unorm: new We("r8unorm", H.keyword, "r8unorm"), r8snorm: new We("r8snorm", H.keyword, "r8snorm"), r8uint: new We("r8uint", H.keyword, "r8uint"), r8sint: new We("r8sint", H.keyword, "r8sint"), r16uint: new We("r16uint", H.keyword, "r16uint"), r16sint: new We("r16sint", H.keyword, "r16sint"), r16float: new We("r16float", H.keyword, "r16float"), rg8unorm: new We("rg8unorm", H.keyword, "rg8unorm"), rg8snorm: new We("rg8snorm", H.keyword, "rg8snorm"), rg8uint: new We("rg8uint", H.keyword, "rg8uint"), rg8sint: new We("rg8sint", H.keyword, "rg8sint"), r32uint: new We("r32uint", H.keyword, "r32uint"), r32sint: new We("r32sint", H.keyword, "r32sint"), r32float: new We("r32float", H.keyword, "r32float"), rg16uint: new We("rg16uint", H.keyword, "rg16uint"), rg16sint: new We("rg16sint", H.keyword, "rg16sint"), rg16float: new We("rg16float", H.keyword, "rg16float"), rgba8unorm: new We("rgba8unorm", H.keyword, "rgba8unorm"), rgba8unorm_srgb: new We("rgba8unorm_srgb", H.keyword, "rgba8unorm_srgb"), rgba8snorm: new We("rgba8snorm", H.keyword, "rgba8snorm"), rgba8uint: new We("rgba8uint", H.keyword, "rgba8uint"), rgba8sint: new We("rgba8sint", H.keyword, "rgba8sint"), bgra8unorm: new We("bgra8unorm", H.keyword, "bgra8unorm"), bgra8unorm_srgb: new We("bgra8unorm_srgb", H.keyword, "bgra8unorm_srgb"), rgb10a2unorm: new We("rgb10a2unorm", H.keyword, "rgb10a2unorm"), rg11b10float: new We("rg11b10float", H.keyword, "rg11b10float"), rg32uint: new We("rg32uint", H.keyword, "rg32uint"), rg32sint: new We("rg32sint", H.keyword, "rg32sint"), rg32float: new We("rg32float", H.keyword, "rg32float"), rgba16uint: new We("rgba16uint", H.keyword, "rgba16uint"), rgba16sint: new We("rgba16sint", H.keyword, "rgba16sint"), rgba16float: new We("rgba16float", H.keyword, "rgba16float"), rgba32uint: new We("rgba32uint", H.keyword, "rgba32uint"), rgba32sint: new We("rgba32sint", H.keyword, "rgba32sint"), rgba32float: new We("rgba32float", H.keyword, "rgba32float"), static_assert: new We("static_assert", H.keyword, "static_assert") }, qe.tokens = { decimal_float_literal: new We("decimal_float_literal", H.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/), hex_float_literal: new We("hex_float_literal", H.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/), int_literal: new We("int_literal", H.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/), uint_literal: new We("uint_literal", H.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/), name: new We("name", H.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u), ident: new We("ident", H.token, /[_a-zA-Z][0-9a-zA-Z_]*/), and: new We("and", H.token, "&"), and_and: new We("and_and", H.token, "&&"), arrow: new We("arrow ", H.token, "->"), attr: new We("attr", H.token, "@"), forward_slash: new We("forward_slash", H.token, "/"), bang: new We("bang", H.token, "!"), bracket_left: new We("bracket_left", H.token, "["), bracket_right: new We("bracket_right", H.token, "]"), brace_left: new We("brace_left", H.token, "{"), brace_right: new We("brace_right", H.token, "}"), colon: new We("colon", H.token, ":"), comma: new We("comma", H.token, ","), equal: new We("equal", H.token, "="), equal_equal: new We("equal_equal", H.token, "=="), not_equal: new We("not_equal", H.token, "!="), greater_than: new We("greater_than", H.token, ">"), greater_than_equal: new We("greater_than_equal", H.token, ">="), shift_right: new We("shift_right", H.token, ">>"), less_than: new We("less_than", H.token, "<"), less_than_equal: new We("less_than_equal", H.token, "<="), shift_left: new We("shift_left", H.token, "<<"), modulo: new We("modulo", H.token, "%"), minus: new We("minus", H.token, "-"), minus_minus: new We("minus_minus", H.token, "--"), period: new We("period", H.token, "."), plus: new We("plus", H.token, "+"), plus_plus: new We("plus_plus", H.token, "++"), or: new We("or", H.token, "|"), or_or: new We("or_or", H.token, "||"), paren_left: new We("paren_left", H.token, "("), paren_right: new We("paren_right", H.token, ")"), semicolon: new We("semicolon", H.token, ";"), star: new We("star", H.token, "*"), tilde: new We("tilde", H.token, "~"), underscore: new We("underscore", H.token, "_"), xor: new We("xor", H.token, "^"), plus_equal: new We("plus_equal", H.token, "+="), minus_equal: new We("minus_equal", H.token, "-="), times_equal: new We("times_equal", H.token, "*="), division_equal: new We("division_equal", H.token, "/="), modulo_equal: new We("modulo_equal", H.token, "%="), and_equal: new We("and_equal", H.token, "&="), or_equal: new We("or_equal", H.token, "|="), xor_equal: new We("xor_equal", H.token, "^="), shift_right_equal: new We("shift_right_equal", H.token, ">>="), shift_left_equal: new We("shift_left_equal", H.token, "<<=") }, qe.simpleTokens = { "@": q.tokens.attr, "{": q.tokens.brace_left, "}": q.tokens.brace_right, ":": q.tokens.colon, ",": q.tokens.comma, "(": q.tokens.paren_left, ")": q.tokens.paren_right, ";": q.tokens.semicolon }, qe.literalTokens = { "&": q.tokens.and, "&&": q.tokens.and_and, "->": q.tokens.arrow, "/": q.tokens.forward_slash, "!": q.tokens.bang, "[": q.tokens.bracket_left, "]": q.tokens.bracket_right, "=": q.tokens.equal, "==": q.tokens.equal_equal, "!=": q.tokens.not_equal, ">": q.tokens.greater_than, ">=": q.tokens.greater_than_equal, ">>": q.tokens.shift_right, "<": q.tokens.less_than, "<=": q.tokens.less_than_equal, "<<": q.tokens.shift_left, "%": q.tokens.modulo, "-": q.tokens.minus, "--": q.tokens.minus_minus, ".": q.tokens.period, "+": q.tokens.plus, "++": q.tokens.plus_plus, "|": q.tokens.or, "||": q.tokens.or_or, "*": q.tokens.star, "~": q.tokens.tilde, _: q.tokens.underscore, "^": q.tokens.xor, "+=": q.tokens.plus_equal, "-=": q.tokens.minus_equal, "*=": q.tokens.times_equal, "/=": q.tokens.division_equal, "%=": q.tokens.modulo_equal, "&=": q.tokens.and_equal, "|=": q.tokens.or_equal, "^=": q.tokens.xor_equal, ">>=": q.tokens.shift_right_equal, "<<=": q.tokens.shift_left_equal }, qe.regexTokens = { decimal_float_literal: q.tokens.decimal_float_literal, hex_float_literal: q.tokens.hex_float_literal, int_literal: q.tokens.int_literal, uint_literal: q.tokens.uint_literal, ident: q.tokens.ident }, qe.storage_class = [q.keywords.function, q.keywords.private, q.keywords.workgroup, q.keywords.uniform, q.keywords.storage], qe.access_mode = [q.keywords.read, q.keywords.write, q.keywords.read_write], qe.sampler_type = [q.keywords.sampler, q.keywords.sampler_comparison], qe.sampled_texture_type = [q.keywords.texture_1d, q.keywords.texture_2d, q.keywords.texture_2d_array, q.keywords.texture_3d, q.keywords.texture_cube, q.keywords.texture_cube_array], qe.multisampled_texture_type = [q.keywords.texture_multisampled_2d], qe.storage_texture_type = [q.keywords.texture_storage_1d, q.keywords.texture_storage_2d, q.keywords.texture_storage_2d_array, q.keywords.texture_storage_3d], qe.depth_texture_type = [q.keywords.texture_depth_2d, q.keywords.texture_depth_2d_array, q.keywords.texture_depth_cube, q.keywords.texture_depth_cube_array, q.keywords.texture_depth_multisampled_2d], qe.texture_external_type = [q.keywords.texture_external], qe.any_texture_type = [...q.sampled_texture_type, ...q.multisampled_texture_type, ...q.storage_texture_type, ...q.depth_texture_type, ...q.texture_external_type], qe.texel_format = [q.keywords.r8unorm, q.keywords.r8snorm, q.keywords.r8uint, q.keywords.r8sint, q.keywords.r16uint, q.keywords.r16sint, q.keywords.r16float, q.keywords.rg8unorm, q.keywords.rg8snorm, q.keywords.rg8uint, q.keywords.rg8sint, q.keywords.r32uint, q.keywords.r32sint, q.keywords.r32float, q.keywords.rg16uint, q.keywords.rg16sint, q.keywords.rg16float, q.keywords.rgba8unorm, q.keywords.rgba8unorm_srgb, q.keywords.rgba8snorm, q.keywords.rgba8uint, q.keywords.rgba8sint, q.keywords.bgra8unorm, q.keywords.bgra8unorm_srgb, q.keywords.rgb10a2unorm, q.keywords.rg11b10float, q.keywords.rg32uint, q.keywords.rg32sint, q.keywords.rg32float, q.keywords.rgba16uint, q.keywords.rgba16sint, q.keywords.rgba16float, q.keywords.rgba32uint, q.keywords.rgba32sint, q.keywords.rgba32float], qe.const_literal = [q.tokens.int_literal, q.tokens.uint_literal, q.tokens.decimal_float_literal, q.tokens.hex_float_literal, q.keywords.true, q.keywords.false], qe.literal_or_ident = [q.tokens.ident, q.tokens.int_literal, q.tokens.uint_literal, q.tokens.decimal_float_literal, q.tokens.hex_float_literal, q.tokens.name], qe.element_count_expression = [q.tokens.int_literal, q.tokens.uint_literal, q.tokens.ident], qe.template_types = [q.keywords.vec2, q.keywords.vec3, q.keywords.vec4, q.keywords.mat2x2, q.keywords.mat2x3, q.keywords.mat2x4, q.keywords.mat3x2, q.keywords.mat3x3, q.keywords.mat3x4, q.keywords.mat4x2, q.keywords.mat4x3, q.keywords.mat4x4, q.keywords.atomic, q.keywords.bitcast, ...q.any_texture_type], qe.attribute_name = [q.tokens.ident, q.keywords.block, q.keywords.diagnostic], qe.assignment_operators = [q.tokens.equal, q.tokens.plus_equal, q.tokens.minus_equal, q.tokens.times_equal, q.tokens.division_equal, q.tokens.modulo_equal, q.tokens.and_equal, q.tokens.or_equal, q.tokens.xor_equal, q.tokens.shift_right_equal, q.tokens.shift_left_equal], qe.increment_operators = [q.tokens.plus_plus, q.tokens.minus_minus];
function Re(e2) {
  return Array.isArray(e2) || (null == e2 ? void 0 : e2.buffer) instanceof ArrayBuffer;
}
var Ge = new Float32Array(1);
var Xe = new Uint32Array(Ge.buffer);
var je = new Uint32Array(Ge.buffer);
var Ze = new Int32Array(1);
var Qe = new Float32Array(Ze.buffer);
var Ye = new Uint32Array(Ze.buffer);
var Ke = new Uint32Array(1);
var Je = new Float32Array(Ke.buffer);
var et = new Int32Array(Ke.buffer);
function tt(e2, t2, n2) {
  if (t2 === n2) return e2;
  if ("f32" === t2) {
    if ("i32" === n2 || "x32" === n2) return Ge[0] = e2, Xe[0];
    if ("u32" === n2) return Ge[0] = e2, je[0];
  } else if ("i32" === t2 || "x32" === t2) {
    if ("f32" === n2) return Ze[0] = e2, Qe[0];
    if ("u32" === n2) return Ze[0] = e2, Ye[0];
  } else if ("u32" === t2) {
    if ("f32" === n2) return Ke[0] = e2, Je[0];
    if ("i32" === n2 || "x32" === n2) return Ke[0] = e2, et[0];
  }
  return console.error(`Unsupported cast from ${t2} to ${n2}`), e2;
}
var nt = class {
  constructor(e2) {
    this.resources = null, this.inUse = false, this.info = null, this.node = e2;
  }
};
var st = class {
  constructor(e2, t2) {
    this.align = e2, this.size = t2;
  }
};
var rt = class _rt {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new d(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(e2) {
    return "texture_storage_1d" == e2.name || "texture_storage_2d" == e2.name || "texture_storage_2d_array" == e2.name || "texture_storage_3d" == e2.name;
  }
  updateAST(e2) {
    for (const t2 of e2) t2 instanceof C && this._functions.set(t2.name, new nt(t2));
    for (const t2 of e2) if (t2 instanceof ie) {
      const e3 = this.getTypeInfo(t2, null);
      e3 instanceof n && this.structs.push(e3);
    }
    for (const t2 of e2) if (t2 instanceof ee) this.aliases.push(this._getAliasInfo(t2));
    else if (t2 instanceof F) {
      const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "id", 0), s2 = null != e3.type ? this.getTypeInfo(e3.type, e3.attributes) : null;
      this.overrides.push(new h(e3.name, s2, e3.attributes, n2));
    } else if (this._isUniformVar(t2)) {
      const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = new o(e3.name, r2, n2, s2, e3.attributes, i.Uniform, e3.access);
      a2.access || (a2.access = "read"), this.uniforms.push(a2);
    } else if (this._isStorageVar(t2)) {
      const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = this._isStorageTexture(r2), l2 = new o(e3.name, r2, n2, s2, e3.attributes, a2 ? i.StorageTexture : i.Storage, e3.access);
      l2.access || (l2.access = "read"), this.storage.push(l2);
    } else if (this._isTextureVar(t2)) {
      const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = this._isStorageTexture(r2), l2 = new o(e3.name, r2, n2, s2, e3.attributes, a2 ? i.StorageTexture : i.Texture, e3.access);
      l2.access || (l2.access = "read"), a2 ? this.storage.push(l2) : this.textures.push(l2);
    } else if (this._isSamplerVar(t2)) {
      const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = new o(e3.name, r2, n2, s2, e3.attributes, i.Sampler, e3.access);
      this.samplers.push(a2);
    } else ;
    for (const t2 of e2) if (t2 instanceof C) {
      const e3 = this._getAttribute(t2, "vertex"), n2 = this._getAttribute(t2, "fragment"), s2 = this._getAttribute(t2, "compute"), r2 = e3 || n2 || s2, a2 = new p(t2.name, null == r2 ? void 0 : r2.name, t2.attributes);
      a2.attributes = t2.attributes, a2.startLine = t2.startLine, a2.endLine = t2.endLine, this.functions.push(a2), this._functions.get(t2.name).info = a2, r2 && (this._functions.get(t2.name).inUse = true, a2.inUse = true, a2.resources = this._findResources(t2, !!r2), a2.inputs = this._getInputs(t2.args), a2.outputs = this._getOutputs(t2.returnType), this.entry[r2.name].push(a2)), a2.arguments = t2.args.map((e4) => new f(e4.name, this.getTypeInfo(e4.type, e4.attributes), e4.attributes)), a2.returnType = t2.returnType ? this.getTypeInfo(t2.returnType, t2.attributes) : null;
    } else ;
    for (const e3 of this._functions.values()) e3.info && (e3.info.inUse = e3.inUse, this._addCalls(e3.node, e3.info.calls));
    for (const e3 of this._functions.values()) e3.node.search((t2) => {
      var n2, s2, r2;
      if (t2 instanceof Ce) {
        if (t2.value) if (Re(t2.value)) for (const s3 of t2.value) for (const t3 of this.overrides) s3 === t3.name && (null === (n2 = e3.info) || void 0 === n2 || n2.overrides.push(t3));
        else for (const n3 of this.overrides) t2.value === n3.name && (null === (s2 = e3.info) || void 0 === s2 || s2.overrides.push(n3));
      } else if (t2 instanceof me) for (const n3 of this.overrides) t2.name === n3.name && (null === (r2 = e3.info) || void 0 === r2 || r2.overrides.push(n3));
    });
    for (const e3 of this.uniforms) this._markStructsInUse(e3.type);
    for (const e3 of this.storage) this._markStructsInUse(e3.type);
  }
  getStructInfo(e2) {
    for (const t2 of this.structs) if (t2.name == e2) return t2;
    return null;
  }
  getOverrideInfo(e2) {
    for (const t2 of this.overrides) if (t2.name == e2) return t2;
    return null;
  }
  _markStructsInUse(e2) {
    if (e2) if (e2.isStruct) {
      if (e2.inUse = true, e2.members) for (const t2 of e2.members) this._markStructsInUse(t2.type);
    } else if (e2.isArray) this._markStructsInUse(e2.format);
    else if (e2.isTemplate) e2.format && this._markStructsInUse(e2.format);
    else {
      const t2 = this._getAlias(e2.name);
      t2 && this._markStructsInUse(t2);
    }
  }
  _addCalls(e2, t2) {
    var n2;
    for (const s2 of e2.calls) {
      const e3 = null === (n2 = this._functions.get(s2.name)) || void 0 === n2 ? void 0 : n2.info;
      e3 && t2.add(e3);
    }
  }
  findResource(e2, t2, n2) {
    if (n2) {
      for (const s2 of this.entry.compute) if (s2.name === n2) {
        for (const n3 of s2.resources) if (n3.group == e2 && n3.binding == t2) return n3;
      }
      for (const s2 of this.entry.vertex) if (s2.name === n2) {
        for (const n3 of s2.resources) if (n3.group == e2 && n3.binding == t2) return n3;
      }
      for (const s2 of this.entry.fragment) if (s2.name === n2) {
        for (const n3 of s2.resources) if (n3.group == e2 && n3.binding == t2) return n3;
      }
    }
    for (const n3 of this.uniforms) if (n3.group == e2 && n3.binding == t2) return n3;
    for (const n3 of this.storage) if (n3.group == e2 && n3.binding == t2) return n3;
    for (const n3 of this.textures) if (n3.group == e2 && n3.binding == t2) return n3;
    for (const n3 of this.samplers) if (n3.group == e2 && n3.binding == t2) return n3;
    return null;
  }
  _findResource(e2) {
    for (const t2 of this.uniforms) if (t2.name == e2) return t2;
    for (const t2 of this.storage) if (t2.name == e2) return t2;
    for (const t2 of this.textures) if (t2.name == e2) return t2;
    for (const t2 of this.samplers) if (t2.name == e2) return t2;
    return null;
  }
  _markStructsFromAST(e2) {
    const t2 = this.getTypeInfo(e2, null);
    this._markStructsInUse(t2);
  }
  _findResources(e2, t2) {
    const n2 = [], s2 = this, r2 = [];
    return e2.search((a2) => {
      if (a2 instanceof A) r2.push({});
      else if (a2 instanceof E) r2.pop();
      else if (a2 instanceof B) {
        const e3 = a2;
        t2 && null !== e3.type && this._markStructsFromAST(e3.type), r2.length > 0 && (r2[r2.length - 1][e3.name] = e3);
      } else if (a2 instanceof pe) {
        const e3 = a2;
        t2 && null !== e3.type && this._markStructsFromAST(e3.type);
      } else if (a2 instanceof M) {
        const e3 = a2;
        t2 && null !== e3.type && this._markStructsFromAST(e3.type), r2.length > 0 && (r2[r2.length - 1][e3.name] = e3);
      } else if (a2 instanceof me) {
        const e3 = a2;
        if (r2.length > 0) {
          if (r2[r2.length - 1][e3.name]) return;
        }
        const t3 = s2._findResource(e3.name);
        t3 && n2.push(t3);
      } else if (a2 instanceof de) {
        const r3 = a2, i2 = s2._functions.get(r3.name);
        i2 && (t2 && (i2.inUse = true), e2.calls.add(i2.node), null === i2.resources && (i2.resources = s2._findResources(i2.node, t2)), n2.push(...i2.resources));
      } else if (a2 instanceof G) {
        const r3 = a2, i2 = s2._functions.get(r3.name);
        i2 && (t2 && (i2.inUse = true), e2.calls.add(i2.node), null === i2.resources && (i2.resources = s2._findResources(i2.node, t2)), n2.push(...i2.resources));
      }
    }), [...new Map(n2.map((e3) => [e3.name, e3])).values()];
  }
  getBindGroups() {
    const e2 = [];
    function t2(t3, n2) {
      t3 >= e2.length && (e2.length = t3 + 1), void 0 === e2[t3] && (e2[t3] = []), n2 >= e2[t3].length && (e2[t3].length = n2 + 1);
    }
    for (const n2 of this.uniforms) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.storage) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.textures) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.samplers) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    return e2;
  }
  _getOutputs(e2, t2 = void 0) {
    if (void 0 === t2 && (t2 = []), e2 instanceof ie) this._getStructOutputs(e2, t2);
    else {
      const n2 = this._getOutputInfo(e2);
      null !== n2 && t2.push(n2);
    }
    return t2;
  }
  _getStructOutputs(e2, t2) {
    for (const n2 of e2.members) if (n2.type instanceof ie) this._getStructOutputs(n2.type, t2);
    else {
      const e3 = this._getAttribute(n2, "location") || this._getAttribute(n2, "builtin");
      if (null !== e3) {
        const s2 = this.getTypeInfo(n2.type, n2.type.attributes), r2 = this._parseInt(e3.value), a2 = new u(n2.name, s2, e3.name, r2);
        t2.push(a2);
      }
    }
  }
  _getOutputInfo(e2) {
    const t2 = this._getAttribute(e2, "location") || this._getAttribute(e2, "builtin");
    if (null !== t2) {
      const n2 = this.getTypeInfo(e2, e2.attributes), s2 = this._parseInt(t2.value);
      return new u("", n2, t2.name, s2);
    }
    return null;
  }
  _getInputs(e2, t2 = void 0) {
    void 0 === t2 && (t2 = []);
    for (const n2 of e2) if (n2.type instanceof ie) this._getStructInputs(n2.type, t2);
    else {
      const e3 = this._getInputInfo(n2);
      null !== e3 && t2.push(e3);
    }
    return t2;
  }
  _getStructInputs(e2, t2) {
    for (const n2 of e2.members) if (n2.type instanceof ie) this._getStructInputs(n2.type, t2);
    else {
      const e3 = this._getInputInfo(n2);
      null !== e3 && t2.push(e3);
    }
  }
  _getInputInfo(e2) {
    const t2 = this._getAttribute(e2, "location") || this._getAttribute(e2, "builtin");
    if (null !== t2) {
      const n2 = this._getAttribute(e2, "interpolation"), s2 = this.getTypeInfo(e2.type, e2.attributes), r2 = this._parseInt(t2.value), a2 = new c(e2.name, s2, t2.name, r2);
      return null !== n2 && (a2.interpolation = this._parseString(n2.value)), a2;
    }
    return null;
  }
  _parseString(e2) {
    return e2 instanceof Array && (e2 = e2[0]), e2;
  }
  _parseInt(e2) {
    e2 instanceof Array && (e2 = e2[0]);
    const t2 = parseInt(e2);
    return isNaN(t2) ? e2 : t2;
  }
  _getAlias(e2) {
    for (const t2 of this.aliases) if (t2.name == e2) return t2.type;
    return null;
  }
  _getAliasInfo(e2) {
    return new l(e2.name, this.getTypeInfo(e2.type, null));
  }
  getTypeInfoByName(e2) {
    for (const t2 of this.structs) if (t2.name == e2) return t2;
    for (const t2 of this.aliases) if (t2.name == e2) return t2.type;
    return null;
  }
  getTypeInfo(i2, o2 = null) {
    if (this._types.has(i2)) return this._types.get(i2);
    if (i2 instanceof le) {
      const e2 = i2.type ? this.getTypeInfo(i2.type, i2.attributes) : null, t2 = new r(i2.name, e2, o2);
      return this._types.set(i2, t2), this._updateTypeInfo(t2), t2;
    }
    if (i2 instanceof ce) {
      const e2 = i2, t2 = e2.format ? this.getTypeInfo(e2.format, e2.attributes) : null, n2 = new s(e2.name, o2);
      return n2.format = t2, n2.count = e2.count, this._types.set(i2, n2), this._updateTypeInfo(n2), n2;
    }
    if (i2 instanceof ie) {
      const e2 = i2, s2 = new n(e2.name, o2);
      s2.startLine = e2.startLine, s2.endLine = e2.endLine;
      for (const n2 of e2.members) {
        const e3 = this.getTypeInfo(n2.type, n2.attributes);
        s2.members.push(new t(n2.name, e3, n2.attributes));
      }
      return this._types.set(i2, s2), this._updateTypeInfo(s2), s2;
    }
    if (i2 instanceof ue) {
      const t2 = i2, n2 = t2.format instanceof re, s2 = t2.format ? n2 ? this.getTypeInfo(t2.format, null) : new e(t2.format, null) : null, r2 = new a(t2.name, s2, o2, t2.access);
      return this._types.set(i2, r2), this._updateTypeInfo(r2), r2;
    }
    if (i2 instanceof oe) {
      const e2 = i2, t2 = e2.format ? this.getTypeInfo(e2.format, null) : null, n2 = new a(e2.name, t2, o2, e2.access);
      return this._types.set(i2, n2), this._updateTypeInfo(n2), n2;
    }
    const l2 = new e(i2.name, o2);
    return this._types.set(i2, l2), this._updateTypeInfo(l2), l2;
  }
  _updateTypeInfo(e2) {
    var t2, a2, i2;
    const o2 = this._getTypeSize(e2);
    if (e2.size = null !== (t2 = null == o2 ? void 0 : o2.size) && void 0 !== t2 ? t2 : 0, e2 instanceof s && e2.format) {
      const t3 = this._getTypeSize(e2.format);
      e2.stride = Math.max(null !== (a2 = null == t3 ? void 0 : t3.size) && void 0 !== a2 ? a2 : 0, null !== (i2 = null == t3 ? void 0 : t3.align) && void 0 !== i2 ? i2 : 0), this._updateTypeInfo(e2.format);
    }
    e2 instanceof r && this._updateTypeInfo(e2.format), e2 instanceof n && this._updateStructInfo(e2);
  }
  _updateStructInfo(e2) {
    var t2;
    let n2 = 0, s2 = 0, r2 = 0, a2 = 0;
    for (let i2 = 0, o2 = e2.members.length; i2 < o2; ++i2) {
      const o3 = e2.members[i2], l2 = this._getTypeSize(o3);
      if (!l2) continue;
      null !== (t2 = this._getAlias(o3.type.name)) && void 0 !== t2 || o3.type;
      const c2 = l2.align, u2 = l2.size;
      n2 = this._roundUp(c2, n2 + s2), s2 = u2, r2 = n2, a2 = Math.max(a2, c2), o3.offset = n2, o3.size = u2, this._updateTypeInfo(o3.type);
    }
    e2.size = this._roundUp(a2, r2 + s2), e2.align = a2;
  }
  _getTypeSize(r2) {
    var a2, i2;
    if (null == r2) return null;
    const o2 = this._getAttributeNum(r2.attributes, "size", 0), l2 = this._getAttributeNum(r2.attributes, "align", 0);
    if (r2 instanceof t && (r2 = r2.type), r2 instanceof e) {
      const e2 = this._getAlias(r2.name);
      null !== e2 && (r2 = e2);
    }
    {
      const e2 = _rt._typeInfo[r2.name];
      if (void 0 !== e2) {
        const t2 = "f16" === (null === (a2 = r2.format) || void 0 === a2 ? void 0 : a2.name) ? 2 : 1;
        return new st(Math.max(l2, e2.align / t2), Math.max(o2, e2.size / t2));
      }
    }
    {
      const e2 = _rt._typeInfo[r2.name.substring(0, r2.name.length - 1)];
      if (e2) {
        const t2 = "h" === r2.name[r2.name.length - 1] ? 2 : 1;
        return new st(Math.max(l2, e2.align / t2), Math.max(o2, e2.size / t2));
      }
    }
    if (r2 instanceof s) {
      let e2 = r2, t2 = 8, n2 = 8;
      const s2 = this._getTypeSize(e2.format);
      null !== s2 && (n2 = s2.size, t2 = s2.align);
      return n2 = e2.count * this._getAttributeNum(null !== (i2 = null == r2 ? void 0 : r2.attributes) && void 0 !== i2 ? i2 : null, "stride", this._roundUp(t2, n2)), o2 && (n2 = o2), new st(Math.max(l2, t2), Math.max(o2, n2));
    }
    if (r2 instanceof n) {
      let e2 = 0, t2 = 0, n2 = 0, s2 = 0, a3 = 0;
      for (const t3 of r2.members) {
        const r3 = this._getTypeSize(t3.type);
        null !== r3 && (e2 = Math.max(r3.align, e2), n2 = this._roundUp(r3.align, n2 + s2), s2 = r3.size, a3 = n2);
      }
      return t2 = this._roundUp(e2, a3 + s2), new st(Math.max(l2, e2), Math.max(o2, t2));
    }
    return null;
  }
  _isUniformVar(e2) {
    return e2 instanceof B && "uniform" == e2.storage;
  }
  _isStorageVar(e2) {
    return e2 instanceof B && "storage" == e2.storage;
  }
  _isTextureVar(e2) {
    return e2 instanceof B && null !== e2.type && -1 != _rt._textureTypes.indexOf(e2.type.name);
  }
  _isSamplerVar(e2) {
    return e2 instanceof B && null !== e2.type && -1 != _rt._samplerTypes.indexOf(e2.type.name);
  }
  _getAttribute(e2, t2) {
    const n2 = e2;
    if (!n2 || !n2.attributes) return null;
    const s2 = n2.attributes;
    for (let e3 of s2) if (e3.name == t2) return e3;
    return null;
  }
  _getAttributeNum(e2, t2, n2) {
    if (null === e2) return n2;
    for (let s2 of e2) if (s2.name == t2) {
      let e3 = null !== s2 && null !== s2.value ? s2.value : n2;
      return e3 instanceof Array && (e3 = e3[0]), "number" == typeof e3 ? e3 : "string" == typeof e3 ? parseInt(e3) : n2;
    }
    return n2;
  }
  _roundUp(e2, t2) {
    return Math.ceil(t2 / e2) * e2;
  }
};
rt._typeInfo = { f16: { align: 2, size: 2 }, i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, atomic: { align: 4, size: 4 }, vec2: { align: 8, size: 8 }, vec3: { align: 16, size: 12 }, vec4: { align: 16, size: 16 }, mat2x2: { align: 8, size: 16 }, mat3x2: { align: 8, size: 24 }, mat4x2: { align: 8, size: 32 }, mat2x3: { align: 16, size: 32 }, mat3x3: { align: 16, size: 48 }, mat4x3: { align: 16, size: 64 }, mat2x4: { align: 16, size: 32 }, mat3x4: { align: 16, size: 48 }, mat4x4: { align: 16, size: 64 } }, rt._textureTypes = qe.any_texture_type.map((e2) => e2.name), rt._samplerTypes = qe.sampler_type.map((e2) => e2.name);
var at = 0;
var it = class _it {
  constructor(e2, t2, n2) {
    this.id = at++, this.name = e2, this.value = t2, this.node = n2;
  }
  clone() {
    return new _it(this.name, this.value, this.node);
  }
};
var ot = class _ot {
  constructor(e2) {
    this.id = at++, this.name = e2.name, this.node = e2;
  }
  clone() {
    return new _ot(this.node);
  }
};
var lt = class _lt {
  constructor(e2) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = at++, e2 && (this.parent = e2, this.currentFunctionName = e2.currentFunctionName);
  }
  getVariable(e2) {
    var t2;
    return this.variables.has(e2) ? null !== (t2 = this.variables.get(e2)) && void 0 !== t2 ? t2 : null : this.parent ? this.parent.getVariable(e2) : null;
  }
  getFunction(e2) {
    var t2;
    return this.functions.has(e2) ? null !== (t2 = this.functions.get(e2)) && void 0 !== t2 ? t2 : null : this.parent ? this.parent.getFunction(e2) : null;
  }
  createVariable(e2, t2, n2) {
    this.variables.set(e2, new it(e2, t2, null != n2 ? n2 : null));
  }
  setVariable(e2, t2, n2) {
    const s2 = this.getVariable(e2);
    null !== s2 ? s2.value = t2 : this.createVariable(e2, t2, n2);
  }
  getVariableValue(e2) {
    var t2;
    const n2 = this.getVariable(e2);
    return null !== (t2 = null == n2 ? void 0 : n2.value) && void 0 !== t2 ? t2 : null;
  }
  clone() {
    return new _lt(this);
  }
};
var ct = class {
  evalExpression(e2, t2) {
    return null;
  }
  getTypeInfo(e2) {
    return null;
  }
  getVariableName(e2, t2) {
    return "";
  }
};
var ut = class {
  constructor(e2) {
    this.exec = e2;
  }
  getTypeInfo(e2) {
    return this.exec.getTypeInfo(e2);
  }
  All(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    let s2 = true;
    if (n2 instanceof Fe) return n2.data.forEach((e3) => {
      e3 || (s2 = false);
    }), new Oe(s2 ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${e2.line}`);
  }
  Any(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) {
      const e3 = n2.data.some((e4) => e4);
      return new Oe(e3 ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${e2.line}`);
  }
  Select(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[2], t2);
    if (!(n2 instanceof Oe)) throw new Error(`Select() expects a bool condition. Line ${e2.line}`);
    return n2.value ? this.exec.evalExpression(e2.args[1], t2) : this.exec.evalExpression(e2.args[0], t2);
  }
  ArrayLength(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.evalExpression(n2, t2);
    if (s2 instanceof Ue && 0 === s2.typeInfo.size) {
      const e3 = s2.typeInfo, t3 = s2.buffer.byteLength / e3.stride;
      return new Oe(t3, this.getTypeInfo("u32"));
    }
    return new Oe(s2.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.abs(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.abs(s2.value), s2.typeInfo);
  }
  Acos(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.acos(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.acos(s2.value), n2.typeInfo);
  }
  Acosh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.acosh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.acosh(s2.value), n2.typeInfo);
  }
  Asin(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.asin(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.asin(s2.value), n2.typeInfo);
  }
  Asinh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.asinh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.asinh(s2.value), n2.typeInfo);
  }
  Atan(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.atan(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.atan(s2.value), n2.typeInfo);
  }
  Atanh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.atanh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.atanh(s2.value), n2.typeInfo);
  }
  Atan2(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => Math.atan2(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Oe(Math.atan2(r2.value, a2.value), n2.typeInfo);
  }
  Ceil(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.ceil(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.ceil(s2.value), n2.typeInfo);
  }
  _clamp(e2, t2, n2) {
    return Math.min(Math.max(e2, t2), n2);
  }
  Clamp(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Fe && s2 instanceof Fe && r2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => this._clamp(e3, s2.data[t3], r2.data[t3])), n2.typeInfo);
    const a2 = n2, i2 = s2, o2 = r2;
    return new Oe(this._clamp(a2.value, i2.value, o2.value), n2.typeInfo);
  }
  Cos(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.cos(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.cos(s2.value), n2.typeInfo);
  }
  Cosh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.cosh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.cos(s2.value), n2.typeInfo);
  }
  CountLeadingZeros(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.clz32(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.clz32(s2.value), n2.typeInfo);
  }
  _countOneBits(e2) {
    let t2 = 0;
    for (; 0 !== e2; ) 1 & e2 && t2++, e2 >>= 1;
    return t2;
  }
  CountOneBits(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => this._countOneBits(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(this._countOneBits(s2.value), n2.typeInfo);
  }
  _countTrailingZeros(e2) {
    if (0 === e2) return 32;
    let t2 = 0;
    for (; !(1 & e2); ) e2 >>= 1, t2++;
    return t2;
  }
  CountTrailingZeros(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => this._countTrailingZeros(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(this._countTrailingZeros(s2.value), n2.typeInfo);
  }
  Cross(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) {
      if (3 !== n2.data.length || 3 !== s2.data.length) return console.error(`Cross() expects 3D vectors. Line ${e2.line}`), null;
      const t3 = n2.data, r2 = s2.data;
      return new Fe([t3[1] * r2[2] - r2[1] * t3[2], t3[2] * r2[0] - r2[2] * t3[0], t3[0] * r2[1] - r2[0] * t3[1]], n2.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${e2.line}`), null;
  }
  Degrees(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = 180 / Math.PI;
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => e3 * s2), n2.typeInfo);
    return new Oe(n2.value * s2, this.getTypeInfo("f32"));
  }
  Determinant(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me) {
      const e3 = n2.data, t3 = n2.typeInfo.getTypeName(), s2 = t3.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if ("mat2x2" === t3 || "mat2x2f" === t3 || "mat2x2h" === t3) return new Oe(e3[0] * e3[3] - e3[1] * e3[2], s2);
      if ("mat2x3" === t3 || "mat2x3f" === t3 || "mat2x3h" === t3) return new Oe(e3[0] * (e3[4] * e3[8] - e3[5] * e3[7]) - e3[1] * (e3[3] * e3[8] - e3[5] * e3[6]) + e3[2] * (e3[3] * e3[7] - e3[4] * e3[6]), s2);
      if ("mat2x4" === t3 || "mat2x4f" === t3 || "mat2x4h" === t3) console.error(`TODO: Determinant for ${t3}`);
      else if ("mat3x2" === t3 || "mat3x2f" === t3 || "mat3x2h" === t3) console.error(`TODO: Determinant for ${t3}`);
      else {
        if ("mat3x3" === t3 || "mat3x3f" === t3 || "mat3x3h" === t3) return new Oe(e3[0] * (e3[4] * e3[8] - e3[5] * e3[7]) - e3[1] * (e3[3] * e3[8] - e3[5] * e3[6]) + e3[2] * (e3[3] * e3[7] - e3[4] * e3[6]), s2);
        "mat3x4" === t3 || "mat3x4f" === t3 || "mat3x4h" === t3 || "mat4x2" === t3 || "mat4x2f" === t3 || "mat4x2h" === t3 || "mat4x3" === t3 || "mat4x3f" === t3 || "mat4x3h" === t3 ? console.error(`TODO: Determinant for ${t3}`) : "mat4x4" !== t3 && "mat4x4f" !== t3 && "mat4x4h" !== t3 || console.error(`TODO: Determinant for ${t3}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${e2.line}`), null;
  }
  Distance(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) {
      let e3 = 0;
      for (let t3 = 0; t3 < n2.data.length; ++t3) e3 += (n2.data[t3] - s2.data[t3]) * (n2.data[t3] - s2.data[t3]);
      return new Oe(Math.sqrt(e3), this.getTypeInfo("f32"));
    }
    const r2 = n2, a2 = s2;
    return new Oe(Math.abs(r2.value - a2.value), n2.typeInfo);
  }
  _dot(e2, t2) {
    let n2 = 0;
    for (let s2 = 0; s2 < e2.length; ++s2) n2 += t2[s2] * e2[s2];
    return n2;
  }
  Dot(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    return n2 instanceof Fe && s2 instanceof Fe ? new Oe(this._dot(n2.data, s2.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e2.line}`), null);
  }
  Dot4U8Packed(e2, t2) {
    return console.error(`TODO: dot4U8Packed. Line ${e2.line}`), null;
  }
  Dot4I8Packed(e2, t2) {
    return console.error(`TODO: dot4I8Packed. Line ${e2.line}`), null;
  }
  Exp(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.exp(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.exp(s2.value), n2.typeInfo);
  }
  Exp2(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.pow(2, e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.pow(2, s2.value), n2.typeInfo);
  }
  ExtractBits(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if ("u32" !== s2.typeInfo.name && "x32" !== s2.typeInfo.name) return console.error(`ExtractBits() expects an i32 offset argument. Line ${e2.line}`), null;
    if ("u32" !== r2.typeInfo.name && "x32" !== r2.typeInfo.name) return console.error(`ExtractBits() expects an i32 count argument. Line ${e2.line}`), null;
    const a2 = s2.value, i2 = r2.value;
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => e3 >> a2 & (1 << i2) - 1), n2.typeInfo);
    if ("i32" !== n2.typeInfo.name && "x32" !== n2.typeInfo.name) return console.error(`ExtractBits() expects an i32 argument. Line ${e2.line}`), null;
    const o2 = n2.value;
    return new Oe(o2 >> a2 & (1 << i2) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Fe && s2 instanceof Fe && r2 instanceof Fe) {
      const e3 = this._dot(s2.data, r2.data);
      return new Fe(e3 < 0 ? Array.from(n2.data) : n2.data.map((e4) => -e4), n2.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${e2.line}`), null;
  }
  _firstLeadingBit(e2) {
    return 0 === e2 ? -1 : 31 - Math.clz32(e2);
  }
  FirstLeadingBit(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => this._firstLeadingBit(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(this._firstLeadingBit(s2.value), n2.typeInfo);
  }
  _firstTrailingBit(e2) {
    return 0 === e2 ? -1 : Math.log2(e2 & -e2);
  }
  FirstTrailingBit(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => this._firstTrailingBit(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(this._firstTrailingBit(s2.value), n2.typeInfo);
  }
  Floor(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.floor(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.floor(s2.value), n2.typeInfo);
  }
  Fma(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Fe && s2 instanceof Fe && r2 instanceof Fe) return n2.data.length !== s2.data.length || n2.data.length !== r2.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e2.line}`), null) : new Fe(n2.data.map((e3, t3) => e3 * s2.data[t3] + r2.data[t3]), n2.typeInfo);
    const a2 = n2, i2 = s2, o2 = r2;
    return new Oe(a2.value * i2.value + o2.value, a2.typeInfo);
  }
  Fract(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => e3 - Math.floor(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(s2.value - Math.floor(s2.value), n2.typeInfo);
  }
  Frexp(e2, t2) {
    return console.error(`TODO: frexp. Line ${e2.line}`), null;
  }
  InsertBits(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2), a2 = this.exec.evalExpression(e2.args[3], t2);
    if ("u32" !== r2.typeInfo.name && "x32" !== r2.typeInfo.name) return console.error(`InsertBits() expects an i32 offset argument. Line ${e2.line}`), null;
    const i2 = r2.value, o2 = (1 << a2.value) - 1 << i2, l2 = ~o2;
    if (n2 instanceof Fe && s2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => e3 & l2 | s2.data[t3] << i2 & o2), n2.typeInfo);
    const c2 = n2.value, u2 = s2.value;
    return new Oe(c2 & l2 | u2 << i2 & o2, n2.typeInfo);
  }
  InverseSqrt(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => 1 / Math.sqrt(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(1 / Math.sqrt(s2.value), n2.typeInfo);
  }
  Ldexp(e2, t2) {
    return console.error(`TODO: ldexp. Line ${e2.line}`), null;
  }
  Length(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) {
      let e3 = 0;
      return n2.data.forEach((t3) => {
        e3 += t3 * t3;
      }), new Oe(Math.sqrt(e3), this.getTypeInfo("f32"));
    }
    const s2 = n2;
    return new Oe(Math.abs(s2.value), n2.typeInfo);
  }
  Log(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.log(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.log(s2.value), n2.typeInfo);
  }
  Log2(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.log2(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.log2(s2.value), n2.typeInfo);
  }
  Max(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => Math.max(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Oe(Math.max(r2.value, a2.value), n2.typeInfo);
  }
  Min(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => Math.min(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Oe(Math.min(r2.value, a2.value), n2.typeInfo);
  }
  Mix(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Fe && s2 instanceof Fe && r2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => n2.data[t3] * (1 - r2.data[t3]) + s2.data[t3] * r2.data[t3]), n2.typeInfo);
    const a2 = s2, i2 = r2;
    return new Oe(n2.value * (1 - i2.value) + a2.value * i2.value, n2.typeInfo);
  }
  Modf(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => e3 % s2.data[t3]), n2.typeInfo);
    const r2 = s2;
    return new Oe(n2.value % r2.value, n2.typeInfo);
  }
  Normalize(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) {
      const s2 = this.Length(e2, t2).value;
      return new Fe(n2.data.map((e3) => e3 / s2), n2.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${e2.line}`), null;
  }
  Pow(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) return new Fe(n2.data.map((e3, t3) => Math.pow(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Oe(Math.pow(r2.value, a2.value), n2.typeInfo);
  }
  QuantizeToF16(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => e3), n2.typeInfo);
    return new Oe(n2.value, n2.typeInfo);
  }
  Radians(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => e3 * Math.PI / 180), n2.typeInfo);
    return new Oe(n2.value * Math.PI / 180, this.getTypeInfo("f32"));
  }
  Reflect(e2, t2) {
    let n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Fe && s2 instanceof Fe) {
      const e3 = this._dot(n2.data, s2.data);
      return new Fe(n2.data.map((t3, n3) => t3 - 2 * e3 * s2.data[n3]), n2.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${e2.line}`), null;
  }
  Refract(e2, t2) {
    let n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Fe && s2 instanceof Fe && r2 instanceof Oe) {
      const e3 = this._dot(s2.data, n2.data);
      return new Fe(n2.data.map((t3, n3) => {
        const a2 = 1 - r2.value * r2.value * (1 - e3 * e3);
        if (a2 < 0) return 0;
        const i2 = Math.sqrt(a2);
        return r2.value * t3 - (r2.value * e3 + i2) * s2.data[n3];
      }), n2.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e2.line}`), null;
  }
  ReverseBits(e2, t2) {
    return console.error(`TODO: reverseBits. Line ${e2.line}`), null;
  }
  Round(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.round(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.round(s2.value), n2.typeInfo);
  }
  Saturate(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.min(Math.max(e3, 0), 1)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.min(Math.max(s2.value, 0), 1), n2.typeInfo);
  }
  Sign(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.sign(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.sign(s2.value), n2.typeInfo);
  }
  Sin(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.sin(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.sin(s2.value), n2.typeInfo);
  }
  Sinh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.sinh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.sinh(s2.value), n2.typeInfo);
  }
  _smoothstep(e2, t2, n2) {
    const s2 = Math.min(Math.max((n2 - e2) / (t2 - e2), 0), 1);
    return s2 * s2 * (3 - 2 * s2);
  }
  SmoothStep(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (r2 instanceof Fe && n2 instanceof Fe && s2 instanceof Fe) return new Fe(r2.data.map((e3, t3) => this._smoothstep(n2.data[t3], s2.data[t3], e3)), r2.typeInfo);
    const a2 = n2, i2 = s2, o2 = r2;
    return new Oe(this._smoothstep(a2.value, i2.value, o2.value), r2.typeInfo);
  }
  Sqrt(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.sqrt(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.sqrt(s2.value), n2.typeInfo);
  }
  Step(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (s2 instanceof Fe && n2 instanceof Fe) return new Fe(s2.data.map((e3, t3) => e3 < n2.data[t3] ? 0 : 1), s2.typeInfo);
    const r2 = n2;
    return new Oe(s2.value < r2.value ? 0 : 1, r2.typeInfo);
  }
  Tan(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.tan(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.tan(s2.value), n2.typeInfo);
  }
  Tanh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.tanh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.tanh(s2.value), n2.typeInfo);
  }
  _getTransposeType(e2) {
    const t2 = e2.getTypeName();
    return "mat2x2f" === t2 || "mat2x2h" === t2 ? e2 : "mat2x3f" === t2 ? this.getTypeInfo("mat3x2f") : "mat2x3h" === t2 ? this.getTypeInfo("mat3x2h") : "mat2x4f" === t2 ? this.getTypeInfo("mat4x2f") : "mat2x4h" === t2 ? this.getTypeInfo("mat4x2h") : "mat3x2f" === t2 ? this.getTypeInfo("mat2x3f") : "mat3x2h" === t2 ? this.getTypeInfo("mat2x3h") : "mat3x3f" === t2 || "mat3x3h" === t2 ? e2 : "mat3x4f" === t2 ? this.getTypeInfo("mat4x3f") : "mat3x4h" === t2 ? this.getTypeInfo("mat4x3h") : "mat4x2f" === t2 ? this.getTypeInfo("mat2x4f") : "mat4x2h" === t2 ? this.getTypeInfo("mat2x4h") : "mat4x3f" === t2 ? this.getTypeInfo("mat3x4f") : "mat4x3h" === t2 ? this.getTypeInfo("mat3x4h") : ("mat4x4f" === t2 || "mat4x4h" === t2 || console.error(`Invalid matrix type ${t2}`), e2);
  }
  Transpose(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (!(n2 instanceof Me)) return console.error(`Transpose() expects a matrix argument. Line ${e2.line}`), null;
    const s2 = this._getTransposeType(n2.typeInfo);
    if ("mat2x2" === n2.typeInfo.name || "mat2x2f" === n2.typeInfo.name || "mat2x2h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[2], e3[1], e3[3]], s2);
    }
    if ("mat2x3" === n2.typeInfo.name || "mat2x3f" === n2.typeInfo.name || "mat2x3h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[3], e3[6], e3[1], e3[4], e3[7]], s2);
    }
    if ("mat2x4" === n2.typeInfo.name || "mat2x4f" === n2.typeInfo.name || "mat2x4h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[4], e3[8], e3[12], e3[1], e3[5], e3[9], e3[13]], s2);
    }
    if ("mat3x2" === n2.typeInfo.name || "mat3x2f" === n2.typeInfo.name || "mat3x2h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[3], e3[1], e3[4], e3[2], e3[5]], s2);
    }
    if ("mat3x3" === n2.typeInfo.name || "mat3x3f" === n2.typeInfo.name || "mat3x3h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[3], e3[6], e3[1], e3[4], e3[7], e3[2], e3[5], e3[8]], s2);
    }
    if ("mat3x4" === n2.typeInfo.name || "mat3x4f" === n2.typeInfo.name || "mat3x4h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[4], e3[8], e3[12], e3[1], e3[5], e3[9], e3[13], e3[2], e3[6], e3[10], e3[14]], s2);
    }
    if ("mat4x2" === n2.typeInfo.name || "mat4x2f" === n2.typeInfo.name || "mat4x2h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[4], e3[1], e3[5], e3[2], e3[6]], s2);
    }
    if ("mat4x3" === n2.typeInfo.name || "mat4x3f" === n2.typeInfo.name || "mat4x3h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[4], e3[8], e3[1], e3[5], e3[9], e3[2], e3[6], e3[10]], s2);
    }
    if ("mat4x4" === n2.typeInfo.name || "mat4x4f" === n2.typeInfo.name || "mat4x4h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Me([e3[0], e3[4], e3[8], e3[12], e3[1], e3[5], e3[9], e3[13], e3[2], e3[6], e3[10], e3[14], e3[3], e3[7], e3[11], e3[15]], s2);
    }
    return console.error(`Invalid matrix type ${n2.typeInfo.name}`), null;
  }
  Trunc(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Fe) return new Fe(n2.data.map((e3) => Math.trunc(e3)), n2.typeInfo);
    const s2 = n2;
    return new Oe(Math.trunc(s2.value), n2.typeInfo);
  }
  Dpdx(e2, t2) {
    return console.error(`TODO: dpdx. Line ${e2.line}`), null;
  }
  DpdxCoarse(e2, t2) {
    return console.error(`TODO: dpdxCoarse. Line ${e2.line}`), null;
  }
  DpdxFine(e2, t2) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(e2, t2) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(e2, t2) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(e2, t2) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(e2, t2) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(e2, t2) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(e2, t2) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(e2, t2) {
    const n2 = e2.args[0], s2 = e2.args.length > 1 ? this.exec.evalExpression(e2.args[1], t2).value : 0;
    if (n2 instanceof me) {
      const r2 = n2.name, a2 = t2.getVariableValue(r2);
      if (a2 instanceof Pe) {
        if (s2 < 0 || s2 >= a2.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e2.line}`), null;
        const t3 = a2.getMipLevelSize(s2), n3 = a2.dimension;
        return "1d" === n3 ? new Oe(t3[0], this.getTypeInfo("u32")) : "3d" === n3 ? new Fe(t3, this.getTypeInfo("vec3u")) : "2d" === n3 ? new Fe(t3.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${n3} not found. Line ${e2.line}`), null);
      }
      return console.error(`Texture ${r2} not found. Line ${e2.line}`), null;
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${e2.line}`), null;
  }
  TextureGather(e2, t2) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(e2, t2) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(e2, t2) {
    const n2 = e2.args[0], s2 = this.exec.evalExpression(e2.args[1], t2), r2 = e2.args.length > 2 ? this.exec.evalExpression(e2.args[2], t2).value : 0;
    if (!(s2 instanceof Fe) || 2 !== s2.data.length) return console.error(`Invalid UV argument for textureLoad. Line ${e2.line}`), null;
    if (n2 instanceof me) {
      const a2 = n2.name, i2 = t2.getVariableValue(a2);
      if (i2 instanceof Pe) {
        const t3 = Math.floor(s2.data[0]), n3 = Math.floor(s2.data[1]);
        if (t3 < 0 || t3 >= i2.width || n3 < 0 || n3 >= i2.height) return console.error(`Texture ${a2} out of bounds. Line ${e2.line}`), null;
        const o2 = i2.getPixel(t3, n3, 0, r2);
        return null === o2 ? (console.error(`Invalid texture format for textureLoad. Line ${e2.line}`), null) : new Fe(o2, this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${a2} not found. Line ${e2.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${e2.line}`), null;
  }
  TextureNumLayers(e2, t2) {
    const n2 = e2.args[0];
    if (n2 instanceof me) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof Pe ? new Oe(r2.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e2.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLayers. Line ${e2.line}`), null;
  }
  TextureNumLevels(e2, t2) {
    const n2 = e2.args[0];
    if (n2 instanceof me) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof Pe ? new Oe(r2.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e2.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLevels. Line ${e2.line}`), null;
  }
  TextureNumSamples(e2, t2) {
    const n2 = e2.args[0];
    if (n2 instanceof me) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof Pe ? new Oe(r2.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e2.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumSamples. Line ${e2.line}`), null;
  }
  TextureSample(e2, t2) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(e2, t2) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(e2, t2) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(e2, t2) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(e2, t2) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(e2, t2) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(e2, t2) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(e2, t2) {
    const n2 = e2.args[0], s2 = this.exec.evalExpression(e2.args[1], t2), r2 = 4 === e2.args.length ? this.exec.evalExpression(e2.args[2], t2).value : 0, a2 = 4 === e2.args.length ? this.exec.evalExpression(e2.args[3], t2).data : this.exec.evalExpression(e2.args[2], t2).data;
    if (4 !== a2.length) return console.error(`Invalid value argument for textureStore. Line ${e2.line}`), null;
    if (!(s2 instanceof Fe) || 2 !== s2.data.length) return console.error(`Invalid UV argument for textureStore. Line ${e2.line}`), null;
    if (n2 instanceof me) {
      const i2 = n2.name, o2 = t2.getVariableValue(i2);
      if (o2 instanceof Pe) {
        const t3 = o2.getMipLevelSize(0), n3 = Math.floor(s2.data[0]), l2 = Math.floor(s2.data[1]);
        return n3 < 0 || n3 >= t3[0] || l2 < 0 || l2 >= t3[1] ? (console.error(`Texture ${i2} out of bounds. Line ${e2.line}`), null) : (o2.setPixel(n3, l2, 0, r2, Array.from(a2)), null);
      }
      return console.error(`Texture ${i2} not found. Line ${e2.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${e2.line}`), null;
  }
  AtomicLoad(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2);
    return t2.getVariable(s2).value.getSubData(this.exec, n2.postfix, t2);
  }
  AtomicStore(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value = i2.value), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), null;
  }
  AtomicAdd(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value += i2.value), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicSub(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value -= i2.value), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicMax(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value = Math.max(o2.value, i2.value)), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicMin(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value = Math.min(o2.value, i2.value)), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicAnd(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value = o2.value & i2.value), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicOr(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value = o2.value | i2.value), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicXor(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value = o2.value ^ i2.value), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicExchange(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof we && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i2 = this.exec.evalExpression(a2, t2), o2 = r2.value.getSubData(this.exec, n2.postfix, t2), l2 = new Oe(o2.value, o2.typeInfo);
    return o2 instanceof Oe && i2 instanceof Oe && (o2.value = i2.value), r2.value instanceof Ue && r2.value.setDataValue(this.exec, o2, n2.postfix, t2), l2;
  }
  AtomicCompareExchangeWeak(e2, t2) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(e2, t2) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(e2, t2) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(e2, t2) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(e2, t2) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(e2, t2) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(e2, t2) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(e2, t2) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(e2, t2) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(e2, t2) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(e2, t2) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(e2, t2) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(e2, t2) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(e2, t2) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(e2, t2) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(e2, t2) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(e2, t2) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(e2, t2) {
    return null;
  }
  TextureBarrier(e2, t2) {
    return null;
  }
  WorkgroupBarrier(e2, t2) {
    return null;
  }
  WorkgroupUniformLoad(e2, t2) {
    return null;
  }
  SubgroupAdd(e2, t2) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(e2, t2) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(e2, t2) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(e2, t2) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(e2, t2) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(e2, t2) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(e2, t2) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(e2, t2) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(e2, t2) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(e2, t2) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(e2, t2) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(e2, t2) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(e2, t2) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(e2, t2) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(e2, t2) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(e2, t2) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(e2, t2) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(e2, t2) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(e2, t2) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(e2, t2) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(e2, t2) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(e2, t2) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(e2, t2) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(e2, t2) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(e2, t2) {
    return console.error("TODO: quadSwapY"), null;
  }
};
var ht = { vec2: 2, vec2f: 2, vec2i: 2, vec2u: 2, vec2b: 2, vec2h: 2, vec3: 3, vec3f: 3, vec3i: 3, vec3u: 3, vec3b: 3, vec3h: 3, vec4: 4, vec4f: 4, vec4i: 4, vec4u: 4, vec4b: 4, vec4h: 4 };
var ft = { mat2x2: [2, 2, 4], mat2x2f: [2, 2, 4], mat2x2h: [2, 2, 4], mat2x3: [2, 3, 6], mat2x3f: [2, 3, 6], mat2x3h: [2, 3, 6], mat2x4: [2, 4, 8], mat2x4f: [2, 4, 8], mat2x4h: [2, 4, 8], mat3x2: [3, 2, 6], mat3x2f: [3, 2, 6], mat3x2h: [3, 2, 6], mat3x3: [3, 3, 9], mat3x3f: [3, 3, 9], mat3x3h: [3, 3, 9], mat3x4: [3, 4, 12], mat3x4f: [3, 4, 12], mat3x4h: [3, 4, 12], mat4x2: [4, 2, 8], mat4x2f: [4, 2, 8], mat4x2h: [4, 2, 8], mat4x3: [4, 3, 12], mat4x3f: [4, 3, 12], mat4x3h: [4, 3, 12], mat4x4: [4, 4, 16], mat4x4f: [4, 4, 16], mat4x4h: [4, 4, 16] };
var pt = class _pt extends ct {
  constructor(e2, t2) {
    var n2;
    super(), this.ast = null != e2 ? e2 : [], this.reflection = new rt(), this.reflection.updateAST(this.ast), this.context = null !== (n2 = null == t2 ? void 0 : t2.clone()) && void 0 !== n2 ? n2 : new lt(), this.builtins = new ut(this), this.typeInfo = { bool: this.getTypeInfo(re.bool), i32: this.getTypeInfo(re.i32), u32: this.getTypeInfo(re.u32), f32: this.getTypeInfo(re.f32), f16: this.getTypeInfo(re.f16), vec2f: this.getTypeInfo(oe.vec2f), vec2u: this.getTypeInfo(oe.vec2u), vec2i: this.getTypeInfo(oe.vec2i), vec2h: this.getTypeInfo(oe.vec2h), vec3f: this.getTypeInfo(oe.vec3f), vec3u: this.getTypeInfo(oe.vec3u), vec3i: this.getTypeInfo(oe.vec3i), vec3h: this.getTypeInfo(oe.vec3h), vec4f: this.getTypeInfo(oe.vec4f), vec4u: this.getTypeInfo(oe.vec4u), vec4i: this.getTypeInfo(oe.vec4i), vec4h: this.getTypeInfo(oe.vec4h), mat2x2f: this.getTypeInfo(oe.mat2x2f), mat2x3f: this.getTypeInfo(oe.mat2x3f), mat2x4f: this.getTypeInfo(oe.mat2x4f), mat3x2f: this.getTypeInfo(oe.mat3x2f), mat3x3f: this.getTypeInfo(oe.mat3x3f), mat3x4f: this.getTypeInfo(oe.mat3x4f), mat4x2f: this.getTypeInfo(oe.mat4x2f), mat4x3f: this.getTypeInfo(oe.mat4x3f), mat4x4f: this.getTypeInfo(oe.mat4x4f) };
  }
  getVariableValue(e2) {
    var t2, n2;
    const r2 = null !== (n2 = null === (t2 = this.context.getVariable(e2)) || void 0 === t2 ? void 0 : t2.value) && void 0 !== n2 ? n2 : null;
    if (null === r2) return null;
    if (r2 instanceof Oe) return r2.value;
    if (r2 instanceof Fe) return Array.from(r2.data);
    if (r2 instanceof Me) return Array.from(r2.data);
    if (r2 instanceof Ue && r2.typeInfo instanceof s) {
      if ("u32" === r2.typeInfo.format.name) return Array.from(new Uint32Array(r2.buffer, r2.offset, r2.typeInfo.count));
      if ("i32" === r2.typeInfo.format.name) return Array.from(new Int32Array(r2.buffer, r2.offset, r2.typeInfo.count));
      if ("f32" === r2.typeInfo.format.name) return Array.from(new Float32Array(r2.buffer, r2.offset, r2.typeInfo.count));
    }
    return console.error(`Unsupported return variable type ${r2.typeInfo.name}`), null;
  }
  execute(e2) {
    (e2 = null != e2 ? e2 : {}).constants && this._setOverrides(e2.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(e2, t2, n2, s2) {
    const r2 = this.context.clone();
    (s2 = null != s2 ? s2 : {}).constants && this._setOverrides(s2.constants, r2), this._execStatements(this.ast, r2);
    const a2 = r2.getFunction(e2);
    if (!a2) return void console.error(`Function ${e2} not found`);
    if ("number" == typeof t2) t2 = [t2, 1, 1];
    else {
      if (0 === t2.length) return void console.error("Invalid dispatch count");
      1 === t2.length ? t2 = [t2[0], 1, 1] : 2 === t2.length ? t2 = [t2[0], t2[1], 1] : t2.length > 3 && (t2 = [t2[0], t2[1], t2[2]]);
    }
    const i2 = t2[0], o2 = t2[1], l2 = t2[2], c2 = this.getTypeInfo("vec3u");
    r2.setVariable("@num_workgroups", new Fe(t2, c2));
    for (const e3 in n2) for (const t3 in n2[e3]) {
      const s3 = n2[e3][t3];
      r2.variables.forEach((n3) => {
        var r3;
        const a3 = n3.node;
        if (null == a3 ? void 0 : a3.attributes) {
          let i3 = null, o3 = null;
          for (const e4 of a3.attributes) "binding" === e4.name ? i3 = e4.value : "group" === e4.name && (o3 = e4.value);
          if (t3 == i3 && e3 == o3) if (void 0 !== s3.texture && void 0 !== s3.descriptor) {
            const e4 = new Pe(s3.texture, this.getTypeInfo(a3.type), s3.descriptor, null !== (r3 = s3.texture.view) && void 0 !== r3 ? r3 : null);
            n3.value = e4;
          } else void 0 !== s3.uniform ? n3.value = new Ue(s3.uniform, this.getTypeInfo(a3.type)) : n3.value = new Ue(s3, this.getTypeInfo(a3.type));
        }
      });
    }
    for (let e3 = 0; e3 < l2; ++e3) for (let t3 = 0; t3 < o2; ++t3) for (let n3 = 0; n3 < i2; ++n3) r2.setVariable("@workgroup_id", new Fe([n3, t3, e3], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(a2, [n3, t3, e3], r2);
  }
  execStatement(e2, t2) {
    if (e2 instanceof Q) return this.evalExpression(e2.value, t2);
    if (e2 instanceof ne) {
      if (e2.condition) {
        const n2 = this.evalExpression(e2.condition, t2);
        if (!(n2 instanceof Oe)) throw new Error("Invalid break-if condition");
        if (!n2.value) return null;
      }
      return _pt._breakObj;
    }
    if (e2 instanceof se) return _pt._continueObj;
    if (e2 instanceof M) this._let(e2, t2);
    else if (e2 instanceof B) this._var(e2, t2);
    else if (e2 instanceof U) this._const(e2, t2);
    else if (e2 instanceof C) this._function(e2, t2);
    else {
      if (e2 instanceof Z) return this._if(e2, t2);
      if (e2 instanceof j) return this._switch(e2, t2);
      if (e2 instanceof O) return this._for(e2, t2);
      if (e2 instanceof N) return this._while(e2, t2);
      if (e2 instanceof X) return this._loop(e2, t2);
      if (e2 instanceof V) {
        const n2 = t2.clone();
        return n2.currentFunctionName = t2.currentFunctionName, this._execStatements(e2.body, n2);
      }
      if (e2 instanceof R) this._assign(e2, t2);
      else if (e2 instanceof z) this._increment(e2, t2);
      else {
        if (e2 instanceof ie) return null;
        if (e2 instanceof F) {
          const n2 = e2.name;
          null === t2.getVariable(n2) && t2.setVariable(n2, new Oe(0, this.getTypeInfo("u32")));
        } else if (e2 instanceof G) this._call(e2, t2);
        else {
          if (e2 instanceof J) return null;
          if (e2 instanceof ee) return null;
          console.error("Invalid statement type.", e2, `Line ${e2.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(e2, t2) {
    return e2 instanceof ke ? this._evalBinaryOp(e2, t2) : e2 instanceof ge ? this._evalLiteral(e2, t2) : e2 instanceof me ? this._evalVariable(e2, t2) : e2 instanceof de ? this._evalCall(e2, t2) : e2 instanceof pe ? this._evalCreate(e2, t2) : e2 instanceof _e ? this._evalConst(e2, t2) : e2 instanceof xe ? this._evalBitcast(e2, t2) : e2 instanceof we ? this._evalUnaryOp(e2, t2) : (console.error("Invalid expression type", e2, `Line ${e2.line}`), null);
  }
  getTypeInfo(e2) {
    var t2;
    if (e2 instanceof re) {
      const t3 = this.reflection.getTypeInfo(e2);
      if (null !== t3) return t3;
    }
    let n2 = null !== (t2 = this.typeInfo[e2]) && void 0 !== t2 ? t2 : null;
    return null !== n2 || (n2 = this.reflection.getTypeInfoByName(e2)), n2;
  }
  _setOverrides(e2, t2) {
    for (const n2 in e2) {
      const s2 = e2[n2], r2 = this.reflection.getOverrideInfo(n2);
      null !== r2 ? (null === r2.type && (r2.type = this.getTypeInfo("u32")), "u32" === r2.type.name || "i32" === r2.type.name || "f32" === r2.type.name || "f16" === r2.type.name ? t2.setVariable(n2, new Oe(s2, r2.type)) : "bool" === r2.type.name ? t2.setVariable(n2, new Oe(s2 ? 1 : 0, r2.type)) : "vec2" === r2.type.name || "vec3" === r2.type.name || "vec4" === r2.type.name || "vec2f" === r2.type.name || "vec3f" === r2.type.name || "vec4f" === r2.type.name || "vec2i" === r2.type.name || "vec3i" === r2.type.name || "vec4i" === r2.type.name || "vec2u" === r2.type.name || "vec3u" === r2.type.name || "vec4u" === r2.type.name || "vec2h" === r2.type.name || "vec3h" === r2.type.name || "vec4h" === r2.type.name ? t2.setVariable(n2, new Fe(s2, r2.type)) : console.error(`Invalid constant type for ${n2}`)) : console.error(`Override ${n2} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(e2, t2, n2) {
    const s2 = [1, 1, 1];
    for (const t3 of e2.node.attributes) if ("workgroup_size" === t3.name) {
      if (t3.value.length > 0) {
        const e3 = n2.getVariableValue(t3.value[0]);
        s2[0] = e3 instanceof Oe ? e3.value : parseInt(t3.value[0]);
      }
      if (t3.value.length > 1) {
        const e3 = n2.getVariableValue(t3.value[1]);
        s2[1] = e3 instanceof Oe ? e3.value : parseInt(t3.value[1]);
      }
      if (t3.value.length > 2) {
        const e3 = n2.getVariableValue(t3.value[2]);
        s2[2] = e3 instanceof Oe ? e3.value : parseInt(t3.value[2]);
      }
    }
    const r2 = this.getTypeInfo("vec3u"), a2 = this.getTypeInfo("u32");
    n2.setVariable("@workgroup_size", new Fe(s2, r2));
    const i2 = s2[0], o2 = s2[1], l2 = s2[2];
    for (let c2 = 0, u2 = 0; c2 < l2; ++c2) for (let l3 = 0; l3 < o2; ++l3) for (let o3 = 0; o3 < i2; ++o3, ++u2) {
      const i3 = [o3, l3, c2], h2 = [o3 + t2[0] * s2[0], l3 + t2[1] * s2[1], c2 + t2[2] * s2[2]];
      n2.setVariable("@local_invocation_id", new Fe(i3, r2)), n2.setVariable("@global_invocation_id", new Fe(h2, r2)), n2.setVariable("@local_invocation_index", new Oe(u2, a2)), this._dispatchExec(e2, n2);
    }
  }
  _dispatchExec(e2, t2) {
    for (const n2 of e2.node.args) for (const e3 of n2.attributes) if ("builtin" === e3.name) {
      const s2 = `@${e3.value}`, r2 = t2.getVariable(s2);
      void 0 !== r2 && t2.variables.set(n2.name, r2);
    }
    this._execStatements(e2.node.body, t2);
  }
  getVariableName(e2, t2) {
    for (; e2 instanceof we; ) e2 = e2.right;
    return e2 instanceof me ? e2.name : (console.error("Unknown variable type", e2, "Line", e2.line), null);
  }
  _execStatements(e2, t2) {
    for (const n2 of e2) {
      if (n2 instanceof Array) {
        const e4 = t2.clone(), s2 = this._execStatements(n2, e4);
        if (s2) return s2;
        continue;
      }
      const e3 = this.execStatement(n2, t2);
      if (e3) return e3;
    }
    return null;
  }
  _call(e2, t2) {
    const n2 = t2.clone();
    n2.currentFunctionName = e2.name;
    const s2 = t2.getFunction(e2.name);
    if (s2) {
      for (let t3 = 0; t3 < s2.node.args.length; ++t3) {
        const r2 = s2.node.args[t3], a2 = this.evalExpression(e2.args[t3], n2);
        n2.setVariable(r2.name, a2, r2);
      }
      this._execStatements(s2.node.body, n2);
    } else if (e2.isBuiltin) this._callBuiltinFunction(e2, n2);
    else {
      this.getTypeInfo(e2.name) && this._evalCreate(e2, t2);
    }
  }
  _increment(e2, t2) {
    const n2 = this.getVariableName(e2.variable, t2), s2 = t2.getVariable(n2);
    s2 ? "++" === e2.operator ? s2.value instanceof Oe ? s2.value.value++ : console.error(`Variable ${n2} is not a scalar. Line ${e2.line}`) : "--" === e2.operator ? s2.value instanceof Oe ? s2.value.value-- : console.error(`Variable ${n2} is not a scalar. Line ${e2.line}`) : console.error(`Unknown increment operator ${e2.operator}. Line ${e2.line}`) : console.error(`Variable ${n2} not found. Line ${e2.line}`);
  }
  _getVariableData(e2, t2) {
    if (e2 instanceof me) {
      const n2 = this.getVariableName(e2, t2), s2 = t2.getVariable(n2);
      return null === s2 ? (console.error(`Variable ${n2} not found. Line ${e2.line}`), null) : s2.value.getSubData(this, e2.postfix, t2);
    }
    if (e2 instanceof we) {
      if ("*" === e2.operator) {
        const n2 = this._getVariableData(e2.right, t2);
        return n2 instanceof Ve ? n2.reference.getSubData(this, e2.postfix, t2) : (console.error(`Variable ${e2.right} is not a pointer. Line ${e2.line}`), null);
      }
      if ("&" === e2.operator) {
        const n2 = this._getVariableData(e2.right, t2);
        return new Ve(n2);
      }
    }
    return null;
  }
  _assign(e2, t2) {
    let n2 = null, s2 = "<var>", r2 = null;
    if (e2.variable instanceof we) {
      const n3 = this._getVariableData(e2.variable, t2), s3 = this.evalExpression(e2.value, t2), r3 = e2.operator;
      if ("=" === r3) {
        if (n3 instanceof Oe || n3 instanceof Fe || n3 instanceof Me) {
          if (s3 instanceof Oe || s3 instanceof Fe || s3 instanceof Me && n3.data.length === s3.data.length) return void n3.data.set(s3.data);
          console.error(`Invalid assignment. Line ${e2.line}`);
        } else if (n3 instanceof Ue && s3 instanceof Ue && n3.buffer.byteLength - n3.offset >= s3.buffer.byteLength - s3.offset) return void (n3.buffer.byteLength % 4 == 0 ? new Uint32Array(n3.buffer, n3.offset, n3.typeInfo.size / 4).set(new Uint32Array(s3.buffer, s3.offset, s3.typeInfo.size / 4)) : new Uint8Array(n3.buffer, n3.offset, n3.typeInfo.size).set(new Uint8Array(s3.buffer, s3.offset, s3.typeInfo.size)));
        return console.error(`Invalid assignment. Line ${e2.line}`), null;
      }
      if ("+=" === r3) return n3 instanceof Oe || n3 instanceof Fe || n3 instanceof Me ? s3 instanceof Oe || s3 instanceof Fe || s3 instanceof Me ? void n3.data.set(s3.data.map((e3, t3) => n3.data[t3] + e3)) : void console.error(`Invalid assignment . Line ${e2.line}`) : void console.error(`Invalid assignment. Line ${e2.line}`);
      if ("-=" === r3) return (n3 instanceof Oe || n3 instanceof Fe || n3 instanceof Me) && (s3 instanceof Oe || s3 instanceof Fe || s3 instanceof Me) ? void n3.data.set(s3.data.map((e3, t3) => n3.data[t3] - e3)) : void console.error(`Invalid assignment. Line ${e2.line}`);
    }
    if (e2.variable instanceof we) {
      if ("*" === e2.variable.operator) {
        s2 = this.getVariableName(e2.variable.right, t2);
        const r3 = t2.getVariable(s2);
        if (!(r3 && r3.value instanceof Ve)) return void console.error(`Variable ${s2} is not a pointer. Line ${e2.line}`);
        n2 = r3.value.reference;
        let a3 = e2.variable.postfix;
        if (!a3) {
          let t3 = e2.variable.right;
          for (; t3 instanceof we; ) {
            if (t3.postfix) {
              a3 = t3.postfix;
              break;
            }
            t3 = t3.right;
          }
        }
        a3 && (n2 = n2.getSubData(this, a3, t2));
      }
    } else {
      r2 = e2.variable.postfix, s2 = this.getVariableName(e2.variable, t2);
      const a3 = t2.getVariable(s2);
      if (null === a3) return void console.error(`Variable ${s2} not found. Line ${e2.line}`);
      n2 = a3.value;
    }
    if (n2 instanceof Ve && (n2 = n2.reference), null === n2) return void console.error(`Variable ${s2} not found. Line ${e2.line}`);
    const a2 = this.evalExpression(e2.value, t2), i2 = e2.operator;
    if ("=" === i2) if (n2 instanceof Ue) n2.setDataValue(this, a2, r2, t2);
    else if (r2) {
      if (!(n2 instanceof Fe || n2 instanceof Me)) return void console.error(`Variable ${s2} is not a vector or matrix. Line ${e2.line}`);
      if (r2 instanceof be) {
        const i3 = this.evalExpression(r2.index, t2).value;
        if (n2 instanceof Fe) {
          if (!(a2 instanceof Oe)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
          n2.data[i3] = a2.value;
        } else {
          if (!(n2 instanceof Me)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
          {
            const i4 = this.evalExpression(r2.index, t2).value;
            if (i4 < 0) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
            if (!(a2 instanceof Fe)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
            {
              const t3 = n2.typeInfo.getTypeName();
              if ("mat2x2" === t3 || "mat2x2f" === t3 || "mat2x2h" === t3) {
                if (!(i4 < 2 && 2 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[2 * i4] = a2.data[0], n2.data[2 * i4 + 1] = a2.data[1];
              } else if ("mat2x3" === t3 || "mat2x3f" === t3 || "mat2x3h" === t3) {
                if (!(i4 < 2 && 3 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[3 * i4] = a2.data[0], n2.data[3 * i4 + 1] = a2.data[1], n2.data[3 * i4 + 2] = a2.data[2];
              } else if ("mat2x4" === t3 || "mat2x4f" === t3 || "mat2x4h" === t3) {
                if (!(i4 < 2 && 4 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[4 * i4] = a2.data[0], n2.data[4 * i4 + 1] = a2.data[1], n2.data[4 * i4 + 2] = a2.data[2], n2.data[4 * i4 + 3] = a2.data[3];
              } else if ("mat3x2" === t3 || "mat3x2f" === t3 || "mat3x2h" === t3) {
                if (!(i4 < 3 && 2 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[2 * i4] = a2.data[0], n2.data[2 * i4 + 1] = a2.data[1];
              } else if ("mat3x3" === t3 || "mat3x3f" === t3 || "mat3x3h" === t3) {
                if (!(i4 < 3 && 3 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[3 * i4] = a2.data[0], n2.data[3 * i4 + 1] = a2.data[1], n2.data[3 * i4 + 2] = a2.data[2];
              } else if ("mat3x4" === t3 || "mat3x4f" === t3 || "mat3x4h" === t3) {
                if (!(i4 < 3 && 4 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[4 * i4] = a2.data[0], n2.data[4 * i4 + 1] = a2.data[1], n2.data[4 * i4 + 2] = a2.data[2], n2.data[4 * i4 + 3] = a2.data[3];
              } else if ("mat4x2" === t3 || "mat4x2f" === t3 || "mat4x2h" === t3) {
                if (!(i4 < 4 && 2 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[2 * i4] = a2.data[0], n2.data[2 * i4 + 1] = a2.data[1];
              } else if ("mat4x3" === t3 || "mat4x3f" === t3 || "mat4x3h" === t3) {
                if (!(i4 < 4 && 3 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[3 * i4] = a2.data[0], n2.data[3 * i4 + 1] = a2.data[1], n2.data[3 * i4 + 2] = a2.data[2];
              } else {
                if ("mat4x4" !== t3 && "mat4x4f" !== t3 && "mat4x4h" !== t3) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                if (!(i4 < 4 && 4 === a2.data.length)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[4 * i4] = a2.data[0], n2.data[4 * i4 + 1] = a2.data[1], n2.data[4 * i4 + 2] = a2.data[2], n2.data[4 * i4 + 3] = a2.data[3];
              }
            }
          }
        }
      } else if (r2 instanceof fe) {
        const t3 = r2.value;
        if (!(n2 instanceof Fe)) return void console.error(`Invalid assignment to ${t3}. Variable ${s2} is not a vector. Line ${e2.line}`);
        if (a2 instanceof Oe) {
          if (t3.length > 1) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
          if ("x" === t3) n2.data[0] = a2.value;
          else if ("y" === t3) {
            if (n2.data.length < 2) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
            n2.data[1] = a2.value;
          } else if ("z" === t3) {
            if (n2.data.length < 3) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
            n2.data[2] = a2.value;
          } else if ("w" === t3) {
            if (n2.data.length < 4) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
            n2.data[3] = a2.value;
          }
        } else {
          if (!(a2 instanceof Fe)) return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
          if (t3.length !== a2.data.length) return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
          for (let r3 = 0; r3 < t3.length; ++r3) {
            const i3 = t3[r3];
            if ("x" === i3 || "r" === i3) n2.data[0] = a2.data[r3];
            else if ("y" === i3 || "g" === i3) {
              if (a2.data.length < 2) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e2.line}`);
              n2.data[1] = a2.data[r3];
            } else if ("z" === i3 || "b" === i3) {
              if (a2.data.length < 3) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e2.line}`);
              n2.data[2] = a2.data[r3];
            } else {
              if ("w" !== i3 && "a" !== i3) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e2.line}`);
              if (a2.data.length < 4) return void console.error(`Invalid assignment to ${i3} for variable ${s2}. Line ${e2.line}`);
              n2.data[3] = a2.data[r3];
            }
          }
        }
      }
    } else n2 instanceof Oe && a2 instanceof Oe ? n2.value = a2.value : n2 instanceof Fe && a2 instanceof Fe || n2 instanceof Me && a2 instanceof Me ? n2.data.set(a2.data) : console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
    else {
      const s3 = n2.getSubData(this, r2, t2);
      if (s3 instanceof Fe && a2 instanceof Oe) {
        const t3 = s3.data, n3 = a2.value;
        if ("+=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] += n3;
        else if ("-=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] -= n3;
        else if ("*=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] *= n3;
        else if ("/=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] /= n3;
        else if ("%=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] %= n3;
        else if ("&=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] &= n3;
        else if ("|=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] |= n3;
        else if ("^=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] ^= n3;
        else if ("<<=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] <<= n3;
        else if (">>=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] >>= n3;
        else console.error(`Invalid operator ${i2}. Line ${e2.line}`);
      } else if (s3 instanceof Fe && a2 instanceof Fe) {
        const t3 = s3.data, n3 = a2.data;
        if (t3.length !== n3.length) return void console.error(`Vector length mismatch. Line ${e2.line}`);
        if ("+=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] += n3[e3];
        else if ("-=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] -= n3[e3];
        else if ("*=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] *= n3[e3];
        else if ("/=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] /= n3[e3];
        else if ("%=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] %= n3[e3];
        else if ("&=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] &= n3[e3];
        else if ("|=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] |= n3[e3];
        else if ("^=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] ^= n3[e3];
        else if ("<<=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] <<= n3[e3];
        else if (">>=" === i2) for (let e3 = 0; e3 < t3.length; ++e3) t3[e3] >>= n3[e3];
        else console.error(`Invalid operator ${i2}. Line ${e2.line}`);
      } else {
        if (!(s3 instanceof Oe && a2 instanceof Oe)) return void console.error(`Invalid type for ${e2.operator} operator. Line ${e2.line}`);
        "+=" === i2 ? s3.value += a2.value : "-=" === i2 ? s3.value -= a2.value : "*=" === i2 ? s3.value *= a2.value : "/=" === i2 ? s3.value /= a2.value : "%=" === i2 ? s3.value %= a2.value : "&=" === i2 ? s3.value &= a2.value : "|=" === i2 ? s3.value |= a2.value : "^=" === i2 ? s3.value ^= a2.value : "<<=" === i2 ? s3.value <<= a2.value : ">>=" === i2 ? s3.value >>= a2.value : console.error(`Invalid operator ${i2}. Line ${e2.line}`);
      }
      n2 instanceof Ue && n2.setDataValue(this, s3, r2, t2);
    }
  }
  _function(e2, t2) {
    const n2 = new ot(e2);
    t2.functions.set(e2.name, n2);
  }
  _const(e2, t2) {
    let n2 = null;
    null !== e2.value && (n2 = this.evalExpression(e2.value, t2)), t2.createVariable(e2.name, n2, e2);
  }
  _let(e2, t2) {
    let n2 = null;
    if (null !== e2.value) {
      if (n2 = this.evalExpression(e2.value, t2), null === n2) return void console.error(`Invalid value for variable ${e2.name}. Line ${e2.line}`);
      e2.value instanceof we || (n2 = n2.clone());
    } else {
      const s2 = e2.type.name;
      if ("f32" === s2 || "i32" === s2 || "u32" === s2 || "bool" === s2 || "f16" === s2 || "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2b" === s2 || "vec3b" === s2 || "vec4b" === s2 || "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 || "array" === s2) {
        const s3 = new pe(e2.type, []);
        n2 = this._evalCreate(s3, t2);
      }
    }
    t2.createVariable(e2.name, n2, e2);
  }
  _var(e2, t2) {
    let n2 = null;
    if (null !== e2.value) {
      if (n2 = this.evalExpression(e2.value, t2), null === n2) return void console.error(`Invalid value for variable ${e2.name}. Line ${e2.line}`);
      e2.value instanceof we || (n2 = n2.clone());
    } else {
      if (null === e2.type) return void console.error(`Variable ${e2.name} has no type. Line ${e2.line}`);
      const s2 = e2.type.name;
      if ("f32" === s2 || "i32" === s2 || "u32" === s2 || "bool" === s2 || "f16" === s2 || "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2b" === s2 || "vec3b" === s2 || "vec4b" === s2 || "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 || e2.type instanceof ce || e2.type instanceof ie || e2.type instanceof oe) {
        const s3 = new pe(e2.type, []);
        n2 = this._evalCreate(s3, t2);
      }
    }
    t2.createVariable(e2.name, n2, e2);
  }
  _switch(e2, t2) {
    t2 = t2.clone();
    const n2 = this.evalExpression(e2.condition, t2);
    if (!(n2 instanceof Oe)) return console.error(`Invalid if condition. Line ${e2.line}`), null;
    let s2 = null;
    for (const r2 of e2.cases) if (r2 instanceof Se) for (const a2 of r2.selectors) {
      if (a2 instanceof Te) {
        s2 = r2;
        continue;
      }
      const i2 = this.evalExpression(a2, t2);
      if (!(i2 instanceof Oe)) return console.error(`Invalid case selector. Line ${e2.line}`), null;
      if (i2.value === n2.value) return this._execStatements(r2.body, t2);
    }
    else r2 instanceof Ae && (s2 = r2);
    return s2 ? this._execStatements(s2.body, t2) : null;
  }
  _if(e2, t2) {
    t2 = t2.clone();
    const n2 = this.evalExpression(e2.condition, t2);
    if (!(n2 instanceof Oe)) return console.error(`Invalid if condition. Line ${e2.line}`), null;
    if (n2.value) return this._execStatements(e2.body, t2);
    for (const n3 of e2.elseif) {
      const s2 = this.evalExpression(n3.condition, t2);
      if (!(s2 instanceof Oe)) return console.error(`Invalid if condition. Line ${e2.line}`), null;
      if (s2.value) return this._execStatements(n3.body, t2);
    }
    return e2.else ? this._execStatements(e2.else, t2) : null;
  }
  _getScalarValue(e2) {
    return e2 instanceof Oe ? e2.value : (console.error("Expected scalar value.", e2), 0);
  }
  _for(e2, t2) {
    for (t2 = t2.clone(), this.execStatement(e2.init, t2); this._getScalarValue(this.evalExpression(e2.condition, t2)); ) {
      const n2 = this._execStatements(e2.body, t2);
      if (n2 === _pt._breakObj) break;
      if (null !== n2 && n2 !== _pt._continueObj) return n2;
      this.execStatement(e2.increment, t2);
    }
    return null;
  }
  _loop(e2, t2) {
    for (t2 = t2.clone(); ; ) {
      const n2 = this._execStatements(e2.body, t2);
      if (n2 === _pt._breakObj) break;
      if (n2 === _pt._continueObj) {
        if (e2.continuing) {
          if (this._execStatements(e2.continuing.body, t2) === _pt._breakObj) break;
        }
      } else if (null !== n2) return n2;
    }
    return null;
  }
  _while(e2, t2) {
    for (t2 = t2.clone(); this._getScalarValue(this.evalExpression(e2.condition, t2)); ) {
      const n2 = this._execStatements(e2.body, t2);
      if (n2 === _pt._breakObj) break;
      if (n2 !== _pt._continueObj && null !== n2) return n2;
    }
    return null;
  }
  _evalBitcast(e2, t2) {
    const n2 = this.evalExpression(e2.value, t2), s2 = e2.type;
    if (n2 instanceof Oe) {
      const e3 = tt(n2.value, n2.typeInfo.name, s2.name);
      return new Oe(e3, this.getTypeInfo(s2));
    }
    if (n2 instanceof Fe) {
      const t3 = n2.typeInfo.getTypeName();
      let r2 = "";
      if (t3.endsWith("f")) r2 = "f32";
      else if (t3.endsWith("i")) r2 = "i32";
      else if (t3.endsWith("u")) r2 = "u32";
      else if (t3.endsWith("b")) r2 = "bool";
      else {
        if (!t3.endsWith("h")) return console.error(`Unknown vector type ${t3}. Line ${e2.line}`), null;
        r2 = "f16";
      }
      const a2 = s2.getTypeName();
      let i2 = "";
      if (a2.endsWith("f")) i2 = "f32";
      else if (a2.endsWith("i")) i2 = "i32";
      else if (a2.endsWith("u")) i2 = "u32";
      else if (a2.endsWith("b")) i2 = "bool";
      else {
        if (!a2.endsWith("h")) return console.error(`Unknown vector type ${i2}. Line ${e2.line}`), null;
        i2 = "f16";
      }
      const o2 = function(e3, t4, n3) {
        if (t4 === n3) return e3;
        const s3 = new Array(e3.length);
        for (let r3 = 0; r3 < e3.length; r3++) s3[r3] = tt(e3[r3], t4, n3);
        return s3;
      }(Array.from(n2.data), r2, i2);
      return new Fe(o2, this.getTypeInfo(s2));
    }
    return console.error(`TODO: bitcast for ${n2.typeInfo.name}. Line ${e2.line}`), null;
  }
  _evalConst(e2, t2) {
    return t2.getVariableValue(e2.name).clone().getSubData(this, e2.postfix, t2);
  }
  _evalCreate(e2, t2) {
    var r2;
    if (e2 instanceof pe) {
      if (null === e2.type) return Ne.void;
      switch (e2.type.getTypeName()) {
        case "bool":
        case "i32":
        case "u32":
        case "f32":
        case "f16":
          return this._callConstructorValue(e2, t2);
        case "vec2":
        case "vec3":
        case "vec4":
        case "vec2f":
        case "vec3f":
        case "vec4f":
        case "vec2h":
        case "vec3h":
        case "vec4h":
        case "vec2i":
        case "vec3i":
        case "vec4i":
        case "vec2u":
        case "vec3u":
        case "vec4u":
        case "vec2b":
        case "vec3b":
        case "vec4b":
          return this._callConstructorVec(e2, t2);
        case "mat2x2":
        case "mat2x2f":
        case "mat2x2h":
        case "mat2x3":
        case "mat2x3f":
        case "mat2x3h":
        case "mat2x4":
        case "mat2x4f":
        case "mat2x4h":
        case "mat3x2":
        case "mat3x2f":
        case "mat3x2h":
        case "mat3x3":
        case "mat3x3f":
        case "mat3x3h":
        case "mat3x4":
        case "mat3x4f":
        case "mat3x4h":
        case "mat4x2":
        case "mat4x2f":
        case "mat4x2h":
        case "mat4x3":
        case "mat4x3f":
        case "mat4x3h":
        case "mat4x4":
        case "mat4x4f":
        case "mat4x4h":
          return this._callConstructorMatrix(e2, t2);
      }
    }
    const a2 = e2 instanceof pe ? e2.type.name : e2.name, i2 = e2 instanceof pe ? this.getTypeInfo(e2.type) : this.getTypeInfo(e2.name);
    if (null === i2) return console.error(`Unknown type ${a2}. Line ${e2.line}`), null;
    if (0 === i2.size) return null;
    const o2 = new Ue(new ArrayBuffer(i2.size), i2, 0);
    if (i2 instanceof n) {
      if (e2.args) for (let n2 = 0; n2 < e2.args.length; ++n2) {
        const s2 = i2.members[n2], r3 = e2.args[n2], a3 = this.evalExpression(r3, t2);
        o2.setData(this, a3, s2.type, s2.offset, t2);
      }
    } else if (i2 instanceof s) {
      let n2 = 0;
      if (e2.args) for (let s2 = 0; s2 < e2.args.length; ++s2) {
        const a3 = e2.args[s2], l2 = this.evalExpression(a3, t2);
        null === i2.format && ("x32" === (null === (r2 = l2.typeInfo) || void 0 === r2 ? void 0 : r2.name) ? i2.format = this.getTypeInfo("i32") : i2.format = l2.typeInfo), o2.setData(this, l2, i2.format, n2, t2), n2 += i2.stride;
      }
    } else console.error(`Unknown type "${a2}". Line ${e2.line}`);
    return e2 instanceof pe ? o2.getSubData(this, e2.postfix, t2) : o2;
  }
  _evalLiteral(e2, t2) {
    const n2 = this.getTypeInfo(e2.type), s2 = n2.name;
    if ("x32" === s2 || "u32" === s2 || "f32" === s2 || "f16" === s2 || "i32" === s2 || "bool" === s2) {
      return new Oe(e2.scalarValue, n2);
    }
    return "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 ? this._callConstructorVec(e2, t2) : "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 ? this._callConstructorMatrix(e2, t2) : e2.value;
  }
  _evalVariable(e2, t2) {
    const n2 = t2.getVariableValue(e2.name);
    return null === n2 ? n2 : n2.getSubData(this, e2.postfix, t2);
  }
  _maxFormatTypeInfo(e2) {
    let t2 = e2[0];
    if ("f32" === t2.name) return t2;
    for (let n2 = 1; n2 < e2.length; ++n2) {
      const s2 = _pt._priority.get(t2.name);
      _pt._priority.get(e2[n2].name) < s2 && (t2 = e2[n2]);
    }
    return "x32" === t2.name ? this.getTypeInfo("i32") : t2;
  }
  _evalUnaryOp(e2, t2) {
    const n2 = this.evalExpression(e2.right, t2);
    if ("&" === e2.operator) return new Ve(n2);
    if ("*" === e2.operator) return n2 instanceof Ve ? n2.reference.getSubData(this, e2.postfix, t2) : (console.error(`Invalid dereference. Line ${e2.line}`), null);
    const s2 = n2 instanceof Oe ? n2.value : n2 instanceof Fe ? Array.from(n2.data) : null;
    switch (e2.operator) {
      case "+": {
        if (Re(s2)) {
          const e4 = s2.map((e5, t4) => +e5);
          return new Fe(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Oe(+e3, t3);
      }
      case "-": {
        if (Re(s2)) {
          const e4 = s2.map((e5, t4) => -e5);
          return new Fe(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Oe(-e3, t3);
      }
      case "!": {
        if (Re(s2)) {
          const e4 = s2.map((e5, t4) => e5 ? 0 : 1);
          return new Fe(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Oe(e3 ? 0 : 1, t3);
      }
      case "~": {
        if (Re(s2)) {
          const e4 = s2.map((e5, t4) => ~e5);
          return new Fe(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Oe(~e3, t3);
      }
    }
    return console.error(`Invalid unary operator ${e2.operator}. Line ${e2.line}`), null;
  }
  _evalBinaryOp(e2, t2) {
    const n2 = this.evalExpression(e2.left, t2), s2 = this.evalExpression(e2.right, t2), r2 = n2 instanceof Oe ? n2.value : n2 instanceof Fe || n2 instanceof Me ? Array.from(n2.data) : null, a2 = s2 instanceof Oe ? s2.value : s2 instanceof Fe || s2 instanceof Me ? Array.from(s2.data) : null;
    switch (e2.operator) {
      case "+": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 + s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 + e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 + t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 + i2, o2);
      }
      case "-": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 - s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 - e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 - t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 - i2, o2);
      }
      case "*": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, i3 = a2;
          if (n2 instanceof Me && s2 instanceof Me) {
            const r3 = function(e3, t5, n3, s3) {
              if (void 0 === ft[t5.name] || void 0 === ft[s3.name]) return null;
              const r4 = ft[t5.name][0], a4 = ft[t5.name][1], i4 = ft[s3.name][0];
              if (r4 !== ft[s3.name][1]) return null;
              const o4 = new Array(i4 * a4);
              for (let t6 = 0; t6 < a4; t6++) for (let s4 = 0; s4 < i4; s4++) {
                let l3 = 0;
                for (let i5 = 0; i5 < r4; i5++) l3 += e3[i5 * a4 + t6] * n3[s4 * r4 + i5];
                o4[t6 * i4 + s4] = l3;
              }
              return o4;
            }(t4, n2.typeInfo, i3, s2.typeInfo);
            if (null === r3) return console.error(`Matrix multiplication failed. Line ${e2.line}.`), null;
            const a3 = ft[s2.typeInfo.name][0], o3 = ft[n2.typeInfo.name][1], l2 = this.getTypeInfo(`mat${a3}x${o3}f`);
            return new Me(r3, l2);
          }
          if (n2 instanceof Me && s2 instanceof Fe) {
            const r3 = function(e3, t5, n3, s3) {
              if (void 0 === ft[t5.name] || void 0 === ht[s3.name]) return null;
              const r4 = ft[t5.name][0], a3 = ft[t5.name][1];
              if (r4 !== n3.length) return null;
              const i4 = new Array(a3);
              for (let t6 = 0; t6 < a3; t6++) {
                let s4 = 0;
                for (let i5 = 0; i5 < r4; i5++) s4 += e3[i5 * a3 + t6] * n3[i5];
                i4[t6] = s4;
              }
              return i4;
            }(t4, n2.typeInfo, i3, s2.typeInfo);
            return null === r3 ? (console.error(`Matrix vector multiplication failed. Line ${e2.line}.`), null) : new Fe(r3, s2.typeInfo);
          }
          if (n2 instanceof Fe && s2 instanceof Me) {
            const r3 = function(e3, t5, n3, s3) {
              if (void 0 === ht[t5.name] || void 0 === ft[s3.name]) return null;
              const r4 = ft[s3.name][0], a3 = ft[s3.name][1];
              if (a3 !== e3.length) return null;
              const i4 = [];
              for (let t6 = 0; t6 < r4; t6++) {
                let s4 = 0;
                for (let i5 = 0; i5 < a3; i5++) s4 += e3[i5] * n3[i5 * r4 + t6];
                i4[t6] = s4;
              }
              return i4;
            }(t4, n2.typeInfo, i3, s2.typeInfo);
            return null === r3 ? (console.error(`Matrix vector multiplication failed. Line ${e2.line}.`), null) : new Fe(r3, n2.typeInfo);
          }
          {
            if (t4.length !== i3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
            const s3 = t4.map((e3, t5) => e3 * i3[t5]);
            return new Fe(s3, n2.typeInfo);
          }
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 * e3);
          return n2 instanceof Me ? new Me(t4, n2.typeInfo) : new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 * t5);
          return s2 instanceof Me ? new Me(t4, s2.typeInfo) : new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 * i2, o2);
      }
      case "%": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 % s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 % e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 % t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 % i2, o2);
      }
      case "/": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 / s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 / e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 / t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 / i2, o2);
      }
      case "&": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 & s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 & e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 & t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 & i2, o2);
      }
      case "|": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 | s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 | e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 | t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 | i2, o2);
      }
      case "^": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 ^ s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 ^ e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 ^ t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 ^ i2, o2);
      }
      case "<<": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 << s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 << e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 << t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 << i2, o2);
      }
      case ">>": {
        if (Re(r2) && Re(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t4.map((e3, t5) => e3 >> s3[t5]);
          return new Fe(i3, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 >> e3);
          return new Fe(t4, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 >> t5);
          return new Fe(t4, s2.typeInfo);
        }
        const t3 = r2, i2 = a2, o2 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Oe(t3 >> i2, o2);
      }
      case ">":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 > s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 > e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 > t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 > a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 < s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 < e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 < t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 < a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 === s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 == e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 == t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 === a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 !== s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 !== e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 !== t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 !== a2 ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 >= s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 >= e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 >= t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 >= a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 <= s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 <= e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 <= t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 <= a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 && s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 && e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 && t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 && a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (Re(r2) && Re(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length) return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i2 = t3.map((e3, t4) => e3 || s3[t4] ? 1 : 0);
          return new Fe(i2, n2.typeInfo);
        }
        if (Re(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 || e3 ? 1 : 0);
          return new Fe(t3, n2.typeInfo);
        }
        if (Re(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 || t4 ? 1 : 0);
          return new Fe(t3, s2.typeInfo);
        }
        return new Oe(r2 || a2 ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${e2.operator}. Line ${e2.line}`), null;
  }
  _evalCall(e2, t2) {
    if (null !== e2.cachedReturnValue) return e2.cachedReturnValue;
    const n2 = t2.clone();
    n2.currentFunctionName = e2.name;
    const s2 = t2.getFunction(e2.name);
    if (!s2) {
      if (e2.isBuiltin) return this._callBuiltinFunction(e2, n2);
      return this.getTypeInfo(e2.name) ? this._evalCreate(e2, t2) : (console.error(`Unknown function "${e2.name}". Line ${e2.line}`), null);
    }
    for (let t3 = 0; t3 < s2.node.args.length; ++t3) {
      const r2 = s2.node.args[t3], a2 = this.evalExpression(e2.args[t3], n2);
      n2.createVariable(r2.name, a2, r2);
    }
    return this._execStatements(s2.node.body, n2);
  }
  _callBuiltinFunction(e2, t2) {
    switch (e2.name) {
      case "all":
        return this.builtins.All(e2, t2);
      case "any":
        return this.builtins.Any(e2, t2);
      case "select":
        return this.builtins.Select(e2, t2);
      case "arrayLength":
        return this.builtins.ArrayLength(e2, t2);
      case "abs":
        return this.builtins.Abs(e2, t2);
      case "acos":
        return this.builtins.Acos(e2, t2);
      case "acosh":
        return this.builtins.Acosh(e2, t2);
      case "asin":
        return this.builtins.Asin(e2, t2);
      case "asinh":
        return this.builtins.Asinh(e2, t2);
      case "atan":
        return this.builtins.Atan(e2, t2);
      case "atanh":
        return this.builtins.Atanh(e2, t2);
      case "atan2":
        return this.builtins.Atan2(e2, t2);
      case "ceil":
        return this.builtins.Ceil(e2, t2);
      case "clamp":
        return this.builtins.Clamp(e2, t2);
      case "cos":
        return this.builtins.Cos(e2, t2);
      case "cosh":
        return this.builtins.Cosh(e2, t2);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(e2, t2);
      case "countOneBits":
        return this.builtins.CountOneBits(e2, t2);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(e2, t2);
      case "cross":
        return this.builtins.Cross(e2, t2);
      case "degrees":
        return this.builtins.Degrees(e2, t2);
      case "determinant":
        return this.builtins.Determinant(e2, t2);
      case "distance":
        return this.builtins.Distance(e2, t2);
      case "dot":
        return this.builtins.Dot(e2, t2);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(e2, t2);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(e2, t2);
      case "exp":
        return this.builtins.Exp(e2, t2);
      case "exp2":
        return this.builtins.Exp2(e2, t2);
      case "extractBits":
        return this.builtins.ExtractBits(e2, t2);
      case "faceForward":
        return this.builtins.FaceForward(e2, t2);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(e2, t2);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(e2, t2);
      case "floor":
        return this.builtins.Floor(e2, t2);
      case "fma":
        return this.builtins.Fma(e2, t2);
      case "fract":
        return this.builtins.Fract(e2, t2);
      case "frexp":
        return this.builtins.Frexp(e2, t2);
      case "insertBits":
        return this.builtins.InsertBits(e2, t2);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(e2, t2);
      case "ldexp":
        return this.builtins.Ldexp(e2, t2);
      case "length":
        return this.builtins.Length(e2, t2);
      case "log":
        return this.builtins.Log(e2, t2);
      case "log2":
        return this.builtins.Log2(e2, t2);
      case "max":
        return this.builtins.Max(e2, t2);
      case "min":
        return this.builtins.Min(e2, t2);
      case "mix":
        return this.builtins.Mix(e2, t2);
      case "modf":
        return this.builtins.Modf(e2, t2);
      case "normalize":
        return this.builtins.Normalize(e2, t2);
      case "pow":
        return this.builtins.Pow(e2, t2);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(e2, t2);
      case "radians":
        return this.builtins.Radians(e2, t2);
      case "reflect":
        return this.builtins.Reflect(e2, t2);
      case "refract":
        return this.builtins.Refract(e2, t2);
      case "reverseBits":
        return this.builtins.ReverseBits(e2, t2);
      case "round":
        return this.builtins.Round(e2, t2);
      case "saturate":
        return this.builtins.Saturate(e2, t2);
      case "sign":
        return this.builtins.Sign(e2, t2);
      case "sin":
        return this.builtins.Sin(e2, t2);
      case "sinh":
        return this.builtins.Sinh(e2, t2);
      case "smoothStep":
        return this.builtins.SmoothStep(e2, t2);
      case "sqrt":
        return this.builtins.Sqrt(e2, t2);
      case "step":
        return this.builtins.Step(e2, t2);
      case "tan":
        return this.builtins.Tan(e2, t2);
      case "tanh":
        return this.builtins.Tanh(e2, t2);
      case "transpose":
        return this.builtins.Transpose(e2, t2);
      case "trunc":
        return this.builtins.Trunc(e2, t2);
      case "dpdx":
        return this.builtins.Dpdx(e2, t2);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(e2, t2);
      case "dpdxFine":
        return this.builtins.DpdxFine(e2, t2);
      case "dpdy":
        return this.builtins.Dpdy(e2, t2);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(e2, t2);
      case "dpdyFine":
        return this.builtins.DpdyFine(e2, t2);
      case "fwidth":
        return this.builtins.Fwidth(e2, t2);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(e2, t2);
      case "fwidthFine":
        return this.builtins.FwidthFine(e2, t2);
      case "textureDimensions":
        return this.builtins.TextureDimensions(e2, t2);
      case "textureGather":
        return this.builtins.TextureGather(e2, t2);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(e2, t2);
      case "textureLoad":
        return this.builtins.TextureLoad(e2, t2);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(e2, t2);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(e2, t2);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(e2, t2);
      case "textureSample":
        return this.builtins.TextureSample(e2, t2);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(e2, t2);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(e2, t2);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(e2, t2);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(e2, t2);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(e2, t2);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(e2, t2);
      case "textureStore":
        return this.builtins.TextureStore(e2, t2);
      case "atomicLoad":
        return this.builtins.AtomicLoad(e2, t2);
      case "atomicStore":
        return this.builtins.AtomicStore(e2, t2);
      case "atomicAdd":
        return this.builtins.AtomicAdd(e2, t2);
      case "atomicSub":
        return this.builtins.AtomicSub(e2, t2);
      case "atomicMax":
        return this.builtins.AtomicMax(e2, t2);
      case "atomicMin":
        return this.builtins.AtomicMin(e2, t2);
      case "atomicAnd":
        return this.builtins.AtomicAnd(e2, t2);
      case "atomicOr":
        return this.builtins.AtomicOr(e2, t2);
      case "atomicXor":
        return this.builtins.AtomicXor(e2, t2);
      case "atomicExchange":
        return this.builtins.AtomicExchange(e2, t2);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(e2, t2);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(e2, t2);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(e2, t2);
      case "pack4xI8":
        return this.builtins.Pack4xI8(e2, t2);
      case "pack4xU8":
        return this.builtins.Pack4xU8(e2, t2);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(e2, t2);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(e2, t2);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(e2, t2);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(e2, t2);
      case "pack2x16float":
        return this.builtins.Pack2x16float(e2, t2);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(e2, t2);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(e2, t2);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(e2, t2);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(e2, t2);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(e2, t2);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(e2, t2);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(e2, t2);
      case "storageBarrier":
        return this.builtins.StorageBarrier(e2, t2);
      case "textureBarrier":
        return this.builtins.TextureBarrier(e2, t2);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(e2, t2);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(e2, t2);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(e2, t2);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(e2, t2);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(e2, t2);
      case "subgroupAll":
        return this.builtins.SubgroupAll(e2, t2);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(e2, t2);
      case "subgroupAny":
        return this.builtins.SubgroupAny(e2, t2);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(e2, t2);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(e2, t2);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(e2, t2);
      case "subgroupElect":
        return this.builtins.SubgroupElect(e2, t2);
      case "subgroupMax":
        return this.builtins.SubgroupMax(e2, t2);
      case "subgroupMin":
        return this.builtins.SubgroupMin(e2, t2);
      case "subgroupMul":
        return this.builtins.SubgroupMul(e2, t2);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(e2, t2);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(e2, t2);
      case "subgroupOr":
        return this.builtins.SubgroupOr(e2, t2);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(e2, t2);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(e2, t2);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(e2, t2);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(e2, t2);
      case "subgroupXor":
        return this.builtins.SubgroupXor(e2, t2);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(e2, t2);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(e2, t2);
      case "quadSwapX":
        return this.builtins.QuadSwapX(e2, t2);
      case "quadSwapY":
        return this.builtins.QuadSwapY(e2, t2);
    }
    const n2 = t2.getFunction(e2.name);
    if (n2) {
      const s2 = t2.clone();
      for (let t3 = 0; t3 < n2.node.args.length; ++t3) {
        const r2 = n2.node.args[t3], a2 = this.evalExpression(e2.args[t3], s2);
        s2.setVariable(r2.name, a2, r2);
      }
      return this._execStatements(n2.node.body, s2);
    }
    return null;
  }
  _callConstructorValue(e2, t2) {
    if (!e2.args || 0 === e2.args.length) return new Oe(0, this.getTypeInfo(e2.type));
    const n2 = this.evalExpression(e2.args[0], t2);
    return n2.typeInfo = this.getTypeInfo(e2.type), n2.getSubData(this, e2.postfix, t2).clone();
  }
  _callConstructorVec(e2, t2) {
    const n2 = this.getTypeInfo(e2.type), s2 = e2.type.getTypeName(), r2 = ht[s2];
    if (void 0 === r2) return console.error(`Invalid vec constructor ${s2}. Line ${e2.line}`), null;
    const a2 = [];
    if (e2 instanceof ge) if (e2.isVector) {
      const t3 = e2.vectorValue;
      for (const e3 of t3) a2.push(e3);
    } else a2.push(e2.scalarValue);
    else if (e2.args) for (const n3 of e2.args) {
      const e3 = this.evalExpression(n3, t2);
      if (e3 instanceof Fe) {
        const t3 = e3.data;
        for (let e4 = 0; e4 < t3.length; ++e4) {
          let n4 = t3[e4];
          a2.push(n4);
        }
      } else if (e3 instanceof Oe) {
        let t3 = e3.value;
        a2.push(t3);
      }
    }
    if (e2.type instanceof oe && null === e2.type.format && (e2.type.format = oe.f32), 0 === a2.length) {
      const s3 = new Array(r2).fill(0);
      return new Fe(s3, n2).getSubData(this, e2.postfix, t2);
    }
    if (1 === a2.length) for (; a2.length < r2; ) a2.push(a2[0]);
    if (a2.length < r2) return console.error(`Invalid vec constructor. Line ${e2.line}`), null;
    return new Fe(a2.length > r2 ? a2.slice(0, r2) : a2, n2).getSubData(this, e2.postfix, t2);
  }
  _callConstructorMatrix(e2, t2) {
    const n2 = this.getTypeInfo(e2.type), s2 = e2.type.getTypeName(), r2 = ft[s2];
    if (void 0 === r2) return console.error(`Invalid matrix constructor ${s2}. Line ${e2.line}`), null;
    const i2 = [];
    if (e2 instanceof ge) if (e2.isVector) {
      const t3 = e2.vectorValue;
      for (const e3 of t3) i2.push(e3);
    } else i2.push(e2.scalarValue);
    else if (e2.args) for (const n3 of e2.args) {
      const e3 = this.evalExpression(n3, t2);
      e3 instanceof Fe ? i2.push(...e3.data) : e3 instanceof Oe ? i2.push(e3.value) : e3 instanceof Me && i2.push(...e3.data);
    }
    if (n2 instanceof a && null === n2.format && (n2.format = this.getTypeInfo("f32")), 0 === i2.length) {
      const s3 = new Array(r2[2]).fill(0);
      return new Me(s3, n2).getSubData(this, e2.postfix, t2);
    }
    return i2.length !== r2[2] ? (console.error(`Invalid matrix constructor. Line ${e2.line}`), null) : new Me(i2, n2).getSubData(this, e2.postfix, t2);
  }
};
pt._breakObj = new De(new e("BREAK", null), null), pt._continueObj = new De(new e("CONTINUE", null), null), pt._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/math/fp16/fp16-utils.js
var buffer = new ArrayBuffer(4);
var floatView = new Float32Array(buffer);
var uint32View = new Uint32Array(buffer);

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js
var lightingUniformsGLSL = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
);

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js
var lightingUniformsWGSL = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
);

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js
var MAX_LIGHTS = 3;
var COLOR_FACTOR = 255;
var LIGHT_TYPE;
(function(LIGHT_TYPE2) {
  LIGHT_TYPE2[LIGHT_TYPE2["POINT"] = 0] = "POINT";
  LIGHT_TYPE2[LIGHT_TYPE2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
})(LIGHT_TYPE || (LIGHT_TYPE = {}));
var lighting = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    MAX_LIGHTS
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientLightColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: LIGHT_TYPE.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientLightColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: lightingUniformsWGSL,
  vs: lightingUniformsGLSL,
  fs: lightingUniformsGLSL,
  getUniforms
};
function getUniforms(props, prevUniforms = {}) {
  props = props ? { ...props } : props;
  if (!props) {
    return { ...lighting.defaultUniforms };
  }
  if (props.lights) {
    props = { ...props, ...extractLightTypes(props.lights), lights: void 0 };
  }
  const { ambientLight, pointLights, directionalLights } = props || {};
  const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
  if (!hasLights) {
    return { ...lighting.defaultUniforms, enabled: 0 };
  }
  const uniforms = {
    ...lighting.defaultUniforms,
    ...prevUniforms,
    ...getLightSourceUniforms({ ambientLight, pointLights, directionalLights })
  };
  if (props.enabled !== void 0) {
    uniforms.enabled = props.enabled ? 1 : 0;
  }
  return uniforms;
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
  const lightSourceUniforms = {};
  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);
  let currentLight = 0;
  for (const pointLight of pointLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
    const i2 = currentLight;
    lightSourceUniforms[`lightColor${i2}`] = convertColor(pointLight);
    lightSourceUniforms[`lightPosition${i2}`] = pointLight.position;
    lightSourceUniforms[`lightAttenuation${i2}`] = pointLight.attenuation || [1, 0, 0];
    currentLight++;
  }
  for (const directionalLight of directionalLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
    const i2 = currentLight;
    lightSourceUniforms[`lightColor${i2}`] = convertColor(directionalLight);
    lightSourceUniforms[`lightDirection${i2}`] = directionalLight.direction;
    currentLight++;
  }
  if (currentLight > MAX_LIGHTS) {
    log.warn("MAX_LIGHTS exceeded")();
  }
  lightSourceUniforms.directionalLightCount = directionalLights.length;
  lightSourceUniforms.pointLightCount = pointLights.length;
  return lightSourceUniforms;
}
function extractLightTypes(lights2) {
  var _a, _b;
  const lightSources = { pointLights: [], directionalLights: [] };
  for (const light of lights2 || []) {
    switch (light.type) {
      case "ambient":
        lightSources.ambientLight = light;
        break;
      case "directional":
        (_a = lightSources.directionalLights) == null ? void 0 : _a.push(light);
        break;
      case "point":
        (_b = lightSources.pointLights) == null ? void 0 : _b.push(light);
        break;
      default:
    }
  }
  return lightSources;
}
function convertColor(colorDef = {}) {
  const { color = [0, 0, 0], intensity = 1 } = colorDef;
  return color.map((component) => component * intensity / COLOR_FACTOR);
}

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js
var PHONG_VS = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
);
var PHONG_FS = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
);

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js
var PHONG_WGSL = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
);

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js
var gouraudMaterial = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: PHONG_FS.replace("phongMaterial", "gouraudMaterial"),
  fs: PHONG_VS.replace("phongMaterial", "gouraudMaterial"),
  source: PHONG_WGSL.replaceAll("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: 1
  },
  dependencies: [lighting],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(props) {
    const uniforms = { ...props };
    if (uniforms.specularColor) {
      uniforms.specularColor = uniforms.specularColor.map((x2) => x2 / 255);
    }
    return { ...gouraudMaterial.defaultUniforms, ...uniforms };
  }
};

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-material.js
var phongMaterial = {
  name: "phongMaterial",
  dependencies: [lighting],
  // Note these are switched between phong and gouraud
  source: PHONG_WGSL,
  vs: PHONG_VS,
  fs: PHONG_FS,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(props) {
    const uniforms = { ...props };
    if (uniforms.specularColor) {
      uniforms.specularColor = uniforms.specularColor.map((x2) => x2 / 255);
    }
    return { ...phongMaterial.defaultUniforms, ...uniforms };
  }
};

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules-webgl1/project/project.js
var common = (
  /* glsl */
  `varying vec4 project_vPositionWorld;
varying vec3 project_vNormalWorld;

vec4 project_getPosition_World() {
  return project_vPositionWorld;
}

vec3 project_getNormal_World() {
  return project_vNormalWorld;
}
`
);
var vs2 = `${common}

// Unprefixed uniforms
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewProjectionMatrix;
uniform vec3 cameraPositionWorld;

struct World {
  vec3 position;
  vec3 normal;
};

World world;

void project_setPosition(vec4 position) {
  project_vPositionWorld = position;
}

void project_setNormal(vec3 normal) {
  project_vNormalWorld = normal;
}

void project_setPositionAndNormal_World(vec3 position, vec3 normal) {
  world.position = position;
  world.normal = normal;
}

void project_setPositionAndNormal_Model(vec3 position, vec3 normal) {
  world.position = (modelMatrix * vec4(position, 1.)).xyz;
  world.normal = mat3(modelMatrix) * normal;
}

vec4 project_model_to_clipspace(vec4 position) {
  return viewProjectionMatrix * modelMatrix * position;
}

vec4 project_model_to_clipspace(vec3 position) {
  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);
}

vec4 project_world_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}

vec4 project_view_to_clipspace(vec3 position) {
  return projectionMatrix * vec4(position, 1.);
}

vec4 project_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}
`;
var fs2 = `
${common}`;

// node_modules/@deck.gl/layers/node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/dirlight/dirlight.js
var DEFAULT_MODULE_OPTIONS = {
  lightDirection: new Float32Array([1, 1, 2])
};

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-uniforms.js
var uniformBlock4 = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`;
var pointCloudUniforms = {
  name: "pointCloud",
  vs: uniformBlock4,
  fs: uniformBlock4,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-vertex.glsl.js
var point_cloud_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-fragment.glsl.js
var point_cloud_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer.js
var DEFAULT_COLOR4 = [0, 0, 0, 255];
var DEFAULT_NORMAL = [0, 0, 1];
var defaultProps5 = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getNormal: { type: "accessor", value: DEFAULT_NORMAL },
  getColor: { type: "accessor", value: DEFAULT_COLOR4 },
  material: true,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function normalizeData(data) {
  const { header, attributes } = data;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    const { size, value } = attributes.COLOR_0;
    attributes.instanceColors = { size, type: "unorm8", value };
  }
}
var PointCloudLayer = class extends Layer {
  getShaders() {
    return super.getShaders({
      vs: point_cloud_layer_vertex_glsl_default,
      fs: point_cloud_layer_fragment_glsl_default,
      modules: [project32_default, gouraudMaterial, picking_default, pointCloudUniforms]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: "getNormal",
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR4
      }
    });
  }
  updateState(params) {
    var _a;
    const { changeFlags, props } = params;
    super.updateState(params);
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
    if (changeFlags.dataChanged) {
      normalizeData(props.data);
    }
  }
  draw({ uniforms }) {
    const { pointSize, sizeUnits } = this.props;
    const model = this.state.model;
    const pointCloudProps = {
      sizeUnits: UNIT[sizeUnits],
      radiusPixels: pointSize
    };
    model.shaderInputs.setProps({ pointCloud: pointCloudProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [];
    for (let i2 = 0; i2 < 3; i2++) {
      const angle3 = i2 / 3 * Math.PI * 2;
      positions.push(Math.cos(angle3) * 2, Math.sin(angle3) * 2, 0);
    }
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }
};
PointCloudLayer.layerName = "PointCloudLayer";
PointCloudLayer.defaultProps = defaultProps5;
var point_cloud_layer_default = PointCloudLayer;

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-uniforms.js
var glslUniformBlock = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`;
var scatterplotUniforms = {
  name: "scatterplot",
  vs: glslUniformBlock,
  fs: glslUniformBlock,
  source: "",
  uniformTypes: {
    radiusScale: "f32",
    radiusMinPixels: "f32",
    radiusMaxPixels: "f32",
    lineWidthScale: "f32",
    lineWidthMinPixels: "f32",
    lineWidthMaxPixels: "f32",
    stroked: "f32",
    filled: "f32",
    antialiasing: "f32",
    billboard: "f32",
    radiusUnits: "i32",
    lineWidthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.wgsl.js
var scatterplot_layer_wgsl_default = (
  /* wgsl */
  `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)

struct LayerUniforms {
  opacity: f32,
};

var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    // discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        // discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    // discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR5 = [0, 0, 0, 255];
var defaultProps6 = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var ScatterplotLayer = class extends Layer {
  getShaders() {
    return super.getShaders({
      vs: scatterplot_layer_vertex_glsl_default,
      fs: scatterplot_layer_fragment_glsl_default,
      source: scatterplot_layer_wgsl_default,
      modules: [project32_default, picking_default, scatterplotUniforms]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;
    const scatterplotProps = {
      stroked,
      filled,
      billboard,
      antialiasing,
      radiusUnits: UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    };
    const model = this.state.model;
    model.shaderInputs.setProps({ scatterplot: scatterplotProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
ScatterplotLayer.defaultProps = defaultProps6;
ScatterplotLayer.layerName = "ScatterplotLayer";
var scatterplot_layer_default = ScatterplotLayer;

// node_modules/@deck.gl/layers/node_modules/@math.gl/polygon/dist/polygon-utils.js
var WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
var DimIndex = {
  x: 0,
  y: 1,
  z: 2
};
function getPolygonSignedArea(points, options = {}) {
  const { start = 0, end = points.length, plane = "xy" } = options;
  const dim = options.size || 2;
  let area = 0;
  const i0 = DimIndex[plane[0]];
  const i1 = DimIndex[plane[1]];
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    area += (points[i2 + i0] - points[j2 + i0]) * (points[i2 + i1] + points[j2 + i1]);
    j2 = i2;
  }
  return area / 2;
}
function reversePolygon(points, options) {
  const { start = 0, end = points.length, size = 2 } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i2 = 0; i2 < numSwaps; ++i2) {
    const b1 = start + i2 * size;
    const b2 = start + (numPoints - 1 - i2) * size;
    for (let j2 = 0; j2 < size; ++j2) {
      const tmp = points[b1 + j2];
      points[b1 + j2] = points[b2 + j2];
      points[b2 + j2] = tmp;
    }
  }
}

// node_modules/@deck.gl/layers/node_modules/@math.gl/polygon/dist/utils.js
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i2 = 0; i2 < size; i2++) {
      if (target[startIndex - size + i2] !== source[i2]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i2 = 0; i2 < size; i2++) {
    target[startIndex + i2] = source[i2];
  }
  return true;
}
function copy7(target, source) {
  const size = source.length;
  for (let i2 = 0; i2 < size; i2++) {
    target[i2] = source[i2];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i2 = 0; i2 < size; i2++) {
    out[i2] = positions[startI + i2];
  }
  return out;
}

// node_modules/@deck.gl/layers/node_modules/@math.gl/polygon/dist/lineclip.js
function intersect(a2, b2, edge, bbox, out = []) {
  let t2;
  let snap;
  if (edge & 8) {
    t2 = (bbox[3] - a2[1]) / (b2[1] - a2[1]);
    snap = 3;
  } else if (edge & 4) {
    t2 = (bbox[1] - a2[1]) / (b2[1] - a2[1]);
    snap = 1;
  } else if (edge & 2) {
    t2 = (bbox[2] - a2[0]) / (b2[0] - a2[0]);
    snap = 2;
  } else if (edge & 1) {
    t2 = (bbox[0] - a2[0]) / (b2[0] - a2[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i2 = 0; i2 < a2.length; i2++) {
    out[i2] = (snap & 1) === i2 ? bbox[snap] : t2 * (b2[i2] - a2[i2]) + a2[i2];
  }
  return out;
}
function bitCode(p2, bbox) {
  let code = 0;
  if (p2[0] < bbox[0])
    code |= 1;
  else if (p2[0] > bbox[2])
    code |= 2;
  if (p2[1] < bbox[1])
    code |= 4;
  else if (p2[1] > bbox[3])
    code |= 8;
  return code;
}

// node_modules/@deck.gl/layers/node_modules/@math.gl/polygon/dist/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a2 = getPointAtIndex(positions, 0, size, startIndex);
  let b2;
  let codeB;
  const cell = getGridCell(a2, gridResolution, gridOffset, []);
  const scratchPoint = [];
  push(part, a2);
  for (let i2 = 1; i2 < numPoints; i2++) {
    b2 = getPointAtIndex(positions, i2, size, startIndex, b2);
    codeB = bitCode(b2, cell);
    while (codeB) {
      intersect(a2, b2, codeB, cell, scratchPoint);
      const codeAlt = bitCode(scratchPoint, cell);
      if (codeAlt) {
        intersect(a2, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      push(part, scratchPoint);
      copy7(a2, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a2);
      }
      codeB = bitCode(b2, cell);
    }
    push(part, b2);
    copy7(a2, b2);
  }
  return broken ? result : result[0];
}
var TYPE_INSIDE = 0;
var TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
  const result = [];
  const queue = [
    {
      pos: positions,
      types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
      holes: holeIndices || []
    }
  ];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const { pos, types, holes } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
      const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
      queue.push(polygonLow, polygonHigh);
      for (let i2 = 0; i2 < holes.length; i2++) {
        parts = bisectPolygon(pos, types, size, holes[i2], holes[i2 + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = { positions: pos };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p2;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i2 = 0; i2 < numPoints; i2++) {
    p2 = getPointAtIndex(positions, i2, size, startIndex, p2);
    side = Math.sign(edge & 8 ? p2[1] - bbox[3] : p2[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i2];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p2, edge, bbox, scratchPoint);
      push(resultLow, scratchPoint) && typesLow.push(prevType);
      push(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p2) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p2) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy7(prev, p2);
    prevSide = side;
    prevType = type;
  }
  return [
    lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
    highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
  ];
}
function getGridCell(p2, gridResolution, gridOffset, out) {
  const left = Math.floor((p2[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p2[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i2 = 0; i2 < endIndex; i2 += size) {
    const x2 = positions[i2];
    const y2 = positions[i2 + 1];
    minX = x2 < minX ? x2 : minX;
    maxX = x2 > maxX ? x2 : maxX;
    minY = y2 < minY ? y2 : minY;
    maxY = y2 > maxY ? y2 : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
function concatInPlace(arr1, arr2) {
  for (let i2 = 0; i2 < arr2.length; i2++) {
    arr1.push(arr2[i2]);
  }
  return arr1;
}

// node_modules/@deck.gl/layers/node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
var DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize6 = true } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize6) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const { size = 2, normalize: normalize6 = true, edgeTypes = false } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i2 = splitIndex; i2 < srcEndIndex; i2++) {
      newPositions[targetIndex++] = positions[i2];
    }
    for (let i2 = srcStartIndex; i2 < splitIndex; i2++) {
      newPositions[targetIndex++] = positions[i2];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options == null ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize6) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i2 = startIndex + 1; i2 < endIndex; i2 += size) {
    const lat = Math.abs(positions[i2]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i2 - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p2 = getPointAtIndex(positions, 0, size, startIndex);
    p2[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p2);
    p2[1] = Math.sign(p2[1]) * maxLatitude;
    push(positions, p2);
    p2[0] = firstLng;
    push(positions, p2);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i2 = startIndex; i2 < endIndex; i2 += size) {
    lng = positions[i2];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i2] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i2 = 0; i2 < pointCount; i2++) {
    refLng = positions[i2 * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i2 = 0; i2 < pointCount; i2++) {
    positions[i2 * size] += delta;
  }
}

// node_modules/@deck.gl/layers/dist/column-layer/column-geometry.js
var ColumnGeometry = class extends Geometry {
  constructor(props) {
    const { indices, attributes } = tesselateColumn(props);
    super({
      ...props,
      indices,
      // @ts-expect-error
      attributes
    });
  }
};
function tesselateColumn(props) {
  const { radius, height = 1, nradial = 10 } = props;
  let { vertices } = props;
  if (vertices) {
    log_default.assert(vertices.length >= nradial);
    vertices = vertices.flatMap((v2) => [v2[0], v2[1]]);
    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
  }
  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i2 = 0;
  if (isExtruded) {
    for (let j2 = 0; j2 < vertsAroundEdge; j2++) {
      const a2 = j2 * stepAngle;
      const vertexIndex = j2 % nradial;
      const sin2 = Math.sin(a2);
      const cos2 = Math.cos(a2);
      for (let k2 = 0; k2 < 2; k2++) {
        positions[i2 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
        positions[i2 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
        positions[i2 + 2] = (1 / 2 - k2) * height;
        normals[i2 + 0] = vertices ? vertices[vertexIndex * 2] : cos2;
        normals[i2 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2;
        i2 += 3;
      }
    }
    positions[i2 + 0] = positions[i2 - 3];
    positions[i2 + 1] = positions[i2 - 2];
    positions[i2 + 2] = positions[i2 - 1];
    i2 += 3;
  }
  for (let j2 = isExtruded ? 0 : 1; j2 < vertsAroundEdge; j2++) {
    const v2 = Math.floor(j2 / 2) * Math.sign(0.5 - j2 % 2);
    const a2 = v2 * stepAngle;
    const vertexIndex = (v2 + nradial) % nradial;
    const sin2 = Math.sin(a2);
    const cos2 = Math.cos(a2);
    positions[i2 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
    positions[i2 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
    positions[i2 + 2] = height / 2;
    normals[i2 + 2] = 1;
    i2 += 3;
  }
  if (isExtruded) {
    let index = 0;
    for (let j2 = 0; j2 < nradial; j2++) {
      indices[index++] = j2 * 2 + 0;
      indices[index++] = j2 * 2 + 2;
      indices[index++] = j2 * 2 + 0;
      indices[index++] = j2 * 2 + 1;
      indices[index++] = j2 * 2 + 1;
      indices[index++] = j2 * 2 + 3;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: { size: 3, value: positions },
      NORMAL: { size: 3, value: normals }
    }
  };
}

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-uniforms.js
var uniformBlock5 = `uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`;
var columnUniforms = {
  name: "column",
  vs: uniformBlock5,
  fs: uniformBlock5,
  uniformTypes: {
    radius: "f32",
    angle: "f32",
    offset: "vec2<f32>",
    extruded: "f32",
    stroked: "f32",
    isStroke: "f32",
    coverage: "f32",
    elevationScale: "f32",
    edgeDistance: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    radiusUnits: "i32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-vertex.glsl.js
var column_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
column.widthMinPixels, column.widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = column.radius * column.coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
if (column.radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
cameraPosition = project.cameraPosition;
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-fragment.glsl.js
var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer.js
var DEFAULT_COLOR6 = [0, 0, 0, 255];
var defaultProps7 = {
  diskResolution: { type: "number", min: 4, value: 20 },
  vertices: null,
  radius: { type: "number", min: 0, value: 1e3 },
  angle: { type: "number", value: 0 },
  offset: { type: "array", value: [0, 0] },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  elevationScale: { type: "number", min: 0, value: 1 },
  radiusUnits: "meters",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  wireframe: false,
  filled: true,
  stroked: false,
  flatShading: false,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineWidth: { type: "accessor", value: 1 },
  getElevation: { type: "accessor", value: 1e3 },
  material: true,
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var ColumnLayer = class extends Layer {
  getShaders() {
    const defines = {};
    const { flatShading } = this.props;
    if (flatShading) {
      defines.FLAT_SHADING = 1;
    }
    return super.getShaders({
      vs: column_layer_vertex_glsl_default,
      fs: column_layer_fragment_glsl_default,
      defines,
      modules: [project32_default, flatShading ? phongMaterial : gouraudMaterial, picking_default, columnUniforms]
    });
  }
  /**
   * DeckGL calls initializeState when GL context is available
   * Essentially a deferred constructor
   */
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: "getElevation"
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getLineWidth",
        transition: true
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
    if (regenerateModels) {
      (_a = this.state.models) == null ? void 0 : _a.forEach((model) => model.destroy());
      this.setState(this._getModels());
      this.getAttributeManager().invalidateAll();
    }
    const instanceCount = this.getNumInstances();
    this.state.fillModel.setInstanceCount(instanceCount);
    this.state.wireframeModel.setInstanceCount(instanceCount);
    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
      this._updateGeometry(props);
    }
  }
  getGeometry(diskResolution, vertices, hasThinkness) {
    const geometry2 = new ColumnGeometry({
      radius: 1,
      height: hasThinkness ? 2 : 0,
      vertices,
      nradial: diskResolution
    });
    let meanVertexDistance = 0;
    if (vertices) {
      for (let i2 = 0; i2 < diskResolution; i2++) {
        const p2 = vertices[i2];
        const d2 = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1]);
        meanVertexDistance += d2 / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }
    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });
    return geometry2;
  }
  _getModels() {
    const shaders = this.getShaders();
    const bufferLayout = this.getAttributeManager().getBufferLayouts();
    const fillModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-fill`,
      bufferLayout,
      isInstanced: true
    });
    const wireframeModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-wireframe`,
      bufferLayout,
      isInstanced: true
    });
    return {
      fillModel,
      wireframeModel,
      models: [wireframeModel, fillModel]
    };
  }
  _updateGeometry({ diskResolution, vertices, extruded, stroked }) {
    const geometry2 = this.getGeometry(diskResolution, vertices, extruded || stroked);
    this.setState({
      fillVertexCount: geometry2.attributes.POSITION.value.length / 3
    });
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    fillModel.setGeometry(geometry2);
    fillModel.setTopology("triangle-strip");
    fillModel.setIndexBuffer(null);
    wireframeModel.setGeometry(geometry2);
    wireframeModel.setTopology("line-list");
  }
  draw({ uniforms }) {
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, radiusUnits, elevationScale, extruded, filled, stroked, wireframe, offset, coverage, radius, angle: angle3 } = this.props;
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    const { fillVertexCount, edgeDistance } = this.state;
    const columnProps = {
      radius,
      angle: angle3 / 180 * Math.PI,
      offset,
      extruded,
      stroked,
      coverage,
      elevationScale,
      edgeDistance,
      radiusUnits: UNIT[radiusUnits],
      widthUnits: UNIT[lineWidthUnits],
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels
    };
    if (extruded && wireframe) {
      wireframeModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: true
        }
      });
      wireframeModel.draw(this.context.renderPass);
    }
    if (filled) {
      fillModel.setVertexCount(fillVertexCount);
      fillModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: false
        }
      });
      fillModel.draw(this.context.renderPass);
    }
    if (!extruded && stroked) {
      fillModel.setVertexCount(fillVertexCount * 2 / 3);
      fillModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: true
        }
      });
      fillModel.draw(this.context.renderPass);
    }
  }
};
ColumnLayer.layerName = "ColumnLayer";
ColumnLayer.defaultProps = defaultProps7;
var column_layer_default = ColumnLayer;

// node_modules/@deck.gl/layers/dist/column-layer/grid-cell-layer.js
var defaultProps8 = {
  cellSize: { type: "number", min: 0, value: 1e3 },
  offset: { type: "array", value: [1, 1] }
};
var GridCellLayer = class extends column_layer_default {
  _updateGeometry() {
    const geometry2 = new CubeGeometry();
    this.state.fillModel.setGeometry(geometry2);
  }
  draw({ uniforms }) {
    const { elevationScale, extruded, offset, coverage, cellSize, angle: angle3, radiusUnits } = this.props;
    const fillModel = this.state.fillModel;
    const columnProps = {
      radius: cellSize / 2,
      radiusUnits: UNIT[radiusUnits],
      angle: angle3,
      offset,
      extruded,
      stroked: false,
      coverage,
      elevationScale,
      edgeDistance: 1,
      isStroke: false,
      widthUnits: 0,
      widthScale: 0,
      widthMinPixels: 0,
      widthMaxPixels: 0
    };
    fillModel.shaderInputs.setProps({ column: columnProps });
    fillModel.draw(this.context.renderPass);
  }
};
GridCellLayer.layerName = "GridCellLayer";
GridCellLayer.defaultProps = defaultProps8;
var grid_cell_layer_default = GridCellLayer;

// node_modules/@deck.gl/layers/dist/path-layer/path.js
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length5 = path.length * size;
    flatPath = new Array(length5);
    for (let i2 = 0; i2 < path.length; i2++) {
      for (let j2 = 0; j2 < size; j2++) {
        flatPath[i2 * size + j2] = path[i2][j2] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, { size, gridResolution });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, { size });
  }
  return flatPath;
}

// node_modules/@deck.gl/layers/dist/path-layer/path-tesselator.js
var START_CAP = 1;
var END_CAP = 2;
var INVALID = 4;
var PathTesselator = class extends Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        // Padding covers shaderAttributes for last segment in largest case fp64
        // additional vertex + hi & low parts, 3 * 6
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: { size: 1, type: Uint8ClampedArray }
      }
    });
  }
  /** Get packed attribute by name */
  get(attributeName) {
    return this.attributes[attributeName];
  }
  /* Implement base Tesselator interface */
  getGeometryFromBuffer(buffer2) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer2);
    }
    return null;
  }
  /* Implement base Tesselator interface */
  normalizeGeometry(path) {
    if (this.normalize) {
      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  /* Implement base Tesselator interface */
  getGeometrySize(path) {
    if (isCut(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  /* Implement base Tesselator interface */
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const { vertexStart, geometrySize } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const { positions } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const { vertexStart, geometrySize } = context;
    const p2 = new Array(3);
    for (let i2 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i2++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p2);
      positions[i2 * 3] = p2[0];
      positions[i2 * 3 + 1] = p2[1];
      positions[i2 * 3 + 2] = p2[2];
    }
  }
  // Utilities
  /** Returns the number of points in the path */
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  /** Returns a point on the path at the specified index */
  getPointOnPath(path, index, target = []) {
    const { positionSize } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i2 = index * positionSize;
    target[0] = path[i2];
    target[1] = path[i2 + 1];
    target[2] = positionSize === 3 && path[i2 + 2] || 0;
    return target;
  }
  // Returns true if the first and last points are identical
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const { positionSize } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
};
function isCut(path) {
  return Array.isArray(path[0]);
}

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-uniforms.js
var uniformBlock6 = `uniform pathUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float jointType;
  float capType;
  float miterLimit;
  bool billboard;
  highp int widthUnits;
} path;
`;
var pathUniforms = {
  name: "path",
  vs: uniformBlock6,
  fs: uniformBlock6,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    jointType: "f32",
    capType: "f32",
    miterLimit: "f32",
    billboard: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = path.capType;
} else {
vJointType = path.jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),
path.widthMinPixels, path.widthMaxPixels) / 2.0);
vec3 width;
if (path.billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer.js
var DEFAULT_COLOR7 = [0, 0, 0, 255];
var defaultProps9 = {
  widthUnits: "meters",
  widthScale: { type: "number", min: 0, value: 1 },
  widthMinPixels: { type: "number", min: 0, value: 0 },
  widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  jointRounded: false,
  capRounded: false,
  miterLimit: { type: "number", min: 0, value: 4 },
  billboard: false,
  _pathType: null,
  getPath: { type: "accessor", value: (object) => object.path },
  getColor: { type: "accessor", value: DEFAULT_COLOR7 },
  getWidth: { type: "accessor", value: 1 },
  // deprecated props
  rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
};
var ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var PathLayer = class extends Layer {
  getShaders() {
    return super.getShaders({ vs: path_layer_vertex_glsl_default, fs: path_layer_fragment_glsl_default, modules: [project32_default, picking_default, pathUniforms] });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      vertexPositions: {
        size: 3,
        // Start filling buffer from 1 vertex in
        vertexOffset: 1,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getPath",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: "uint8",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        accessor: "getColor",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR7
      },
      instancePickingColors: {
        size: 4,
        type: "uint8",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new PathTesselator({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const { pathTesselator } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === "loop",
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d2) => d2.__source.index === index);
    }
    return info;
  }
  /** Override base Layer method */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data[i2].__source.index === objectIndex) {
          this._disablePickingIndex(i2);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { jointRounded, capRounded, billboard, miterLimit, widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
    const model = this.state.model;
    const pathProps = {
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    };
    model.shaderInputs.setProps({ path: pathProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const SEGMENT_INDICES = [
      // start corner
      0,
      1,
      2,
      // body
      1,
      4,
      2,
      1,
      3,
      4,
      // end corner
      3,
      5,
      4
    ];
    const SEGMENT_POSITIONS = [
      // bevel start corner
      0,
      0,
      // start inner corner
      0,
      -1,
      // start outer corner
      0,
      1,
      // end inner corner
      1,
      -1,
      // end outer corner
      1,
      1,
      // bevel end corner
      1,
      0
    ];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("positions");
  }
  calculateSegmentTypes(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("segmentTypes");
  }
};
PathLayer.defaultProps = defaultProps9;
PathLayer.layerName = "PathLayer";
var path_layer_default = PathLayer;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon.js
var import_earcut2 = __toESM(require_earcut(), 1);
var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
var windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i2 = 0; i2 < size; i2++) {
    if (positions[startIndex + i2] !== positions[endIndex - size + i2]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len5 = simplePolygon.length;
  for (let i2 = 0; i2 < len5; i2++) {
    for (let j2 = 0; j2 < size; j2++) {
      target[targetIndex++] = simplePolygon[i2][j2] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j2 = 0; j2 < size; j2++) {
      target[targetIndex++] = simplePolygon[0][j2] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i2 = 0; i2 < srcLength; i2++) {
    target[targetIndex++] = positions[srcStartIndex + i2];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i2 = 0; i2 < size; i2++) {
      target[targetIndex++] = positions[srcStartIndex + i2];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize5(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i2 = 0; i2 <= srcHoleIndices.length; i2++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i2 - 1], srcHoleIndices[i2], i2 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return { positions, holeIndices };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area = 0;
  for (let i2 = 0; i2 < numVerts; i2++) {
    const j2 = (i2 + 1) % numVerts;
    area += positions[i2 * 3 + xIndex] * positions[j2 * 3 + yIndex];
    area -= positions[j2 * 3 + xIndex] * positions[i2 * 3 + yIndex];
  }
  return Math.abs(area / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i2 = 0; i2 < numVerts; i2++) {
    const o2 = i2 * 3;
    const x2 = positions[o2 + 0];
    const y2 = positions[o2 + 1];
    const z2 = positions[o2 + 2];
    positions[o2 + xIndex] = x2;
    positions[o2 + yIndex] = y2;
    positions[o2 + zIndex] = z2;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n2 = positions.length;
    positions = positions.slice();
    const p2 = [];
    for (let i2 = 0; i2 < n2; i2 += positionSize) {
      p2[0] = positions[i2];
      p2[1] = positions[i2 + 1];
      if (is3d) {
        p2[2] = positions[i2 + 2];
      }
      const xy = preproject(p2);
      positions[i2] = xy[0];
      positions[i2 + 1] = xy[1];
      if (is3d) {
        positions[i2 + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {
    } else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 2, 0, 1);
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon-tesselator.js
var PolygonTesselator = class extends Tesselator {
  constructor(opts) {
    const { fp64: fp642, IndexType = Uint32Array } = opts;
    super({
      ...opts,
      attributes: {
        positions: { size: 3, type: fp642 ? Float64Array : Float32Array },
        vertexValid: { type: Uint16Array, size: 1 },
        indices: { type: IndexType, size: 1 }
      }
    });
  }
  /** Get attribute by name */
  get(attributeName) {
    const { attributes } = this;
    if (attributeName === "indices") {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  /** Override base Tesselator method */
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error("missing indices buffer");
    }
  }
  /** Implement base Tesselator interface */
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = normalize5(polygon, this.positionSize);
      if (this.opts.resolution) {
        return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  /** Implement base Tesselator interface */
  getGeometrySize(polygon) {
    if (isCut2(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return getPositions(polygon).length / this.positionSize;
  }
  /** Override base Tesselator method */
  getGeometryFromBuffer(buffer2) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer2);
    }
    return null;
  }
  /** Implement base Tesselator interface */
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut2(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      const normalizedPolygon = polygon;
      this._updateIndices(normalizedPolygon, context);
      this._updatePositions(normalizedPolygon, context);
      this._updateVertexValid(normalizedPolygon, context);
    }
  }
  // Flatten the indices array
  _updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
    const { attributes, indexStarts, typedArrayManager } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i2 = indexStart;
    const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j2 = 0; j2 < indices.length; j2++) {
      target[i2++] = indices[j2] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(polygon, { vertexStart, geometrySize }) {
    const { attributes: { positions }, positionSize } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = getPositions(polygon);
    for (let i2 = vertexStart, j2 = 0; j2 < geometrySize; i2++, j2++) {
      const x2 = polygonPositions[j2 * positionSize];
      const y2 = polygonPositions[j2 * positionSize + 1];
      const z2 = positionSize > 2 ? polygonPositions[j2 * positionSize + 2] : 0;
      positions[i2 * 3] = x2;
      positions[i2 * 3 + 1] = y2;
      positions[i2 * 3 + 2] = z2;
    }
  }
  _updateVertexValid(polygon, { vertexStart, geometrySize }) {
    const { positionSize } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j2 = 0; j2 < holeIndices.length; j2++) {
        vertexValid[vertexStart + holeIndices[j2] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
};
function isCut2(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-uniforms.js
var uniformBlock7 = `uniform solidPolygonUniforms {
  bool extruded;
  bool isWireframe;
  float elevationScale;
} solidPolygon;
`;
var solidPolygonUniforms = {
  name: "solidPolygon",
  vs: uniformBlock7,
  fs: uniformBlock7,
  uniformTypes: {
    extruded: "f32",
    isWireframe: "f32",
    elevationScale: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default = `in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project.commonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (solidPolygon.extruded) {
pos.z += props.elevations * solidPolygon.elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (solidPolygon.extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * layer.opacity);
} else {
vColor = vec4(colors.rgb, colors.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR8 = [0, 0, 0, 255];
var defaultProps10 = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  _full3d: false,
  elevationScale: { type: "number", min: 0, value: 1 },
  getPolygon: { type: "accessor", value: (f2) => f2.polygon },
  getElevation: { type: "accessor", value: 1e3 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR8 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR8 },
  material: true
};
var ATTRIBUTE_TRANSITION2 = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var SolidPolygonLayer = class extends Layer {
  getShaders(type) {
    return super.getShaders({
      vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
      fs: solid_polygon_layer_fragment_glsl_default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [project32_default, gouraudMaterial, picking_default, solidPolygonUniforms]
    });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const { viewport } = this.context;
    let { coordinateSystem } = this.props;
    const { _full3d } = this.props;
    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new PolygonTesselator({
        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
        // Provide a preproject function if the coordinates are in lnglat
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: Uint32Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(["instancePickingColors"]);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateIndices,
        noAlloc
      },
      vertexPositions: {
        size: 3,
        type: "float64",
        stepMode: "dynamic",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getPolygon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          nextVertexPositions: {
            vertexOffset: 1
          }
        }
      },
      instanceVertexValid: {
        size: 1,
        type: "uint16",
        stepMode: "instance",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getElevation"
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR8
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR8
      },
      pickingColors: {
        size: 4,
        type: "uint8",
        stepMode: "dynamic",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d2) => d2.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data[i2].__source.index === objectIndex) {
          this._disablePickingIndex(i2);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { extruded, filled, wireframe, elevationScale } = this.props;
    const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
    const renderUniforms = {
      extruded: Boolean(extruded),
      elevationScale,
      isWireframe: false
    };
    if (wireframeModel && wireframe) {
      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      wireframeModel.shaderInputs.setProps({ solidPolygon: { ...renderUniforms, isWireframe: true } });
      wireframeModel.draw(this.context.renderPass);
    }
    if (sideModel && filled) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      sideModel.draw(this.context.renderPass);
    }
    if (topModel && filled) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      topModel.draw(this.context.renderPass);
    }
  }
  updateState(updateParams) {
    var _a;
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const { props, oldProps, changeFlags } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      (_a = this.state.models) == null ? void 0 : _a.forEach((model) => model.destroy());
      this.setState(this._getModels());
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({ props, oldProps, changeFlags }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const { polygonTesselator } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels() {
    const { id, filled, extruded } = this.props;
    let topModel;
    let sideModel;
    let wireframeModel;
    if (filled) {
      const shaders = this.getShaders("top");
      shaders.defines.NON_INSTANCED_MODEL = 1;
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: false });
      topModel = new Model(this.context.device, {
        ...shaders,
        id: `${id}-top`,
        topology: "triangle-list",
        bufferLayout,
        isIndexed: true,
        userData: {
          excludeAttributes: { instanceVertexValid: true }
        }
      });
    }
    if (extruded) {
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: true });
      sideModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-side`,
        bufferLayout,
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            // top right - top left - bottom right - bottom left
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
      wireframeModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-wireframe`,
        bufferLayout,
        geometry: new Geometry({
          topology: "line-strip",
          attributes: {
            // top right - top left - bottom left - bottom right
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
    }
    return {
      models: [sideModel, wireframeModel, topModel].filter(Boolean),
      topModel,
      sideModel,
      wireframeModel
    };
  }
  calculateIndices(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get("indices");
  }
  calculatePositions(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get("positions");
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get("vertexValid");
  }
};
SolidPolygonLayer.defaultProps = defaultProps10;
SolidPolygonLayer.layerName = "SolidPolygonLayer";
var solid_polygon_layer_default = SolidPolygonLayer;

// node_modules/@deck.gl/layers/dist/utils.js
function replaceInRange({ data, getIndex, dataRange, replace }) {
  const { startRow = 0, endRow = Infinity } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;
  for (let i2 = 0; i2 < count; i2++) {
    const row = getIndex(data[i2]);
    if (replaceStart > i2 && row >= startRow) {
      replaceStart = i2;
    }
    if (row >= endRow) {
      replaceEnd = i2;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
  for (let i2 = 0; i2 < replace.length; i2++) {
    data[index++] = replace[i2];
  }
  if (endChunk) {
    for (let i2 = 0; i2 < endChunk.length; i2++) {
      data[index++] = endChunk[i2];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}

// node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js
var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultProps11 = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: { type: "accessor", value: (f2) => f2.polygon },
  // Polygon fill color
  getFillColor: { type: "accessor", value: defaultFillColor },
  // Point, line and polygon outline color
  getLineColor: { type: "accessor", value: defaultLineColor },
  // Line and polygon outline accessors
  getLineWidth: { type: "accessor", value: 1 },
  // Polygon extrusion accessor
  getElevation: { type: "accessor", value: 1e3 },
  // Optional material for 'lighting' shader module
  material: true
};
var PolygonLayer = class extends CompositeLayer {
  initializeState() {
    this.state = {
      paths: [],
      pathsDiff: null
    };
    if (this.props.getLineDashArray) {
      log_default.removed("getLineDashArray", "PathStyleExtension")();
    }
  }
  updateState({ changeFlags }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
        data: paths,
        getIndex: (p2) => p2.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({ paths, pathsDiff });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const { data, getPolygon, positionFormat, _normalize } = this.props;
    const paths = [];
    const positionSize = positionFormat === "XY" ? 2 : 3;
    const { startRow, endRow } = dataRange;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);
      if (_normalize) {
        polygon = normalize5(polygon, positionSize);
      }
      const { holeIndices } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i2 = 0; i2 <= holeIndices.length; i2++) {
          const path = positions.slice(holeIndices[i2 - 1] || 0, holeIndices[i2] || positions.length);
          paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
      }
    }
    return paths;
  }
  /* eslint-disable complexity */
  renderLayers() {
    const { data, _dataDiff, stroked, filled, extruded, wireframe, _normalize, _windingOrder, elevationScale, transitions, positionFormat } = this.props;
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified } = this.props;
    const { getFillColor, getLineColor, getLineWidth, getLineDashArray, getElevation, getPolygon, updateTriggers, material } = this.props;
    const { paths, pathsDiff } = this.state;
    const FillLayer = this.getSubLayerClass("fill", solid_polygon_layer_default);
    const StrokeLayer = this.getSubLayerClass("stroke", path_layer_default);
    const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: "fill",
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        // using a legacy API to invalid lineColor attributes
        // if (extruded && wireframe) has changed
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      // Already normalized
      _pathType: "loop",
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: "stroke",
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: (x2) => x2.path
    });
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer,
      polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer
    ];
  }
};
PolygonLayer.layerName = "PolygonLayer";
PolygonLayer.defaultProps = defaultProps11;
var polygon_layer_default = PolygonLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-binary.js
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: { ...data.properties[propertiesIndex] }
  };
  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 4);
    const pickingColor = [];
    for (let i2 = 0; i2 < featureIds.length; i2++) {
      encodePickingColor(featureIds[i2], pickingColor);
      pickingColors[key][i2 * 4 + 0] = pickingColor[0];
      pickingColors[key][i2 * 4 + 1] = pickingColor[1];
      pickingColors[key][i2 * 4 + 2] = pickingColor[2];
      pickingColors[key][i2 * 4 + 3] = 255;
    }
  }
  return pickingColors;
}

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/sdf-uniforms.js
var uniformBlock8 = `uniform sdfUniforms {
  float gamma;
  bool enabled;
  float buffer;
  float outlineBuffer;
  vec4 outlineColor;
} sdf;
`;
var sdfUniforms = {
  name: "sdf",
  vs: uniformBlock8,
  fs: uniformBlock8,
  uniformTypes: {
    gamma: "f32",
    enabled: "f32",
    buffer: "f32",
    outlineBuffer: "f32",
    outlineColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf.enabled) {
float distance = alpha;
alpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);
if (sdf.outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);
color = mix(sdf.outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * layer.opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER2 = 192 / 256;
var EMPTY_ARRAY = [];
var defaultProps12 = {
  getIconOffsets: { type: "accessor", value: (x2) => x2.offsets },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: { type: "color", value: [0, 0, 0, 255] }
};
var MultiIconLayer = class extends icon_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    return { ...shaders, modules: [...shaders.modules, sdfUniforms], fs: multi_icon_layer_fragment_glsl_default };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: "uint8",
        size: 3,
        accessor: (object, { index, target: value }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    let { outlineColor } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map((x2) => x2 / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
    }
  }
  draw(params) {
    const { sdf, smoothing, outlineWidth } = this.props;
    const { outlineColor } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
    const model = this.state.model;
    const sdfProps = {
      buffer: DEFAULT_BUFFER2,
      outlineBuffer,
      gamma: smoothing,
      enabled: Boolean(sdf),
      outlineColor
    };
    model.shaderInputs.setProps({ sdf: sdfProps });
    super.draw(params);
    if (sdf && outlineWidth) {
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        model.shaderInputs.setProps({ sdf: { ...sdfProps, outlineBuffer: DEFAULT_BUFFER2 } });
        model.draw(this.context.renderPass);
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }
};
MultiIconLayer.defaultProps = defaultProps12;
MultiIconLayer.layerName = "MultiIconLayer";
var multi_icon_layer_default = MultiIconLayer;

// node_modules/@mapbox/tiny-sdf/index.js
var INF = 1e20;
var TinySDF = class {
  constructor({
    fontSize = 24,
    buffer: buffer2 = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = "sans-serif",
    fontWeight = "normal",
    fontStyle = "normal"
  } = {}) {
    this.buffer = buffer2;
    this.cutoff = cutoff;
    this.radius = radius;
    const size = this.size = fontSize + buffer2 * 4;
    const canvas = this._createCanvas(size);
    const ctx = this.ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "left";
    ctx.fillStyle = "black";
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    return canvas;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len5 = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len5);
    const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
    if (glyphWidth === 0 || glyphHeight === 0) return glyph;
    const { ctx, buffer: buffer2, gridInner, gridOuter } = this;
    ctx.clearRect(buffer2, buffer2, glyphWidth, glyphHeight);
    ctx.fillText(char, buffer2, buffer2 + glyphTop);
    const imgData = ctx.getImageData(buffer2, buffer2, glyphWidth, glyphHeight);
    gridOuter.fill(INF, 0, len5);
    gridInner.fill(0, 0, len5);
    for (let y2 = 0; y2 < glyphHeight; y2++) {
      for (let x2 = 0; x2 < glyphWidth; x2++) {
        const a2 = imgData.data[4 * (y2 * glyphWidth + x2) + 3] / 255;
        if (a2 === 0) continue;
        const j2 = (y2 + buffer2) * width + x2 + buffer2;
        if (a2 === 1) {
          gridOuter[j2] = 0;
          gridInner[j2] = INF;
        } else {
          const d2 = 0.5 - a2;
          gridOuter[j2] = d2 > 0 ? d2 * d2 : 0;
          gridInner[j2] = d2 < 0 ? d2 * d2 : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer2, buffer2, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i2 = 0; i2 < len5; i2++) {
      const d2 = Math.sqrt(gridOuter[i2]) - Math.sqrt(gridInner[i2]);
      data[i2] = Math.round(255 - 255 * (d2 / this.radius + this.cutoff));
    }
    return glyph;
  }
};
function edt(data, x0, y0, width, height, gridSize, f2, v2, z2) {
  for (let x2 = x0; x2 < x0 + width; x2++) edt1d(data, y0 * gridSize + x2, gridSize, height, f2, v2, z2);
  for (let y2 = y0; y2 < y0 + height; y2++) edt1d(data, y2 * gridSize + x0, 1, width, f2, v2, z2);
}
function edt1d(grid, offset, stride, length5, f2, v2, z2) {
  v2[0] = 0;
  z2[0] = -INF;
  z2[1] = INF;
  f2[0] = grid[offset];
  for (let q2 = 1, k2 = 0, s2 = 0; q2 < length5; q2++) {
    f2[q2] = grid[offset + q2 * stride];
    const q22 = q2 * q2;
    do {
      const r2 = v2[k2];
      s2 = (f2[q2] - f2[r2] + q22 - r2 * r2) / (q2 - r2) / 2;
    } while (s2 <= z2[k2] && --k2 > -1);
    k2++;
    v2[k2] = q2;
    z2[k2] = s2;
    z2[k2 + 1] = INF;
  }
  for (let q2 = 0, k2 = 0; q2 < length5; q2++) {
    while (z2[k2 + 1] < q2) k2++;
    const r2 = v2[k2];
    const qr = q2 - r2;
    grid[offset + q2 * stride] = f2[r2] + qr * qr;
  }
}

// node_modules/@deck.gl/layers/dist/text-layer/utils.js
var MISSING_CHAR_WIDTH = 32;
var SINGLE_LINE = [];
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2({ characterSet, getFontWidth, fontHeight, buffer: buffer2, maxCanvasWidth, mapping = {}, xOffset = 0, yOffset = 0 }) {
  let row = 0;
  let x2 = xOffset;
  const rowHeight = fontHeight + buffer2 * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x2 + width + buffer2 * 2 > maxCanvasWidth) {
        x2 = 0;
        row++;
      }
      mapping[char] = {
        x: x2 + buffer2,
        y: yOffset + row * rowHeight + buffer2,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x2 += width + buffer2 * 2;
    }
  }
  return {
    mapping,
    xOffset: x2,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  var _a;
  let width = 0;
  for (let i2 = startIndex; i2 < endIndex; i2++) {
    const character = text[i2];
    width += ((_a = mapping[character]) == null ? void 0 : _a.layoutWidth) || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i2 = startIndex; i2 < endIndex; i2++) {
    const textWidth = getTextWidth(text, i2, i2 + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i2) {
        target.push(i2);
      }
      rowStartCharIndex = i2;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i2 = startIndex; i2 < endIndex; i2++) {
    if (text[i2] === " ") {
      groupEndCharIndex = i2 + 1;
    } else if (text[i2 + 1] === " " || i2 + 1 === endIndex) {
      groupEndCharIndex = i2 + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x2 = 0;
  let rowHeight = 0;
  for (let i2 = startIndex; i2 < endIndex; i2++) {
    const character = line[i2];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i2] = x2 + frame.layoutWidth / 2;
      x2 += frame.layoutWidth;
    } else {
      log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
      leftOffsets[i2] = x2;
      x2 += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x2;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  var _a;
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x2 = new Array(numCharacters);
  const y2 = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i2 = 0; i2 <= numCharacters; i2++) {
    const char = characters[i2];
    if (char === "\n" || i2 === numCharacters) {
      lineEndIndex = i2;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x2, rowSize);
        for (let j2 = rowStart; j2 < rowEnd; j2++) {
          const rowOffsetLeft = x2[j2] - rowSize[0] / 2;
          const char2 = characters[j2];
          const layoutOffsetY = ((_a = iconMapping[char2]) == null ? void 0 : _a.layoutOffsetY) || 0;
          y2[j2] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j2] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x2[lineStartIndex] = 0;
      y2[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return { x: x2, y: y2, rowWidth, size };
}
function getTextFromBuffer({ value, length: length5, stride, offset, startIndices, characterSet }) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length5] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length5);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i2 = 0; i2 < characterCount; i2++) {
      codes[i2] = value[i2 * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length5; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return { texts, characterCount };
}

// node_modules/@deck.gl/layers/dist/text-layer/lru-cache.js
var LRUCache = class {
  constructor(limit = 5) {
    this._cache = {};
    this._order = [];
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i2 = 32; i2 < 128; i2++) {
    charSet.push(String.fromCharCode(i2));
  }
  return charSet;
}
var DEFAULT_FONT_SETTINGS = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache = new LRUCache(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i2 = 0; i2 < alphaChannel.length; i2++) {
    imageData.data[4 * i2 + 3] = alphaChannel[i2];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache = new LRUCache(limit);
}
var FontAtlasManager = class {
  constructor() {
    this.props = { ...DEFAULT_FONT_SETTINGS };
  }
  get atlas() {
    return this._atlas;
  }
  // TODO - cut during v9 porting as types reveal this is not correct
  // get texture(): Texture | undefined {
  //   return this._atlas;
  // }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const { fontSize, buffer: buffer2 } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer2 * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }
  // eslint-disable-next-line max-statements
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const { fontFamily, fontWeight, fontSize, buffer: buffer2, sdf, radius, cutoff } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const { mapping, canvasHeight, xOffset, yOffset } = buildMapping2({
      getFontWidth: (char) => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer: buffer2,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    });
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new TinySDF({
        fontSize,
        buffer: buffer2,
        radius,
        cutoff,
        fontFamily,
        fontWeight: `${fontWeight}`
      });
      for (const char of characterSet) {
        const { data, width, height, glyphTop } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer2 + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  _getKey() {
    const { fontFamily, fontWeight, fontSize, buffer: buffer2, sdf, radius, cutoff } = this.props;
    if (sdf) {
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer2} ${radius} ${cutoff}`;
    }
    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer2}`;
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-uniforms.js
var uniformBlock9 = `uniform textBackgroundUniforms {
  bool billboard;
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  vec4 borderRadius;
  vec4 padding;
  highp int sizeUnits;
  bool stroked;
} textBackground;
`;
var textBackgroundUniforms = {
  name: "textBackground",
  vs: uniformBlock9,
  fs: uniformBlock9,
  uniformTypes: {
    billboard: "f32",
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    borderRadius: "vec4<f32>",
    padding: "vec4<f32>",
    sizeUnits: "i32",
    stroked: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),
textBackground.sizeMinPixels, textBackground.sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (textBackground.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
float round_rect(vec2 p, vec2 size, vec4 radii) {
vec2 pixelPositionCB = (p - 0.5) * size;
vec2 sizeCB = size * 0.5;
float maxBorderRadius = min(size.x, size.y) * 0.5;
vec4 borderRadius = vec4(min(radii, maxBorderRadius));
borderRadius.xy =
(pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;
borderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;
vec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;
return -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);
}
float rect(vec2 p, vec2 size) {
vec2 pixelPosition = p * size;
return min(min(pixelPosition.x, size.x - pixelPosition.x),
min(pixelPosition.y, size.y - pixelPosition.y));
}
vec4 get_stroked_fragColor(float dist) {
float isBorder = smoothedge(dist, vLineWidth);
return mix(vFillColor, vLineColor, isBorder);
}
void main(void) {
geometry.uv = uv;
if (textBackground.borderRadius != vec4(0.0)) {
float distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);
if (textBackground.stroked) {
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
float shapeAlpha = smoothedge(-distToEdge, 0.0);
fragColor.a *= shapeAlpha;
} else {
if (textBackground.stroked) {
float distToEdge = rect(uv, dimensions);
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer.js
var defaultProps13 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  borderRadius: { type: "object", value: 0 },
  padding: { type: "array", value: [0, 0, 0, 0] },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
  getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineWidth: { type: "accessor", value: 1 }
};
var TextBackgroundLayer = class extends Layer {
  getShaders() {
    return super.getShaders({ vs: text_background_layer_vertex_glsl_default, fs: text_background_layer_fragment_glsl_default, modules: [project32_default, picking_default, textBackgroundUniforms] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { changeFlags } = params;
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
    let { padding, borderRadius } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    if (!Array.isArray(borderRadius)) {
      borderRadius = [borderRadius, borderRadius, borderRadius, borderRadius];
    }
    const model = this.state.model;
    const textBackgroundProps = {
      billboard,
      stroked: Boolean(getLineWidth),
      borderRadius,
      padding,
      sizeUnits: UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    };
    model.shaderInputs.setProps({ textBackground: textBackgroundProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [0, 0, 1, 0, 0, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        vertexCount: 4,
        attributes: {
          positions: { size: 2, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
TextBackgroundLayer.defaultProps = defaultProps13;
TextBackgroundLayer.layerName = "TextBackgroundLayer";
var text_background_layer_default = TextBackgroundLayer;

// node_modules/@deck.gl/layers/dist/text-layer/text-layer.js
var TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
var ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
var DEFAULT_COLOR9 = [0, 0, 0, 255];
var DEFAULT_LINE_HEIGHT = 1;
var defaultProps14 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
  getBorderColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getBorderWidth: { type: "accessor", value: 0 },
  backgroundBorderRadius: { type: "object", value: 0 },
  backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
  characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: { type: "number", value: 0, min: 0 },
  outlineColor: { type: "color", value: DEFAULT_COLOR9 },
  fontSettings: { type: "object", value: {}, compare: 1 },
  // auto wrapping options
  wordBreak: "break-word",
  maxWidth: { type: "number", value: -1 },
  getText: { type: "accessor", value: (x2) => x2.text },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getSize: { type: "accessor", value: 32 },
  getAngle: { type: "accessor", value: 0 },
  getTextAnchor: { type: "accessor", value: "middle" },
  getAlignmentBaseline: { type: "accessor", value: "center" },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  // deprecated
  backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
var TextLayer = class extends CompositeLayer {
  constructor() {
    super(...arguments);
    this.getBoundingRect = (object, objectInfo) => {
      let { size: [width, height] } = this.transformParagraph(object, objectInfo);
      const { fontSize } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    };
    this.getIconOffsets = (object, objectInfo) => {
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const { x: x2, y: y2, rowWidth, size: [width, height] } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x2.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i2 = 0; i2 < numCharacters; i2++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i2]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x2[i2];
        offsets[index++] = (anchorY - 1) * height / 2 + y2[i2];
      }
      return offsets;
    };
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new FontAtlasManager()
    };
    if (this.props.maxWidth > 0) {
      log_default.once(1, "v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
    }
  }
  // eslint-disable-next-line complexity
  updateState(params) {
    const { props, oldProps, changeFlags } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({ info }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  /** Returns true if font has changed */
  _updateFontAtlas() {
    const { fontSettings, fontFamily, fontWeight } = this.props;
    const { fontAtlasManager, characterSet } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  // Text strings are variable width objects
  // Count characters and start offsets
  _updateText() {
    var _a;
    const { data, characterSet } = this.props;
    const textBuffer = (_a = data.attributes) == null ? void 0 : _a.getText;
    let { getText } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
    if (textBuffer && startIndices) {
      const { texts, characterCount } = getTextFromBuffer({
        ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
        // @ts-ignore if data.attribute is defined then length is expected
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_2, { index }) => texts[index];
    } else {
      const { iterable, objectInfo } = createIterable(data);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || "");
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  /** There are two size systems in this layer:
  
      + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
        The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
        in layer props is roughly equivalent to font-size: 24px in CSS.
      + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
        which depends on how large each character is drawn into the font atlas. This is controlled by
        fontSettings.fontSize (default 64) and most users do not set it manually.
        These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
  
      All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
  /** Calculate the size and position of each character in a text string.
   * Values are in texture size */
  transformParagraph(object, objectInfo) {
    const { fontAtlasManager } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const { wordBreak, lineHeight, maxWidth } = this.props;
    const paragraph = getText(object, objectInfo) || "";
    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const { startIndices, numInstances, getText, fontAtlasManager: { scale: scale7, atlas, mapping }, styleVersion } = this.state;
    const { data, _dataDiff, getPosition, getColor, getSize, getAngle: getAngle2, getPixelOffset, getBackgroundColor, getBorderColor, getBorderWidth, backgroundBorderRadius, backgroundPadding, background, billboard, fontSettings, outlineWidth, outlineColor, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, transitions, updateTriggers } = this.props;
    const CharactersLayerClass = this.getSubLayerClass("characters", multi_icon_layer_default);
    const BackgroundLayerClass = this.getSubLayerClass("background", text_background_layer_default);
    return [
      background && new BackgroundLayerClass({
        // background props
        getFillColor: getBackgroundColor,
        getLineColor: getBorderColor,
        getLineWidth: getBorderWidth,
        borderRadius: backgroundBorderRadius,
        padding: backgroundPadding,
        // props shared with characters layer
        getPosition,
        getSize,
        getAngle: getAngle2,
        getPixelOffset,
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getSize: transitions.getSize,
          getFillColor: transitions.getBackgroundColor,
          getLineColor: transitions.getBorderColor,
          getLineWidth: transitions.getBorderWidth,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getSize: updateTriggers.getSize,
          getFillColor: updateTriggers.getBackgroundColor,
          getLineColor: updateTriggers.getBorderColor,
          getLineWidth: updateTriggers.getBorderWidth,
          getPixelOffset: updateTriggers.getPixelOffset,
          getBoundingRect: {
            getText: updateTriggers.getText,
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data: (
          // @ts-ignore (2339) attribute is not defined on all data types
          data.attributes && data.attributes.background ? (
            // @ts-ignore (2339) attribute is not defined on all data types
            { length: data.length, attributes: data.attributes.background }
          ) : data
        ),
        _dataDiff,
        // Maintain the same background behavior as <=8.3. Remove in v9?
        autoHighlight: false,
        getBoundingRect: this.getBoundingRect
      }),
      new CharactersLayerClass({
        sdf: fontSettings.sdf,
        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
        outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
        outlineColor,
        iconAtlas: atlas,
        iconMapping: mapping,
        getPosition,
        getColor,
        getSize,
        getAngle: getAngle2,
        getPixelOffset,
        billboard,
        sizeScale: sizeScale * scale7,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale7,
        sizeMaxPixels: sizeMaxPixels * scale7,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: updateTriggers.getText,
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data,
        _dataDiff,
        startIndices,
        numInstances,
        getIconOffsets: this.getIconOffsets,
        getIcon: getText
      })
    ];
  }
  static set fontAtlasCacheLimit(limit) {
    setFontAtlasCacheLimit(limit);
  }
};
TextLayer.defaultProps = defaultProps14;
TextLayer.layerName = "TextLayer";
var text_layer_default = TextLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/sub-layer-map.js
var POINT_LAYER = {
  circle: {
    type: scatterplot_layer_default,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: icon_layer_default,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: text_layer_default,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
};
var LINE_LAYER = {
  type: path_layer_default,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
};
var POLYGON_LAYER = {
  type: solid_polygon_layer_default,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function getDefaultProps({ type, props }) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const { transitions, updateTriggers } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{ geometry: geojson }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const { startRow = 0, endRow = features.length } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const { geometry: geometry2 } = feature;
    if (!geometry2) {
      continue;
    }
    if (geometry2.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry2.geometries), "GeoJSON does not have geometries array");
      const { geometries } = geometry2;
      for (let i2 = 0; i2 < geometries.length; i2++) {
        const subGeometry = geometries[i2];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry2, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry2, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const { type, coordinates } = geometry2;
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn(`${type} coordinates are malformed`)();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry: geometry2
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point) => {
        pointFeatures.push(wrapFeature({
          geometry: { type: "Point", coordinates: point }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry: geometry2
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry: geometry2
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: { type: "Polygon", coordinates: polygon }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: { type: "LineString", coordinates: path }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
var COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f2) {
  return f2.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const { points, lines, polygons } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js
var FEATURE_TYPES = ["points", "linestrings", "polygons"];
var defaultProps15 = {
  ...getDefaultProps(POINT_LAYER.circle),
  ...getDefaultProps(POINT_LAYER.icon),
  ...getDefaultProps(POINT_LAYER.text),
  ...getDefaultProps(LINE_LAYER),
  ...getDefaultProps(POLYGON_LAYER),
  // Overwrite sub layer defaults
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: { type: "object", value: null },
  iconMapping: { type: "object", value: {} },
  getIcon: { type: "accessor", value: (f2) => f2.properties.icon },
  getText: { type: "accessor", value: (f2) => f2.properties.text },
  // Self props
  pointType: "circle",
  // TODO: deprecated, remove in v9
  getRadius: { deprecatedFor: "getPointRadius" }
};
var GeoJsonLayer = class extends CompositeLayer {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {},
      featuresDiff: {}
    };
  }
  updateState({ props, changeFlags }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const { data } = this.props;
    const binary = data && "points" in data && "polygons" in data && "lines" in data;
    this.setState({ binary });
    if (binary) {
      this._updateStateBinary({ props, changeFlags });
    } else {
      this._updateStateJSON({ props, changeFlags });
    }
  }
  _updateStateBinary({ props, changeFlags }) {
    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
    this.setState({ layerProps });
  }
  _updateStateJSON({ props, changeFlags }) {
    const features = getGeojsonFeatures(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push(replaceInRange({
            data: newFeatures[key],
            getIndex: (f2) => f2.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = separateGeojsonFeatures(features, wrapFeature);
    }
    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index, sourceLayer } = info;
    info.featureType = FEATURE_TYPES.find((ft2) => sourceLayer.id.startsWith(`${this.id}-${ft2}-`));
    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = `${this.id}-points-`;
    const sourceIsPoints = info.featureType === "points";
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    var _a;
    const { extruded, wireframe } = this.props;
    const { layerProps } = this.state;
    const id = "polygons-fill";
    const PolygonFillLayer = this.shouldRenderSubLayer(id, (_a = layerProps.polygons) == null ? void 0 : _a.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    var _a, _b;
    const { extruded, stroked } = this.props;
    const { layerProps } = this.state;
    const polygonStrokeLayerId = "polygons-stroke";
    const lineStringsLayerId = "linestrings";
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, (_a = layerProps.polygonsOutline) == null ? void 0 : _a.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, (_b = layerProps.lines) == null ? void 0 : _b.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = forwardProps(this, LINE_LAYER.props);
      return [
        PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
          id: polygonStrokeLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygonsOutline),
        LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
          id: lineStringsLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.lines)
      ];
    }
    return null;
  }
  _renderPointLayers() {
    var _a;
    const { pointType } = this.props;
    const { layerProps, binary } = this.state;
    let { highlightedObjectIndex } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex((d2) => d2.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split("+"));
    const pointLayers = [];
    for (const type of types) {
      const id = `points-${type}`;
      const PointLayerMapping = POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, (_a = layerProps.points) == null ? void 0 : _a.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = forwardProps(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === "text" && binary) {
          const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            // @ts-expect-error TODO - type binary data
            data: { ...pointsLayerProps.data, attributes: rest }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const { extruded } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer,
      lineLayers,
      pointLayers,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer
    ];
  }
  getSubLayerAccessor(accessor) {
    const { binary } = this.state;
    if (!binary || typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const { data, index } = info;
      const feature = binaryToFeatureForAccesor(data, index);
      return accessor(feature, info);
    };
  }
};
GeoJsonLayer.layerName = "GeoJsonLayer";
GeoJsonLayer.defaultProps = defaultProps15;
var geojson_layer_default = GeoJsonLayer;
export {
  arc_layer_default as ArcLayer,
  bitmap_layer_default as BitmapLayer,
  column_layer_default as ColumnLayer,
  geojson_layer_default as GeoJsonLayer,
  grid_cell_layer_default as GridCellLayer,
  icon_layer_default as IconLayer,
  line_layer_default as LineLayer,
  path_layer_default as PathLayer,
  point_cloud_layer_default as PointCloudLayer,
  polygon_layer_default as PolygonLayer,
  scatterplot_layer_default as ScatterplotLayer,
  solid_polygon_layer_default as SolidPolygonLayer,
  text_layer_default as TextLayer,
  multi_icon_layer_default as _MultiIconLayer,
  text_background_layer_default as _TextBackgroundLayer
};
//# sourceMappingURL=@deck__gl_layers.js.map
